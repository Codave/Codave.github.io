<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>C++语法06-静态成员</title>
      <link href="/2019/04/21/C++%E8%AF%AD%E6%B3%9506-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/"/>
      <url>/2019/04/21/C++%E8%AF%AD%E6%B3%9506-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/</url>
      
        <content type="html"><![CDATA[<h1 id="1-静态数据成员"><a href="#1-静态数据成员" class="headerlink" title="1. 静态数据成员"></a>1. 静态数据成员</h1><blockquote><p>为了实现同一个类的多个对象之间的数据共享，C++提出了静态数据成员的概念。在一个类中 ，若将一个数据成员说明成static，这种成员被称为静态数据成员。与一般的数据成员不同，无论建立多少个类的对象，都只有一个静态数据成员的拷贝。从而实现了同一个类中的不同对象之间的数据共享。</p></blockquote><p>定义静态数据成员的格式如下：</p><p><strong>static  数据类型  数据成员名</strong></p><p>说明：</p><p>（1）静态数据成员的定义与普通数据成员相似，但前面要加上static关键字。</p><p>（2）静态数据成员的初始化与普通数据成员不同。静态数据成员初始化应在类外单独进行，而且应在定义对象之前进行。一般在主函数main之前，类声明之后的特殊地带为它提供定义和初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">初始化的格式如下：</span><br><span class="line">数据类型  类名：：静态数据成员名=初始值；</span><br></pre></td></tr></table></figure><p>（3）静态数据成员属于类（准确地说，是属于类对象的集合），而不像普通数据成员那样属于某一对象，因此可以使用使用“类名：”访问静态的数据成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用类名访问静态数据成员的格式如下：</span><br><span class="line">类名：静态数据成员名</span><br></pre></td></tr></table></figure><p>（4）静态数据成员与静态变量一样，是在编译时创建并初始化。它在该类的任何对象被建立之前就存在。因此，公有的静态数据成员可以在对象定义之前被访问。对象定义后，公有的静态数据成员，也可以通过对象进行访问。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象名.静态数据成员名；</span><br><span class="line">对象指针-&gt;静态数据成员名；</span><br></pre></td></tr></table></figure><p>（5）私有静态数据成员不能在类外直接访问，必须通过公有的成员函数访问。</p><p>（6）C++支持静态数据成员的一个重要原因是可以不必使用全局变量。依赖于全局变量的类几乎都是违反面向对象程序设计的封装特性的。静态数据成员主要用作类的所有对象所共有的数据，如统计总数、平均数等。</p><h1 id="2-静态成员函数"><a href="#2-静态成员函数" class="headerlink" title="2. 静态成员函数"></a>2. 静态成员函数</h1><blockquote><p>在类定义中，前面有static说明的成员函数被称为静态成员函数。静态成员函数属于整个类，是该类所有对象共享的成员函数，而不是类中的某个对象。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">定义静态成员函数的格式如下：</span><br><span class="line"><span class="keyword">static</span>  返回类型  静态成员函数名（参数表）;</span><br><span class="line"></span><br><span class="line">与静态数据成员类似，调用公有静态成员函数的一般格式有如下几种：</span><br><span class="line">(<span class="number">1</span>) 类名::静态成员函数名（实参名）</span><br><span class="line">(<span class="number">2</span>) 对象.静态成员函数名（实参名）</span><br><span class="line">(<span class="number">3</span>) 对象指针-&gt;静态成员函数名（实参名）</span><br></pre></td></tr></table></figure><p>例：静态成员函数访问静态数据成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Small_cat</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Small_cat(<span class="keyword">double</span> w);</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">total_disp</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> weight;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> total_weight;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> total_number;</span><br><span class="line">&#125;;</span><br><span class="line">Small_cat::Small_cat(<span class="keyword">double</span> w)&#123;</span><br><span class="line">    weight=w;</span><br><span class="line">    total_weight+=w;</span><br><span class="line">    total_number++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Small_cat::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"这只小猫的重量是："</span>&lt;&lt;weight&lt;&lt;<span class="string">"千克\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Small_cat::total_disp()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;total_number&lt;&lt;<span class="string">"只小猫的总重量是："</span>；</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;total_weight&lt;&lt;<span class="string">"千克"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> Small_cat::total_weight = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> Small_cat::total_number = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Small_cat w1(0.5),w2(0.6),w3(0.4);</span><br><span class="line">    w1.display();</span><br><span class="line">    w2.display();</span><br><span class="line">    w3.display();</span><br><span class="line">    Samll_cat::total_disp();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面对静态成员函数的使用再作几点说明：</p><p>（1）一般情况下，静态函数成员主要用来访问静态数据成员。当它与静态数据成员一起使用时，达到了对同一个类中对象之间共享数据的目的。</p><p>（2）私有静态成员函数不能做类外部的函数和对象访问。</p><p>（3）使用静态成员函数的一个原因是，可以用它在建立任何对象之前调用静态成员函数，以处理静态数据成员，这是普通成员函数不能实现的功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Small_cat::total_disp();<span class="comment">//可以用它在建立任何对象之前调用静态成员函数</span></span><br><span class="line">    Small_cat w1(0.5),w2(0.6),w3(0.4);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）编译系统将静态成员函数限定为内部连接，也就是说，与现行文件相连接的其他文件中的同名函数不会与该函数发生冲突，维护了该函数使用的安全性，这是使用静态成员函数的另一个原因。</p><p>（5）静态成员函数是类的一部分，而不是对象的一部分。</p><p>（6）静态成员函数与非静态成员函数的重要的区别是：非静态成员函数有this指针，而静态成员函数没有this指针。<strong>静态成员函数可以直接访问本类中的静态数据成员，因为静态数据成员同样是属于类的，可以直接访问。</strong>一般而言，静态成员函数不访问类中的非静态成员。若确实需要访问非静态数据成员，静态成员函数只能通过对象名（或对象指针、对象引用）访问该对象的非静态成员。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 静态成员 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++语法05-对象的赋值和复制</title>
      <link href="/2019/04/20/C++%E8%AF%AD%E6%B3%9505-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%B5%8B%E5%80%BC%E5%92%8C%E5%A4%8D%E5%88%B6/"/>
      <url>/2019/04/20/C++%E8%AF%AD%E6%B3%9505-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%B5%8B%E5%80%BC%E5%92%8C%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="1-对象赋值语句"><a href="#1-对象赋值语句" class="headerlink" title="1. 对象赋值语句"></a>1. 对象赋值语句</h1><blockquote><p>这里所指的对象的赋值是指对其中的数据成员赋值，而不是对成员函数赋值。</p></blockquote><p>例如：A和B是同一类的两个对象，那么下述对象赋值语句 B=A；就能把对象A的数据成员的值逐位复制给对象B。</p><p>说明：</p><p>（1）在使用对象赋值语句进行对象赋值时，两个对象的类型必须相同，如对象的类型不相同，编译时将出错。</p><p>（2） 两个对象之间的赋值，仅仅使这些对象中数据成员相同，而两个对象仍是分离的。</p><p>（3）将一个对象的值赋给另一个对象时，多数情况下都是成功的，但当类中存在指针时，可能会产生错误。</p><h1 id="2-拷贝构造函数"><a href="#2-拷贝构造函数" class="headerlink" title="2. 拷贝构造函数"></a>2. 拷贝构造函数</h1><blockquote><p>拷贝构造函数是一种特殊的构造函数，其形参是本类对象的引用。拷贝构造函数的作用是，在建立一个新的对象时，使用一个已经存在的对象去初始化这个新对象。</p></blockquote><p>例如： Point p2（p1);</p><p>其作用是，在建立新对象p2时，用已经存在的对象p1去初始化新对象p2，在这个过程中就要调用拷贝构造函数。</p><p>拷贝构造函数具有以下特点：</p><p>（1）因为该函数也是一种构造函数，所以其函数名与类名相同，并且该函数也没有返回值类型。</p><p>（2）该函数只有一个参数，并且是同类对象的引用。</p><p>（3）每个类都必须有一个拷贝构造构造函数。程序员可以自定义拷贝构造函数，用于按照需要初始化新对象。如果程序员没有定义类的拷贝构造函数，系统就会自动生成产生一个默认拷贝构造函数，用于复制出数据成员值完全相同的新对象。</p><h1 id="2-1-自定义拷贝构造函数"><a href="#2-1-自定义拷贝构造函数" class="headerlink" title="2.1 自定义拷贝构造函数"></a>2.1 自定义拷贝构造函数</h1><p>自定义拷贝函数的一般形式如下：</p><p><strong>类名：：类名（const 类名 &amp;对象名）{</strong></p><p>​        <strong>//拷贝构造函数的函数体</strong></p><p><strong>}</strong></p><p>调用拷贝构造函数的一般形式为：</p><p>（1）代入法： <strong>类名  对象2（对象1）；</strong></p><p>（2）赋值法： <strong>类名  对象2 = 对象1；</strong></p><h1 id="2-2-默认拷贝构造函数"><a href="#2-2-默认拷贝构造函数" class="headerlink" title="2.2 默认拷贝构造函数"></a>2.2 默认拷贝构造函数</h1><blockquote><p>每个类都必须有一个拷贝构造函数。如果程序员没有定义拷贝构造函数，系统就会自动生成一个默认拷贝构造函数，用于复制出完全相同的新对象。</p></blockquote><p>在通常情况下，默认拷贝函数是能够胜任工作的，但如果类中有指针类型时，调用默认拷贝构造函数有时会产生错误，使用时要予以注意。</p><h1 id="2-3-调用拷贝构造函数的3种情况"><a href="#2-3-调用拷贝构造函数的3种情况" class="headerlink" title="2.3 调用拷贝构造函数的3种情况"></a>2.3 调用拷贝构造函数的3种情况</h1><blockquote><p>普通的构造函数是在对象创建时被调用，而拷贝构造函数在以下3种情况下都会被调用。</p></blockquote><p>（1）当用类的一个对象去初始化该类的另一个对象时，拷贝构造函数将会被调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">Point p3=p1;</span><br></pre></td></tr></table></figure><p>（2）当函数的形参是类的对象，在调用函数进行形参和实参结合时，拷贝构造函数将会调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">(Point p)</span></span>&#123;</span><br><span class="line">    p.print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">    fun1(p1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）当函数的返回值是类的对象，在函数调用完毕将返回值（对象）带回函数调用处时。此时就会调用拷贝构造函数，将此对象复制给一个临时对象并传到该函数的调用处。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">fun2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">10</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Point p2;</span><br><span class="line">    p2=fun2();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对象赋值 </tag>
            
            <tag> 对象复制 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++语法04-向函数传递对象</title>
      <link href="/2019/04/20/C++%E8%AF%AD%E6%B3%9504-%E5%90%91%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/04/20/C++%E8%AF%AD%E6%B3%9504-%E5%90%91%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="1-使用对象作为函数参数"><a href="#1-使用对象作为函数参数" class="headerlink" title="1. 使用对象作为函数参数"></a>1. 使用对象作为函数参数</h1><blockquote><p>对象可以作为参数传递给函数，其方法与传递基本类型的变量相同。在向函数传递对象时，是通过“传值调用”传递给函数的，即单向传递，只由实参传给形参，而不能由形参传回来给实参。<strong>因此函数中对对象的任何修改均不影响调用该函数的对象（实参）本身。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tr</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Tr(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        i=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_i</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        i=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_i</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sqr_it</span><span class="params">(Tr ob)</span></span>&#123;</span><br><span class="line">    ob.set_i(ob.get_i()*ob.get_i());</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"在函数sqr_it内，形参对象ob的数据成员i的值为："</span>&lt;&lt;ob.get_i();      <span class="comment">//100</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Tr <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"调用函数sqr_it前，实参对象obj的数据成员i的值为："</span>;         <span class="comment">//10</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;obj.get_i()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    sqr_it(obj);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"调用函数sqr_it后，实参对象obj的数据成员i的值为："</span>;        <span class="comment">//10</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;obj.get_i();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-使用对象指针作为函数参数"><a href="#2-使用对象指针作为函数参数" class="headerlink" title="2. 使用对象指针作为函数参数"></a>2. 使用对象指针作为函数参数</h1><blockquote><p>对象指针可以作为函数的参数，使用对象指针作为函数参数可以实现“传址调用”，即在函数调用时使实参对象和形参对象指针变量指向同一内存地址，在函数调用过程中，<strong>对形参对象指针值的改变也同样影响着实参对象的值</strong>。<strong>当函数的形参是对象指针时，调用函数的对应实参应该是某个对象的地址值。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tr</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Tr(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        i=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_i</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        i=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_i</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sqr_it</span><span class="params">(Tr *ob)</span></span>&#123;</span><br><span class="line">    ob-&gt;set_i(ob-&gt;get_i()*ob-&gt;get_i());</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"在函数sqr_it内，形参对象ob的数据成员i的值为："</span>&lt;&lt;ob-&gt;get_i();        <span class="comment">//100</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Tr <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"调用函数sqr_it前，实参对象obj的数据成员i的值为："</span>;           <span class="comment">//10</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;obj.get_i()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    sqr_it(&amp;obj);      <span class="comment">//传地址</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"调用函数sqr_it后，实参对象obj的数据成员i的值为："</span>;            <span class="comment">//100</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;obj.get_i();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-使用对象引用作为函数参数"><a href="#3-使用对象引用作为函数参数" class="headerlink" title="3. 使用对象引用作为函数参数"></a>3. 使用对象引用作为函数参数</h1><blockquote><p>在实际中，使用对象引用作为函数参数非常普遍，大部分程序员喜欢用对象引用取代对象指针作为函数参数。因为使用对象引用作为函数参数不但具有对象指针用作函数参数的优点，而且用对象引用作为函数参数将<strong>更简单、更直接</strong>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tr</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Tr(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        i=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_i</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        i=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_i</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sqr_it</span><span class="params">(Tr &amp;ob)</span></span>&#123;</span><br><span class="line">    ob.set_i(ob.get_i()*ob.get_i());</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"在函数sqr_it内，形参对象ob的数据成员i的值为："</span>&lt;&lt;ob.get_i();<span class="comment">//100</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Tr <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"调用函数sqr_it前，实参对象obj的数据成员i的值为："</span>;   <span class="comment">//10</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;obj.get_i()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    sqr_it(obj);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"调用函数sqr_it后，实参对象obj的数据成员i的值为："</span>;<span class="comment">//100</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;obj.get_i();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数传参 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++语法03-对象数组与对象指针</title>
      <link href="/2019/04/20/C++%E8%AF%AD%E6%B3%9503-%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88/"/>
      <url>/2019/04/20/C++%E8%AF%AD%E6%B3%9503-%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="1-对象数组"><a href="#1-对象数组" class="headerlink" title="1. 对象数组"></a>1. 对象数组</h1><blockquote><p>所谓对象数组是指每一个数组元素都是对象的数组，也就是说，若一个类有若干个对象，我们把这一系列的对象用一个数组来存放。对象数组的元素是对象，不仅具有数据成员，而且还有函数成员。</p></blockquote><p>定义一个一维数组的格式如下：</p><p><strong>类名 数组名[下标表达式]</strong></p><p>例如有10个复数，每个复数的属性包括实部与虚部。如果为每一个复数建立一个对象，需要分别取10个对象名。显然用程序处理起来很不方便。这时可以定义一个复数类Complex的对象数组，每一个数组元素是Complex类的一个对象，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex com[<span class="number">10</span>];<span class="comment">//定义类Complex的对象数组com,含有10个对象数组元素</span></span><br></pre></td></tr></table></figure><p>在建立数组时，同样要调用构造函数。有几个数组元素就要调用几次构造函数。例如有10个数组元素 ，就要调用10次构造函数。类Complex的构造函数有两个参数，分别用于给实部数据和虚部数据赋值。<strong>如果构造函数只有1个参数，在定义对象数组时可以直接在等号后面的花括号内提供实参。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用只有1个参数的构造函数给对象数组赋值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">exam</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        exam(<span class="keyword">int</span> n)&#123;</span><br><span class="line">            x=n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">get_x</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    exam ob1[<span class="number">4</span>]=&#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>,<span class="number">44</span>&#125;;<span class="comment">//用只有1个参数的构造函数给对象数组赋值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        cout&lt;&lt;ob1[i].get_x()&lt;&lt;'';</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与基本数据类型的数组一样，在使用对象数组时也只能访问单个数组元素，其一般形式是：</p><p>​                        <strong>数组名  [下标].成员名</strong></p><p>以上例子中构造函数只有一个参数，如果构造函数有多个参数，在定义对象数组时应当怎样实现初始化？我们只要在花括号中分别写出构造函数并指定实参即可。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Complex com[<span class="number">3</span>]=&#123;        <span class="comment">//定义对象数组com</span></span><br><span class="line">    Complex(<span class="number">1.1</span>, <span class="number">2.2</span>);</span><br><span class="line">    Complex(<span class="number">3.3</span>, <span class="number">4.4</span>);</span><br><span class="line">    Complex(<span class="number">5.5</span>, <span class="number">6.6</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于这个对象数组有3个对象数组元素，因此在建立对象数组时，3次调用构造函数，对每一个对象数组元素初始化。<strong>当1个数组中的数组元素被删除时，系统会调用析构函数来完成扫尾工作，有几个对象数组元素就会调用几次析构函数。</strong></p><h1 id="2-对象指针"><a href="#2-对象指针" class="headerlink" title="2. 对象指针"></a>2. 对象指针</h1><blockquote><p>每一个对象在初始化后都会在内存占有一定的空间。因此，既可以通过对象名访问一个对象，也可以通过对象地址来访问一个对象。对象指针就是用于存放对象地址的变量。</p></blockquote><p>声明对象指针的一般语法形式为：</p><p>​                            <strong>类名 *对象指针名</strong></p><p><strong>（1）用指针访问单个对象成员</strong>：</p><p>​    说明对象指针的语法和说明其他数据类型指针的语法相同。使用对象指针时，首先要把它指向一个已创建的对象，然后才能引用该对象的成员。</p><p>​    在一般情况下，用点运算符“.”来访问对象成员，当用指向对象的指针来访问对象成员时，就要用“-&gt;”操作符。</p><p><strong>（2）用对象指针访问对象数组</strong></p><p>​    对象指针不仅能引用单个对象，也能访问对象数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    exe ob[<span class="number">2</span>]; <span class="comment">//定义类exe的对象数组ob[2]</span></span><br><span class="line">    exe *p; <span class="comment">//定义指向类exe的对象指针变量p</span></span><br><span class="line">    ob[<span class="number">0</span>].set_a(<span class="number">10</span>); <span class="comment">//</span></span><br><span class="line">    ob[<span class="number">0</span>].set_b(<span class="number">20</span>);</span><br><span class="line">    p=ob;</span><br><span class="line">    p-&gt;show_a();</span><br><span class="line">    p++;      <span class="comment">//一般而言，当指针加1或减1时，它总是指向其基本类型中相邻的一个元素，对象指针也是如此</span></span><br><span class="line">    p-&gt;show_a();  </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-this指针"><a href="#3-this指针" class="headerlink" title="3. this指针"></a>3. this指针</h1><p>// TODO</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 对象数组 </tag>
            
            <tag> 对象指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++语法02-构造函数和析构函数</title>
      <link href="/2019/04/19/C++%E8%AF%AD%E6%B3%9502-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
      <url>/2019/04/19/C++%E8%AF%AD%E6%B3%9502-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-对象的初始化和构造函数"><a href="#1-对象的初始化和构造函数" class="headerlink" title="1. 对象的初始化和构造函数"></a>1. 对象的初始化和构造函数</h1><blockquote><p><strong>类是一种抽象的数据类型，它不占存储空间，不能容纳具体的数据。因此在类声明中不能给数据成员赋初值。</strong>与使用变量一样，使用对象时也应该先定义，后使用。在定义对象时，对数据成员赋初值，称为对象的初始化。在定义对象时，如果某一数据成员没有被赋值，则它的值是不可预知的。对象是一个实体，在使用对象时，它的每一个数据成员都应该有确定的值。</p></blockquote><p>如果一个类中的所有成员，都是共有的，则可以在定义对象时对数据成员进行初始化。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">double</span> real;</span><br><span class="line">    <span class="keyword">double</span> imag;</span><br><span class="line">&#125;;</span><br><span class="line">Complex c1=&#123;<span class="number">1.1</span>,<span class="number">2.2</span>&#125;;</span><br></pre></td></tr></table></figure><p>说明：这种方法类似于结构体变量初始化的方法。但是，如果类中包含私有的或保护的成员时，就不能用这种方法进行初始化。除了调用公有成员函数来给数据成员赋值，C++提供了一个更好的方法，利用构造函数来完成对象的初始化。</p><blockquote><p>构造函数是一种特殊的成员函数，它主要用于为对象分配对象，进行初始化。构造函数的名字必须和类名相同，而不能由用户任意命名。它可以有任意类型的参数，但不能具有返回值类型。它不需要用户来调用，而是在建立对象时自动执行的。</p></blockquote><p><strong>在建立对象的同时，采用构造函数给成员赋初值，通常有以下两种形式。</strong></p><p><strong>形式1：</strong></p><p><strong>类名  对象名[(实参表)]</strong></p><p><strong>形式2：</strong></p><p><strong>类名  *指针变量名=new 类名[(实参表)]</strong></p><p>说明：这时编译系统开辟了一段内存空间，并在此空间中存放了一个Complex类对象，同时调用了该类的构造函数给数据成员赋初值。这个对象没有名字，称为无名对象。但是该对象有地址，这个地址存放在指针变量pa中。访问用new动态建立的对象一般是不用对象的，而是通过指针访问。</p><p><strong>注意：</strong></p><p>（1）当new建立的对象使用结束时，不再需要它时，可以用delete运算符予以释放<code>delete pa</code>。</p><p>（2）与普通成员函数一样，构造函数的函数体可写在类体内（系统将构造函数作为内联函数处理），也可以写在类体外。</p><p>（3）构造函数一般声明为公有函数，它是在定义对象的同时被自动调用的，而且只执行一次。</p><p>（4）如果没有给类定义构造函数，则编译系统自动地生成一个默认构造函数。<strong>（这个默认的构造函数不带任何参数，函数体是空的，它只能为对象开辟数据成员存储空间，而不能给对象中的数据成员赋值）</strong></p><p>（5）构造函数可以不带参数，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Complex()&#123;   <span class="comment">//不带参数的构造函数</span></span><br><span class="line">    real=<span class="number">0</span>;</span><br><span class="line">    imag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex A;   <span class="comment">//定义类Complex的对象A时调用不要带参数，也不要要带括号！！！</span></span><br></pre></td></tr></table></figure><h1 id="2-用成员初始化列表对数据成员初始化"><a href="#2-用成员初始化列表对数据成员初始化" class="headerlink" title="2. 用成员初始化列表对数据成员初始化"></a>2. 用成员初始化列表对数据成员初始化</h1><blockquote><p>C++还提供另一种初始化数据成员的方法——用成员初始化列表对数据成员初始化。这种方法不在函数体内用赋值语句对数据成员初始化，而是在函数首部实现的。</p></blockquote><p>带有成员初始化列表的构造函数的一般形式如下：</p><p><strong>类名：：构造函数名（[参数表])[:(成员初始化列表)]{</strong></p><p>​        <strong>//构造函数体</strong></p><p><strong>}</strong></p><p>成员初始化列表的一般形式为：</p><p><strong>数据成员名1（初始值1），数据成员名2（初始值2），…..</strong></p><p><strong>注意:</strong></p><p>（1）对于用<code>const</code>修饰的数据成员，或是引用类型的数据成员，是不允许用赋值语句直接赋值的。因此，只能用成员初始化列表对其进行初始化。</p><p>（2）数据成员是按照它们在类中声明的顺序进行初始化的，与它们在成员初始化列表中列出的顺序无关。</p><h1 id="3-构造函数的重载"><a href="#3-构造函数的重载" class="headerlink" title="3. 构造函数的重载"></a>3. 构造函数的重载</h1><blockquote><p>与一般的成员函数一样，C++允许构造函数重载，以适应不同的场合。</p></blockquote><p><strong>注意：</strong></p><p>（1）使用无参构造函数创建对象时，应该用语句“Date date1；”，而不能用语句“Date date1()；”。因为语句“Date date1()；”表示声明一个名为date1的普通函数，此函数的返回值为Date类型。</p><p>（2）如果在类中用户没有定义构造函数，系统会自动提供一个函数体为空的默认构造函数。但是，只要类中定义了一个构造函数（不一定是无参构造函数），系统将不再给它提供默认构造函数。</p><h1 id="4-带默认参数的构造函数"><a href="#4-带默认参数的构造函数" class="headerlink" title="4. 带默认参数的构造函数"></a>4. 带默认参数的构造函数</h1><blockquote><p>对于带参数的构造函数，在定义对象时必须给构造函数的形参传递参数的值，否则构造函数将不被执行。但在实际使用中，有些构造函数的参数值在大部分情况是相同的，只有在特殊情况下才需要改变它的参数值。</p></blockquote><p><strong>说明：</strong></p><p>（1）如果构造函数在类的声明外定义，那么默认参数在类内声明构造函数原型时指定，而不能在类外构造函数定义时指定。因为类的声明是放在头文件中的，用户可以看到，而构造函数的定义是类的实现细节，用户往往看不到。因此，在声明时指定默认参数，可以保证用户在建立对象时知道怎么使用默认参数。</p><p>（2）如果构造函数的全部参数都指定了默认值，则在定义对象时可以指定1个或几个实参，也可以不给出实参，这时的构造函数也属于默认构造函数。<strong>因为一个类只能有一个默认构造函数，因此不能同时再声明无参数的默认构造函数。</strong>否则，编译系统将无法识别应该调用哪个构造函数，因此产生了二义性。</p><p>（3）在一个类中定义了全部是默认参数的构造函数后，不能再定义重载构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例如在一个类中有以下构造函数的声明</span><br><span class="line">Complex(<span class="keyword">double</span> r=<span class="number">0.0</span>, <span class="keyword">double</span> i=<span class="number">0.0</span>);</span><br><span class="line">Complex(<span class="keyword">double</span> r);</span><br><span class="line"></span><br><span class="line">如果用以下语句定义对象</span><br><span class="line">Complex S2（<span class="number">1.1</span>）；     <span class="comment">//无法判断应该调用以上哪个构造函数</span></span><br></pre></td></tr></table></figure><p>因此，一般不要同时使用构造函数的重载和有默认参数的构造函数。</p><h1 id="5-析构函数"><a href="#5-析构函数" class="headerlink" title="5. 析构函数"></a>5. 析构函数</h1><blockquote><p>析构函数也是一种特殊的成员函数。它执行与构造函数相反的操作，通常用于执行一些清理任务，如释放分配给对象的内存空间等。析构函数有如下一些特点：</p><p>（1）析构函数名与类名相同，但它前面必须加一个波浪号（~）。</p><p>（2）析构函数不返回任何值。在定义析构函数时，是不能说明它的类型的，甚至说明为void也不行。</p><p>（3）析构函数没有参数，因此它不能被重载。<strong>一个类可以有多个构造函数，但只能有一个析构函数。</strong></p><p>（4）撤销对象时，编译系统会自动地调用析构函数。</p></blockquote><p><strong>说明：</strong></p><p>（1）每个类必须有一个析构函数。若没有显示地为一个类定义析构函数，则编译系统会自动地生成一个默认析构函数。**对于大多数而言，这个默认析构函数就能满足要求。但是，如果在一个对象撤销之前需要完成另外一些处理工作的话，则应该显示地定义析构函数。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String_data</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        String_data(<span class="keyword">char</span> *s)&#123;</span><br><span class="line">            str=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s)+<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(str, s);</span><br><span class="line">        &#125;</span><br><span class="line">        ~String_data()&#123;</span><br><span class="line">            <span class="keyword">delete</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">get_info</span><span class="params">(<span class="keyword">char</span>*)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sent_info</span><span class="params">(<span class="keyword">char</span>*)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是构造函数和析构函数最常见的用法，即在构造函数中用运算符new为字符串分配存储空间，最后在析构函数中用运算符delete释放已分配的存储空间。</p><p>（2）除了在主函数结束（或调用exit函数）时，对象被撤销，系统会自动调用析构函数外，在以下情况，析构函数也会被调用：</p><ul><li>如果一个对象被定义在一个函数体内，则当这个函数被调用结束时，该对象将释放，析构函数被自动调用。</li><li>若一个对象时使用new运算符动态创建的，在使用delete运算符释放它时，delete会自动调用析构函数。</li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 构造函数 </tag>
            
            <tag> 析构函数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C++语法01-类和对象的基本概念</title>
      <link href="/2019/04/07/C++%E8%AF%AD%E6%B3%9501-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2019/04/07/C++%E8%AF%AD%E6%B3%9501-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="1-结构体的扩充"><a href="#1-结构体的扩充" class="headerlink" title="1. 结构体的扩充"></a>1. 结构体的扩充</h1><blockquote><p>结构体是C语言的一种自定义的数据类型，在结构体中可以含有多种不同类型的数据。C++语言对结构体类型进行了扩充，它不仅可以含有不同类型的数据，而且还可以含有函数。</p></blockquote><p>例如下面声明了一个扩充的结构体Complex:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span>&#123;</span><span class="comment">//声明了一个名为Complex的结构体</span></span><br><span class="line">    <span class="keyword">double</span> real;<span class="comment">//复试的实部    </span></span><br><span class="line">    <span class="keyword">double</span> imag;<span class="comment">//复试的虚部</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">double</span> r,<span class="keyword">double</span> i)</span></span>&#123;</span><br><span class="line">        real=r;</span><br><span class="line">        imag=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">abscomplex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> t;</span><br><span class="line">        t=real*real+imag*imag;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体中的数据和成员都是结构体的成员，在C++中，通常把结构体中的数据成为数据成员，把函数称为成员函数。为了访问这些成员函数，必须先定义该结构体类型的变量，然后像访问结构体中的数据一样进行访问。</p><p><strong>C++提供了一种比结构体更安全有效的数据类型-类</strong>。类与结构体的扩充形式十分相似。上面的结构体类型Complex可以用类改写如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span><span class="comment">//声明了一个名为Complex的类</span></span><br><span class="line">    <span class="keyword">double</span> real;<span class="comment">//数据成员，复试的实部    </span></span><br><span class="line">    <span class="keyword">double</span> imag;<span class="comment">//数据成员，复试的虚部</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">double</span> r,<span class="keyword">double</span> i)</span></span>&#123;<span class="comment">//成员函数</span></span><br><span class="line">        real=r;</span><br><span class="line">        imag=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">abscomplex</span><span class="params">()</span></span>&#123;<span class="comment">//成员函数</span></span><br><span class="line">        <span class="keyword">double</span> t;</span><br><span class="line">        t=real*real+imag*imag;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>类是一种数据类型，它是一种用户定义的抽象的函数类型。C++规定，在默认情况下，类中的成员是私有的，结构体中成员是共有的。</p></blockquote><h1 id="2-类的声明"><a href="#2-类的声明" class="headerlink" title="2. 类的声明"></a>2. 类的声明</h1><p>可以得出，类类型声明的一般形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名&#123;</span></span><br><span class="line">    [<span class="keyword">private</span>:]</span><br><span class="line">    私有数据成员和成员函数</span><br><span class="line">    [<span class="keyword">public</span>:]</span><br><span class="line">        公有数据成员和成员函数</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>(1)私有成员(用private声明)包括数据成员和成员函数只能被类内的成员函数访问，公有成员(用public声明)包括数据成员和成员函数既可被类内的成员函数访问，也可被类外的对象访问。</p><p>(2)除了private和public之外，类中的成员还可以用另一个关键字protected来说明。被protected说明的数据成员和成员函数称为保护成员。保护成员可以由本类的成员函数访问，也可以由本类的派生类的成员函数访问。</p><p>(3)数据成员可以是任何数据成员，但不能是用自动(auto)、寄存器(register)或外部(extern)进行说明。</p><h1 id="3-成员函数的定义"><a href="#3-成员函数的定义" class="headerlink" title="3. 成员函数的定义"></a>3. 成员函数的定义</h1><blockquote><p>类的成员函数是函数的一种，它也有函数名、返回值类型和参数表，用法和普通函数差不多，只是它属于一个类的成员。<strong>成员函数可以访问本类中任何成员（包括private、protected、public）</strong>。</p></blockquote><p><strong>成员函数的三种定义方式</strong></p><blockquote><p><strong>第一种</strong>：在类声明中只给出成员函数的原型，而将成员函数的定义放在类的外部。<strong>(类内声明，类外定义)</strong></p></blockquote><p>这种成员函数在类外定义的一般形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 类名：：成员函数名（参数表）&#123;</span><br><span class="line">    </span><br><span class="line">    函数体</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：在类声明中，成员函数的原型的参数表中可以不说明参数的名字，而只说明它们的类型。<strong>但是</strong>，在类外定义成员函数时，不但要说明参数表中的参数的类型，还必须要指出其参数名。</p><blockquote><p><strong>第二种：</strong>将成员函数直接定义在类的内部。</p></blockquote><p><strong>说明</strong>：编译器会将这些函数隐含地定义为内联成员函数。这种定义内联成员内联函数的方法没有使用关键字<strong>inline</strong>进行声明，因此称为<strong>隐式定义</strong>。</p><blockquote><p>第三种：在类内函数原型声明前或在类外定义成员函数前冠以关键字<strong>inline</strong>，因此称为<strong>显示定义</strong>。</p></blockquote><p><strong>说明</strong>：可以在声明函数原型和定义函数时同时写inline，也可以在其中一处声明inline，效果是相同的。都能按内联函数处理 。使用inline定义内联函数时，必须将类的声明和内联成员函数的定义都放在同一个文件（或同一个头文件中），否则编译时无法进行代码置换。</p><h1 id="4-对象的定义及使用"><a href="#4-对象的定义及使用" class="headerlink" title="4. 对象的定义及使用"></a>4. 对象的定义及使用</h1><h2 id="4-1-对象的定义"><a href="#4-1-对象的定义" class="headerlink" title="4.1 对象的定义"></a>4.1 对象的定义</h2><p>可以用以下两种方法定义对象：</p><p>（1）在声明类的同时，直接定义对象。即直接在声明类的右花括号“}”后，直接写出属于该类的对象名表。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setpoint</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getx</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gety</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;op1,op2;</span><br></pre></td></tr></table></figure><p>在声明类Point的同时，直接定义了对象op1,op2。</p><p>（2）声明了类之后，在使用时再定义对象。其一般形式如下：<code>类名 对象名1，对象名2，..... ;</code></p><p>例如<code>Point op1,op2;</code></p><h2 id="4-2-对象中成员的访问"><a href="#4-2-对象中成员的访问" class="headerlink" title="4.2 对象中成员的访问"></a>4.2 对象中成员的访问</h2><blockquote><p>不论是数据成员，还是函数成员，只要是公有的，在类的外部可以通过类的对象进行访问。访问对象中的成员通常有一下三种方法。</p></blockquote><p>（1）<strong>通过对象名和对象选择符访问对象中的成员</strong></p><p>​    其一般形式是： <code>对象名.数据成员名</code> 或者 <code>对象名.成员函数名[(实参表)]</code></p><p>​    说明：<code>.</code>叫做对象选择符，简称点运算符</p><p>（2）<strong>通过指向对象的指针访问对象中的成员</strong></p><p>​    在定义对象时，若我们定义的是指向此对象的指针，则访问此对象的成员时，不能用<code>.</code>操作符，而应该使用<code>-&gt;</code>操作符。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">Date d,*ptr;</span><br><span class="line">ptr=&amp;d;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ptr-&gt;year;</span><br></pre></td></tr></table></figure><p>在此，<code>ptr-&gt;year</code>表示<code>ptr</code>当前指向对象中<code>d</code>中的成员<code>year</code>，因为<code>（*ptr)</code>就是对象<code>d</code>，<code>(*ptr).year</code>表示的也就是对象<code>d</code>中的成员<code>year</code>。所以有如下等价关系：</p><p><img src="/2019/04/07/C++语法01-类和对象的基本概念/1.png" alt="图1"></p><p>（3）<strong>通过对象的引用访问对象中的成员</strong></p><p>​    如果为了一个对象定义了一个引用，也就是为这个对象起了一个别名、因此完全可以通过引用来访问对象中的成员，其方法与通过对象名来访问对象中的成员是相同的。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">Date d1;</span><br><span class="line">Date &amp;d2=d1;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;d1.year;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;d2.year;</span><br></pre></td></tr></table></figure><p>由于d2是d1的引用（即d2和d1占有相同的存储单），因此d2.year和d1.year是相同的。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类和对象 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux基础07-其他命令</title>
      <link href="/2019/03/24/Linux%E5%9F%BA%E7%A1%8007-%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/03/24/Linux%E5%9F%BA%E7%A1%8007-%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="1-查找文件"><a href="#1-查找文件" class="headerlink" title="1. 查找文件"></a>1. 查找文件</h1><ul><li><code>find</code> 命令功能非常强大，通常用来在 <strong>特定的目录下</strong> <strong>搜索</strong> 符合条件的文件</li></ul><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>find [路径] -name “*.py”</td><td>查找指定路径下扩展名是 <code>.py</code> 的文件，包括子目录</td></tr></tbody></table><ul><li>如果省略路径，表示在当前文件夹下查找</li><li>之前学习的通配符，在使用 <code>find</code> 命令时同时可用</li><li>有关 <code>find</code> 的高级使用，见高级语法</li></ul><h2 id="演练目标"><a href="#演练目标" class="headerlink" title="演练目标"></a>演练目标</h2><ol><li>搜索桌面目录下，文件名包含 <code>1</code> 的文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name <span class="string">"*1*"</span></span><br></pre></td></tr></table></figure><ol start="2"><li>搜索桌面目录下，所有以 <code>.txt</code> 为扩展名的文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name <span class="string">"*.txt"</span></span><br></pre></td></tr></table></figure><ol start="3"><li>搜索桌面目录下，以数字 <code>1</code> 开头的文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name <span class="string">"1*"</span></span><br></pre></td></tr></table></figure><h1 id="2-软链接"><a href="#2-软链接" class="headerlink" title="2. 软链接"></a>2. 软链接</h1><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ln -s 被链接的源文件 链接文件</td><td>建立文件的软链接，用通俗的方式讲<strong>类似于</strong> Windows 下的<strong>快捷方式</strong></td></tr></tbody></table><p>注意：</p><ol><li><p>没有-s选项建立的是一个硬链接文件,两个文件占用相同大小的硬盘空间，<strong>工作中几乎不会建立文件的硬链接</strong></p></li><li><p><strong>源文件要使用绝对路径</strong>，不能使用相对路径，这样可以方便移动链接文件后，仍然能够正常使用</p></li></ol><h2 id="演练目标-1"><a href="#演练目标-1" class="headerlink" title="演练目标"></a>演练目标</h2><ol><li>将桌面目录下的 <code>01.py</code> <strong>移动</strong>到 <code>demo/b/c</code> 目录下</li><li>在桌面目录下新建01.py的软链接FirstPython<br> 分别使用 <strong>相对路径</strong> 和 <strong>绝对路径</strong> 建立 <code>FirstPython</code> 的软链接</li><li>将 <code>FirstPython</code> <strong>移动</strong>到 <code>demo</code> 目录下，对比使用 <strong>相对路径</strong> 和 <strong>绝对路径</strong> 的区别</li></ol><h2 id="硬链接简介"><a href="#硬链接简介" class="headerlink" title="硬链接简介"></a>硬链接简介</h2><ul><li>在使用 <code>ln</code> 创建链接时，如果没有 <code>-s</code> 选项，会创建一个 <strong>硬链接</strong>，而不是软链接</li></ul><h3 id="硬链接演练"><a href="#硬链接演练" class="headerlink" title="硬链接演练"></a>硬链接演练</h3><ol><li>在 <code>~/Desktop/demo</code> 目录下建立 <code>~/Desktop/demo/b/c/01.py</code> 的硬链接 <code>01_hard</code></li><li>使用 <code>ls -l</code> 查看文件的<strong>硬链接数</strong>（硬链接——有多少种方式可以访问文件或者目录）</li><li>删除 <code>~/Desktop/demo/b/c/01.py</code>，并且使用 <code>tree</code> 来确认 <code>demo</code> 目录下的三个链接文件</li></ol><blockquote><p>在 Linux 中，<strong>文件名</strong> 和 <strong>文件的数据</strong> 是分开存储的</p></blockquote><p><strong>提示：</strong></p><ul><li>在 Linux 中，只有文件的 <code>硬链接数 == 0</code> 才会被删除</li><li>使用 <code>ls -l</code> 可以查看一个文件的硬链接的数量</li><li>在日常工作中，几乎不会建立文件的硬链接，知道即可</li></ul><h1 id="3-打包压缩"><a href="#3-打包压缩" class="headerlink" title="3. 打包压缩"></a>3. 打包压缩</h1><ul><li><strong>打包压缩</strong> 是日常工作中备份文件的一种方式</li><li>在不同操作系统中，常用的打包压缩方式是不同的<ul><li><code>Windows</code> 常用 <code>rar</code></li><li><code>Mac</code> 常用 <code>zip</code></li><li><code>Linux</code> 常用 <code>tar.gz</code></li></ul></li></ul><h2 id="3-1-打包-／-解包"><a href="#3-1-打包-／-解包" class="headerlink" title="3.1 打包 ／ 解包"></a>3.1 打包 ／ 解包</h2><ul><li><code>tar</code> 是 Linux 中最常用的 <strong>备份</strong>工具，此命令可以 <strong>把一系列文件</strong> 打包到 <strong>一个大文件中</strong>，也可以把一个 <strong>打包的大文件恢复成一系列文件</strong></li><li><code>tar</code> 的命令格式如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打包文件</span></span><br><span class="line">tar -cvf 打包文件.tar 被打包的文件／路径...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解包文件</span></span><br><span class="line">tar -xvf 打包文件.tar</span><br></pre></td></tr></table></figure><ul><li><code>tar</code> 选项说明</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>c</td><td>生成档案文件，创建打包文件</td></tr><tr><td>x</td><td>解开档案文件</td></tr><tr><td>v</td><td>列出归档解档的详细过程，显示进度</td></tr><tr><td>f</td><td>指定档案文件名称，f 后面一定是 .tar 文件，所以必须放选项最后</td></tr></tbody></table><blockquote><p>注意：<code>f</code> 选项必须放在最后，其他选项顺序可以随意</p></blockquote><h3 id="打包解包演练"><a href="#打包解包演练" class="headerlink" title="打包解包演练"></a>打包解包演练</h3><ol><li>删除桌面下的所有内容</li><li>在桌面下新建三个空白文件 <code>01.py</code>、<code>02.py</code>、<code>03.py</code></li><li>将这三个文件打一个 <code>py.tar</code> 的包</li><li>新建 <code>tar</code> 目录，并且将 <code>py.tar</code> 移动到 <code>tar</code> 目录下</li><li>解包 <code>py.tar</code></li></ol><h2 id="3-2-压缩／解压缩"><a href="#3-2-压缩／解压缩" class="headerlink" title="3.2 压缩／解压缩"></a>3.2 压缩／解压缩</h2><h3 id="1-gzip"><a href="#1-gzip" class="headerlink" title="1) gzip"></a>1) <code>gzip</code></h3><ul><li>tar与gzip命令结合可以使用实现文件打包和压缩<ul><li><code>tar</code> 只负责打包文件，但不压缩</li><li>用 <code>gzip</code> 压缩 <code>tar</code> 打包后的文件，其扩展名一般用 <code>xxx.tar.gz</code></li></ul></li></ul><blockquote><p>在 <code>Linux</code> 中，最常见的压缩文件格式就是 <code>xxx.tar.gz</code></p></blockquote><ul><li>在 <code>tar</code> 命令中有一个选项 <strong>-z</strong> 可以调用 <code>gzip</code>，从而可以方便的实现压缩和解压缩的功能</li><li>命令格式如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压缩文件</span></span><br><span class="line">tar -zcvf 打包文件.tar.gz 被压缩的文件／路径...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩文件</span></span><br><span class="line">tar -zxvf 打包文件.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩到指定路径</span></span><br><span class="line">tar -zxvf 打包文件.tar.gz -C 目标路径</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-C</td><td>解压缩到指定目录，注意：要解压缩的目录必须存在</td></tr></tbody></table><h3 id="2-bzip2"><a href="#2-bzip2" class="headerlink" title="2) bzip2"></a>2) <code>bzip2</code></h3><ul><li><code>tar</code> 与 <code>bzip2</code> 命令结合可以使用实现文件 <strong>打包和压缩</strong>（用法和 <code>gzip</code> 一样）<ul><li><code>tar</code> 只负责打包文件，但不压缩，</li><li>用 <code>bzip2</code> 压缩 <code>tar</code> 打包后的文件，其扩展名一般用 <code>xxx.tar.bz2</code></li></ul></li><li>在 <code>tar</code> 命令中有一个选项 <strong>-j</strong> 可以调用 <code>bzip2</code>，从而可以方便的实现压缩和解压缩的功能</li><li>命令格式如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压缩文件</span></span><br><span class="line">tar -jcvf 打包文件.tar.bz2 被压缩的文件／路径...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩文件</span></span><br><span class="line">tar -jxvf 打包文件.tar.bz2</span><br></pre></td></tr></table></figure><h1 id="4-软件安装"><a href="#4-软件安装" class="headerlink" title="4. 软件安装"></a>4. 软件安装</h1><h2 id="4-1-通过-apt-安装／卸载软件"><a href="#4-1-通过-apt-安装／卸载软件" class="headerlink" title="4.1 通过 apt 安装／卸载软件"></a>4.1 通过 apt 安装／卸载软件</h2><ul><li>apt 是 <code>Advanced Packaging Tool</code>，是 Linux 下的一款安装包管理工具</li><li>可以在终端中方便的 <strong>安装</strong>／<strong>卸载</strong>／<strong>更新软件包</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 安装软件</span></span><br><span class="line">$ sudo apt install 软件包</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 卸载软件</span></span><br><span class="line">$ sudo apt remove 软件名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 更新已安装的包</span></span><br><span class="line">$ sudo apt upgrade</span><br></pre></td></tr></table></figure><h3 id="安装演练"><a href="#安装演练" class="headerlink" title="安装演练"></a>安装演练</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个小火车提示</span></span><br><span class="line">$ sudo apt install sl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个比较漂亮的查看当前进程排名的软件</span></span><br><span class="line">$ sudo apt install htop</span><br></pre></td></tr></table></figure><h2 id="4-2-配置软件源"><a href="#4-2-配置软件源" class="headerlink" title="4.2 配置软件源"></a>4.2 配置软件源</h2><p>在Ubantu18.04版本在系统设置里面是找不到软件源设置界面按钮的，可用如下指令帮助启动图形界面以便设置软件源。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-manager -c -d</span><br></pre></td></tr></table></figure><ul><li><p>如果希望在 <code>ubuntu</code> 中安装软件，<strong>更加快速</strong>，可以通过设置<strong>镜像源</strong>，选择一个访问网速更快的服务器，来提供软件下载／安装服务</p></li><li><p>提示：更换服务器之后，需要一个相对比较长时间的更新过程，需要耐心等待。更新完成后，再安装软件都会从新设置的服务器下载软件了</p></li></ul><blockquote><p>所谓镜像源，就是<strong>所有服务器的内容是相同的（镜像）</strong>，但是根据所在位置不同，国内服务器通常速度会更快一些！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux基础06-系统信息相关命令</title>
      <link href="/2019/03/24/Linux%E5%9F%BA%E7%A1%8006-%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/03/24/Linux%E5%9F%BA%E7%A1%8006-%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="1-时间和日期"><a href="#1-时间和日期" class="headerlink" title="1. 时间和日期"></a>1. 时间和日期</h1><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>date</td><td>查看系统时间</td></tr><tr><td>02</td><td>cal</td><td><code>calendar</code> 查看日历，<code>-y</code> 选项可以查看一年的日历</td></tr></tbody></table><h1 id="2-磁盘信息"><a href="#2-磁盘信息" class="headerlink" title="2. 磁盘信息"></a>2. 磁盘信息</h1><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>df -h</td><td><code>disk free</code> 显示磁盘剩余空间</td></tr><tr><td>02</td><td>du -h [目录名]</td><td><code>disk usage</code> 显示目录下的文件大小</td></tr></tbody></table><ul><li>选项说明</li></ul><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-h</td><td>以人性化的方式显示文件大小</td></tr></tbody></table><h1 id="3-进程信息"><a href="#3-进程信息" class="headerlink" title="3. 进程信息"></a>3. 进程信息</h1><ul><li>所谓 <strong>进程</strong>，通俗地说就是 <strong>当前正在执行的一个程序</strong></li></ul><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ps aux</td><td><code>process status</code> 查看进程的详细状况</td></tr><tr><td>02</td><td>top</td><td>动态显示运行中的进程并且排序</td></tr><tr><td>03</td><td>kill [-9] 进程代号</td><td>终止指定代号的进程，<code>-9</code> 表示强行终止</td></tr></tbody></table><blockquote><p><code>ps</code> 默认只会显示当前用户通过终端启动的应用程序</p></blockquote><ul><li><code>ps</code> 选项说明功能</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>a</td><td>显示终端上的所有进程，包括其他用户的进程</td></tr><tr><td>u</td><td>显示进程的详细状态</td></tr><tr><td>x</td><td>显示没有控制终端的进程</td></tr></tbody></table><blockquote><p>提示：使用 <code>kill</code> 命令时，最好只终止由当前用户开启的进程，而不要终止 <code>root</code> 身份开启的进程，否则可能导致系统崩溃</p><ul><li>要退出 <code>top</code> 可以直接输入 <code>q</code></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux基础05-用户权限相关命令</title>
      <link href="/2019/03/24/Linux%E5%9F%BA%E7%A1%8005-%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/03/24/Linux%E5%9F%BA%E7%A1%8005-%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="1-用户-和-权限-的基本概念"><a href="#1-用户-和-权限-的基本概念" class="headerlink" title="1. 用户 和 权限 的基本概念"></a>1. <strong>用户</strong> 和 <strong>权限</strong> 的基本概念</h1><h2 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h2><ul><li><strong>用户</strong> 是 Linux 系统工作中重要的一环，用户管理包括 <strong>用户</strong> 与 <strong>组</strong> 管理</li><li>在 Linux 系统中，不论是由本机或是远程登录系统，每个系统都<strong>必须拥有一个账号</strong>，并且<strong>对于不同的系统资源拥有不同的使用权限</strong></li><li>在 Linux 中，可以指定 <strong>每一个用户</strong> 针对 <strong>不同的文件或者目录</strong> 的 <strong>不同权限</strong></li><li>对 <strong>文件／目录</strong> 的权限包括：</li></ul><table><thead><tr><th>序号</th><th>权限</th><th>英文</th><th>缩写</th><th>数字代号</th></tr></thead><tbody><tr><td>01</td><td>读</td><td>read</td><td>r</td><td>4</td></tr><tr><td>02</td><td>写</td><td>write</td><td>w</td><td>2</td></tr><tr><td>03</td><td>执行</td><td>excute</td><td>x</td><td>1</td></tr></tbody></table><h2 id="1-2-组"><a href="#1-2-组" class="headerlink" title="1.2 组"></a>1.2 组</h2><ul><li><p>为了方便用户管理，提出了 <strong>组</strong> 的概念</p></li><li><p>在实际应用中，可以预先针对 <strong>组</strong> 设置好权限，然后 <strong>将不同的用户添加到对应的组中</strong>，从而<strong>不用依次为每一个用户设置权限</strong></p></li></ul><h2 id="1-3-ls-l-扩展"><a href="#1-3-ls-l-扩展" class="headerlink" title="1.3 ls -l 扩展"></a>1.3 ls -l 扩展</h2><ul><li><p><code>ls -l</code> 可以查看文件夹下文件的详细信息，从左到右依次是：</p><ul><li><p><strong>权限</strong>，第 1 个字符如果是 <code>d</code> 表示目录</p></li><li><p><strong>硬链接数</strong>，通俗地讲，就是有多少种方式，可以访问到当前目录／文件</p></li><li><p><strong>拥有者</strong>，家目录下 文件／目录 的拥有者通常都是当前用户</p></li><li><p><strong>组</strong>，在 Linux 中，很多时候，会出现组名和用户名相同的情况，后续会讲</p></li><li><p><strong>大小</strong></p></li><li><p><strong>时间</strong></p></li><li><p><strong>名称</strong></p></li></ul></li></ul><p><img src="/2019/03/24/Linux基础05-用户权限相关命令/002_权限示意图.png" alt="002_权限示意图">￼</p><h2 id="1-4-chmod-简单使用"><a href="#1-4-chmod-简单使用" class="headerlink" title="1.4 chmod 简单使用"></a>1.4 <code>chmod</code> 简单使用</h2><ul><li><code>chmod</code> 可以修改 <strong>用户／组</strong> 对 <strong>文件／目录</strong> 的权限</li><li>命令格式如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +/-rwx 文件名|目录名</span><br></pre></td></tr></table></figure><blockquote><p>提示：以上方式会一次性修改 <code>拥有者</code> / <code>组</code> 权限，有关 <code>chmod</code> 的高级用法，后续会讲</p></blockquote><h2 id="1-5-超级用户"><a href="#1-5-超级用户" class="headerlink" title="1.5 超级用户"></a>1.5 超级用户</h2><ul><li>Linux 系统中的 <code>root</code> 账号通常 <strong>用于系统的维护和管理</strong>，对操作系统的所有资源 <strong>具有所有访问权限</strong></li><li>在大多数版本的 Linux 中，都不推荐 <strong>直接使用 root 账号登录系统</strong></li><li>在 Linux 安装的过程中，系统会自动创建一个用户账号，而这个默认的用户就称为“标准用户”</li></ul><p><strong>sudo</strong></p><ul><li><code>su</code> 是 <code>substitute user</code> 的缩写，表示 <strong>使用另一个用户的身份</strong></li><li><code>sudo</code> 命令用来以其他身份来执行命令，预设的身份为 <code>root</code></li><li>用户使用 <code>sudo</code> 时，必须先输入密码，之后有 <strong>5 分钟的有效期限</strong>，超过期限则必须重新输入密码</li></ul><blockquote><p>若其未经授权的用户企图使用 <code>sudo</code>，则会发出警告邮件给管理员</p></blockquote><h1 id="2-组管理-终端命令"><a href="#2-组管理-终端命令" class="headerlink" title="2. 组管理 终端命令"></a>2. <strong>组管理</strong> 终端命令</h1><blockquote><p>提示：<strong>创建组</strong> / <strong>删除组</strong> 的终端命令都需要通过 <code>sudo</code> 执行</p></blockquote><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>groupadd 组名</td><td>添加组</td></tr><tr><td>02</td><td>groupdel 组名</td><td>删除组</td></tr><tr><td>03</td><td>cat /etc/group</td><td>确认组信息</td></tr><tr><td>04</td><td>chgrp -R 组名 文件/目录名</td><td>递归修改文件/目录的所属组</td></tr></tbody></table><blockquote><p>提示：</p><ul><li>组信息保存在 <code>/etc/group</code> 文件中</li><li><code>/etc</code> 目录是专门用来保存 <strong>系统配置信息</strong> 的目录</li><li>在实际应用中，可以预先针对 <strong>组</strong> 设置好权限，然后 <strong>将不同的用户添加到对应的组中</strong>，从而<strong>不用依次为每一个用户设置权限</strong></li></ul></blockquote><h2 id="演练目标"><a href="#演练目标" class="headerlink" title="演练目标"></a>演练目标</h2><ol><li>在 <code>python</code> 用户的桌面文件夹下创建 <code>Python学习</code> 目录</li><li>新建 <code>dev</code> 组</li><li>将 <code>Python学习</code> 目录的组修改为 <code>dev</code></li></ol><h1 id="3-用户管理-终端命令"><a href="#3-用户管理-终端命令" class="headerlink" title="3. 用户管理 终端命令"></a>3. <strong>用户管理</strong> 终端命令</h1><blockquote><p>提示：<strong>创建用户</strong> / <strong>删除用户</strong> / <strong>修改其他用户密码</strong> 的终端命令都需要通过 <code>sudo</code> 执行</p></blockquote><h2 id="3-1-创建用户／设置密码／删除用户"><a href="#3-1-创建用户／设置密码／删除用户" class="headerlink" title="3.1 创建用户／设置密码／删除用户"></a>3.1 创建用户／设置密码／删除用户</h2><table><thead><tr><th>序号</th><th>命令</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>01</td><td>useradd -m -g 组 新建用户名</td><td>添加新用户</td><td>-m 自动建立用户家目录-g 指定用户所在的组，否则会建立一个和同名的组</td></tr><tr><td>02</td><td>passwd 用户名</td><td>设置用户密码</td><td>如果是普通用户，直接用 passwd 可以修改自己的账户密码</td></tr><tr><td>03</td><td>userdel -r 用户名</td><td>删除用户</td><td>-r 选项会自动删除用户家目录</td></tr><tr><td>04</td><td>cat /etc/passwd \</td><td>grep 用户名</td><td>确认用户信息</td><td>新建用户后，用户信息会保存在 /etc/passwd 文件中</td></tr></tbody></table><blockquote><p>提示：</p><ul><li>创建用户时，如果忘记添加 <code>-m</code> 选项指定新用户的家目录 —— 最简单的方法就是<strong>删除用户，重新创建</strong></li><li>创建用户时，默认会创建一个和<strong>用户名</strong>同名的<strong>组名</strong></li><li>用户信息保存在 <code>/etc/passwd</code> 文件中</li></ul></blockquote><h2 id="3-2-查看用户信息"><a href="#3-2-查看用户信息" class="headerlink" title="3.2 查看用户信息"></a>3.2 查看用户信息</h2><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>id [用户名]</td><td>查看用户 UID 和 GID 信息</td></tr><tr><td>02</td><td>who</td><td>查看当前所有登录的用户列表</td></tr><tr><td>03</td><td>whoami</td><td>查看当前登录用户的账户名</td></tr></tbody></table><h3 id="passwd-文件"><a href="#passwd-文件" class="headerlink" title="passwd 文件"></a>passwd 文件</h3><p><code>/etc/passwd</code> 文件存放的是用户的信息，由 6 个分号组成的 7 个信息，分别是</p><ol><li>用户名</li><li>密码（x，表示加密的密码）</li><li>UID（用户标识）</li><li>GID（组标识）</li><li>用户全名或本地帐号</li><li>家目录</li><li>登录使用的 Shell，就是登录之后，使用的终端命令，<code>ubuntu</code> 默认是 <code>dash</code></li></ol><h3 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h3><ul><li><code>usermod</code> 可以用来设置 <strong>用户</strong> 的 <strong>主组</strong> ／ <strong>附加组</strong> 和 <strong>登录 Shell</strong>，命令格式如下：</li><li><strong>主组</strong>：通常在新建用户时指定，在 <code>etc/passwd</code> 的第 4 列 <strong>GID 对应的组</strong></li><li><strong>附加组</strong>：在 <code>etc/group</code> 中最后一列表示该组的用户列表，用于指定 <strong>用户的附加权限</strong></li></ul><blockquote><p>提示：设置了用户的附加组之后，需要重新登录才能生效！</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改用户的主组（passwd 中的 GID）</span></span><br><span class="line">usermod -g 组 用户名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改用户的附加组</span></span><br><span class="line">usermod -G 组 用户名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改用户登录 Shell</span></span><br><span class="line">usermod -s /bin/bash 用户名</span><br></pre></td></tr></table></figure><blockquote><p>注意：默认使用 <code>useradd</code> 添加的用户是没有权限使用 <code>sudo</code> 以 <code>root</code> 身份执行命令的，可以使用以下命令，将用户添加到 <code>sudo</code> 附加组中</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -G sudo 用户名</span><br></pre></td></tr></table></figure><h3 id="which"><a href="#which" class="headerlink" title="which"></a>which</h3><blockquote><p>提示</p><ul><li><code>/etc/passwd</code> 是用于保存用户信息的文件</li><li><code>/usr/bin/passwd</code> 是用于修改用户密码的程序</li></ul></blockquote><ul><li><code>which</code> 命令可以查看执行命令所在位置，例如：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> ls</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># /bin/ls</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">which</span> useradd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># /usr/sbin/useradd</span></span><br></pre></td></tr></table></figure><h3 id="bin-和-sbin"><a href="#bin-和-sbin" class="headerlink" title="bin 和 sbin"></a><code>bin</code> 和 <code>sbin</code></h3><ul><li>在 <code>Linux</code> 中，绝大多数可执行文件都是保存在 <code>/bin</code>、<code>/sbin</code>、<code>/usr/bin</code>、<code>/usr/sbin</code></li><li><code>/bin</code>（<code>binary</code>）是二进制执行文件目录，主要用于具体应用</li><li><code>/sbin</code>（<code>system binary</code>）是系统管理员专用的二进制代码存放目录，主要用于系统管理</li><li><code>/usr/bin</code>（<code>user commands for applications</code>）后期安装的一些软件</li><li><code>/usr/sbin</code>（<code>super user commands for applications</code>）超级用户的一些管理程序</li></ul><blockquote><p>提示：</p><ul><li><code>cd</code> 这个终端命令是内置在系统内核中的，没有独立的文件，因此用 <code>which</code> 无法找到 <code>cd</code> 命令的位置</li></ul></blockquote><h2 id="3-3-切换用户"><a href="#3-3-切换用户" class="headerlink" title="3.3 切换用户"></a>3.3 切换用户</h2><table><thead><tr><th>序号</th><th>命令</th><th>作用</th><th>说明</th></tr></thead><tbody><tr><td>01</td><td>su - 用户名</td><td>切换用户，并且切换目录</td><td>- 可以切换到用户家目录，否则保持位置不变</td></tr><tr><td>02</td><td>exit</td><td>退出当前登录账户</td></tr></tbody></table><ul><li><code>su</code> 不接用户名，可以切换到 <code>root</code>，但是不推荐使用，因为不安全</li><li><code>exit</code> 示意图如下：</li></ul><p><img src="/2019/03/24/Linux基础05-用户权限相关命令/003_su和exit示意图.png" alt="003_su和exit示意图"></p><h1 id="4-修改文件权限"><a href="#4-修改文件权限" class="headerlink" title="4. 修改文件权限"></a>4. 修改文件权限</h1><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>chown</td><td>修改拥有者</td></tr><tr><td>02</td><td>chgrp</td><td>修改组</td></tr><tr><td>03</td><td>chmod</td><td>修改权限</td></tr></tbody></table><ul><li>命令格式如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改文件|目录的拥有者</span></span><br><span class="line">chown 用户名 文件名|目录名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归修改文件|目录的组</span></span><br><span class="line">chgrp -R 组名 文件名|目录名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 递归修改文件权限</span></span><br><span class="line">chmod -R 755 文件名|目录名</span><br></pre></td></tr></table></figure><ul><li><code>chmod</code> 在设置权限时，可以简单地使用三个数字分别对应 <strong>拥有者</strong> ／ <strong>组</strong> 和 <strong>其他</strong> 用户的权限</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接修改文件|目录的 读|写|执行 权限，但是不能精确到 拥有者|组|其他</span></span><br><span class="line">chmod +/-rwx 文件名|目录名</span><br></pre></td></tr></table></figure><p><img src="/2019/03/24/Linux基础05-用户权限相关命令/004_文件权限示意图.png" alt="004_文件权限示意图">￼</p><ul><li><p>常见数字组合有（u表示用户／g表示组／o表示其他）：</p><ul><li><code>777</code> ===&gt; <code>u=rwx,g=rwx,o=rwx</code></li><li><code>755</code> ===&gt; <code>u=rwx,g=rx,o=rx</code></li><li><code>644</code> ===&gt; <code>u=rw,g=r,o=r</code></li></ul></li></ul><h2 id="chmod-演练目标"><a href="#chmod-演练目标" class="headerlink" title="chmod 演练目标"></a><code>chmod</code> 演练目标</h2><ol><li>将 <code>01.py</code> 的权限修改为 <code>u=rwx,g=rx,o=r</code></li><li>将 <code>123.txt</code> 的权限修改为 <code>u=rw,g=r,o=-</code></li><li>将 <code>test</code> 目录以及目录下的 <strong>所有</strong> 文件权限修改为 <code>u=rwx,g=rwx,o=rx</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python语法基础04-字符串</title>
      <link href="/2019/03/23/Python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%8004-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2019/03/23/Python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%8004-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="1-字符串的定义"><a href="#1-字符串的定义" class="headerlink" title="1. 字符串的定义"></a>1. 字符串的定义</h1><ul><li><strong>字符串</strong> 就是 <strong>一串字符</strong>，是编程语言中表示文本的数据类型</li><li>在 Python 中可以使用 <strong>一对双引号</strong> <code>&quot;</code> 或者 <strong>一对单引号</strong> <code>&#39;</code> 定义一个字符串<ul><li>虽然可以使用 <code>\&quot;</code> 或者 <code>\&#39;</code> 做字符串的转义，但是在实际开发中：<ul><li>如果字符串内部需要使用 <code>&quot;</code>，可以使用 <code>&#39;</code> 定义字符串</li><li>如果字符串内部需要使用 <code>&#39;</code>，可以使用 <code>&quot;</code> 定义字符串</li></ul></li></ul></li><li>可以使用 <strong>索引</strong> 获取一个字符串中 <strong>指定位置的字符</strong>，索引计数从 <strong>0</strong> 开始</li><li>也可以使用 <code>for</code> <strong>循环遍历</strong> 字符串中每一个字符</li></ul><blockquote><p>大多数编程语言都是用 <code>&quot;</code> 来定义字符串</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = <span class="string">"Hello Python"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> string:</span><br><span class="line">    print(c)</span><br></pre></td></tr></table></figure><p><img src="/2019/03/23/Python语法基础04-字符串/005_字符串示意图.png" alt="005_字符串示意图-w500"></p><h1 id="2-字符串的常用操作"><a href="#2-字符串的常用操作" class="headerlink" title="2. 字符串的常用操作"></a>2. 字符串的常用操作</h1><ul><li>在 <code>ipython3</code> 中定义一个 <strong>字符串</strong>，例如：<code>hello_str = &quot;&quot;</code></li><li>输入 <code>hello_str.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>字符串</strong> 能够使用的 <strong>方法</strong> 如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [1]: hello_str.</span><br><span class="line">hello_str.capitalize    hello_str.isidentifier  hello_str.rindex</span><br><span class="line">hello_str.casefold      hello_str.islower       hello_str.rjust</span><br><span class="line">hello_str.center        hello_str.isnumeric     hello_str.rpartition</span><br><span class="line">hello_str.count         hello_str.isprintable   hello_str.rsplit</span><br><span class="line">hello_str.encode        hello_str.isspace       hello_str.rstrip</span><br><span class="line">hello_str.endswith      hello_str.istitle       hello_str.split</span><br><span class="line">hello_str.expandtabs    hello_str.isupper       hello_str.splitlines</span><br><span class="line">hello_str.find          hello_str.join          hello_str.startswith</span><br><span class="line">hello_str.format        hello_str.ljust         hello_str.strip</span><br><span class="line">hello_str.format_map    hello_str.lower         hello_str.swapcase</span><br><span class="line">hello_str.index         hello_str.lstrip        hello_str.title</span><br><span class="line">hello_str.isalnum       hello_str.maketrans     hello_str.translate</span><br><span class="line">hello_str.isalpha       hello_str.partition     hello_str.upper</span><br><span class="line">hello_str.isdecimal     hello_str.replace       hello_str.zfill</span><br><span class="line">hello_str.isdigit       hello_str.rfind</span><br></pre></td></tr></table></figure><blockquote><p>提示：正是因为 python 内置提供的方法足够多，才使得在开发时，能够针对字符串进行更加灵活的操作！应对更多的开发需求！</p></blockquote><h2 id="1-判断类型-9"><a href="#1-判断类型-9" class="headerlink" title="1) 判断类型 - 9"></a>1) 判断类型 - 9</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.isspace()</td><td>如果 string 中只包含空格，则返回 True</td></tr><tr><td>string.isalnum()</td><td>如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True</td></tr><tr><td>string.isalpha()</td><td>如果 string 至少有一个字符并且所有字符都是字母则返回 True</td></tr><tr><td>string.isdecimal()</td><td>如果 string 只包含数字则返回 True，<code>全角数字</code></td></tr><tr><td>string.isdigit()</td><td>如果 string 只包含数字则返回 True，<code>全角数字</code>、<code>⑴</code>、<code>\u00b2</code></td></tr><tr><td>string.isnumeric()</td><td>如果 string 只包含数字则返回 True，<code>全角数字</code>，<code>汉字数字</code></td></tr><tr><td>string.istitle()</td><td>如果 string 是标题化的(每个单词的首字母大写)则返回 True</td></tr><tr><td>string.islower()</td><td>如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True</td></tr><tr><td>string.isupper()</td><td>如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True</td></tr></tbody></table><h2 id="2-查找和替换-7"><a href="#2-查找和替换-7" class="headerlink" title="2) 查找和替换 - 7"></a>2) 查找和替换 - 7</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.startswith(str)</td><td>检查字符串是否是以 str 开头，是则返回 True</td></tr><tr><td>string.endswith(str)</td><td>检查字符串是否是以 str 结束，是则返回 True</td></tr><tr><td>string.find(str, start=0, end=len(string))</td><td>检测 str 是否包含在 string 中，如果 start 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 <code>-1</code></td></tr><tr><td>string.rfind(str, start=0, end=len(string))</td><td>类似于 find()，不过是从右边开始查找</td></tr><tr><td>string.index(str, start=0, end=len(string))</td><td>跟 find() 方法类似，不过如果 str 不在 string 会报错</td></tr><tr><td>string.rindex(str, start=0, end=len(string))</td><td>类似于 index()，不过是从右边开始</td></tr><tr><td>string.replace(old_str, new_str, num=string.count(old))</td><td>把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过 num 次</td></tr></tbody></table><h2 id="3-大小写转换-5"><a href="#3-大小写转换-5" class="headerlink" title="3) 大小写转换 - 5"></a>3) 大小写转换 - 5</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.capitalize()</td><td>把字符串的第一个字符大写</td></tr><tr><td>string.title()</td><td>把字符串的每个单词首字母大写</td></tr><tr><td>string.lower()</td><td>转换 string 中所有大写字符为小写</td></tr><tr><td>string.upper()</td><td>转换 string 中的小写字母为大写</td></tr><tr><td>string.swapcase()</td><td>翻转 string 中的大小写</td></tr></tbody></table><h2 id="4-文本对齐-3"><a href="#4-文本对齐-3" class="headerlink" title="4) 文本对齐 - 3"></a>4) 文本对齐 - 3</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.ljust(width)</td><td>返回一个原字符串左对齐，并使用空格填充至长度 width 的新字符串</td></tr><tr><td>string.rjust(width)</td><td>返回一个原字符串右对齐，并使用空格填充至长度 width 的新字符串</td></tr><tr><td>string.center(width)</td><td>返回一个原字符串居中，并使用空格填充至长度 width 的新字符串</td></tr></tbody></table><h2 id="5-去除空白字符-3"><a href="#5-去除空白字符-3" class="headerlink" title="5) 去除空白字符 - 3"></a>5) 去除空白字符 - 3</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.lstrip()</td><td>截掉 string 左边（开始）的空白字符</td></tr><tr><td>string.rstrip()</td><td>截掉 string 右边（末尾）的空白字符</td></tr><tr><td>string.strip()</td><td>截掉 string 左右两边的空白字符</td></tr></tbody></table><h2 id="6-拆分和连接-5"><a href="#6-拆分和连接-5" class="headerlink" title="6) 拆分和连接 - 5"></a>6) 拆分和连接 - 5</h2><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.partition(str)</td><td>把字符串 string 分成一个 3 元素的元组 (str前面, str, str后面)</td></tr><tr><td>string.rpartition(str)</td><td>类似于 partition() 方法，不过是从右边开始查找</td></tr><tr><td>string.split(str=””, num)</td><td>以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1 个子字符串，str 默认包含 ‘\r’, ‘\t’, ‘\n’ 和空格</td></tr><tr><td>string.splitlines()</td><td>按照行(‘\r’, ‘\n’, ‘\r\n’)分隔，返回一个包含各行作为元素的列表</td></tr><tr><td>string.join(seq)</td><td>以 string 作为分隔符，将 seq 中所有的元素（的字符串表示）合并为一个新的字符串</td></tr></tbody></table><h1 id="3-字符串的切片"><a href="#3-字符串的切片" class="headerlink" title="3. 字符串的切片"></a>3. 字符串的切片</h1><ul><li><strong>切片</strong> 方法适用于 <strong>字符串</strong>、<strong>列表</strong>、<strong>元组</strong><ul><li><strong>切片</strong> 使用 <strong>索引值</strong> 来限定范围，从一个大的 <strong>字符串</strong> 中 <strong>切出</strong> 小的 <strong>字符串</strong></li><li><strong>列表</strong> 和 <strong>元组</strong> 都是 <strong>有序</strong> 的集合，都能够 <strong>通过索引值</strong> 获取到对应的数据</li><li><strong>字典</strong> 是一个 <strong>无序</strong> 的集合，是使用 <strong>键值对</strong> 保存数据</li></ul></li></ul><p><img src="/2019/03/23/Python语法基础04-字符串/006_字符串索引示意图.png" alt="006_字符串索引示意图"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串[开始索引:结束索引:步长]</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ol><li>指定的区间属于 <strong>左闭右开</strong> 型 <code>[开始索引,  结束索引)</code> =&gt; <code>开始索引 &gt;= 范围 &lt; 结束索引</code><ul><li>从 <code>起始</code> 位开始，到 <strong><code>结束</code>位的前一位</strong> 结束（<strong>不包含结束位本身</strong>)</li></ul></li><li>从头开始，<strong>开始索引</strong> <strong>数字可以省略，冒号不能省略</strong></li><li>到末尾结束，<strong>结束索引</strong> <strong>数字可以省略，冒号不能省略</strong></li><li>步长默认为 <code>1</code>，如果连续切片，<strong>数字和冒号都可以省略</strong></li></ol><p><strong>索引的顺序和倒序</strong></p><ul><li>在 Python 中不仅支持 <strong>顺序索引</strong>，同时还支持 <strong>倒序索引</strong></li><li>所谓倒序索引就是 <strong>从右向左</strong> 计算索引<ul><li>最右边的索引值是 <strong>-1</strong>，依次递减</li></ul></li></ul><h1 id="4-演练需求"><a href="#4-演练需求" class="headerlink" title="4. 演练需求"></a>4. 演练需求</h1><ul><li><ol><li>截取从 2 ~ 5 位置 的字符串</li></ol></li><li><ol start="2"><li>截取从 2 ~ <code>末尾</code> 的字符串</li></ol></li><li><ol start="3"><li>截取从 <code>开始</code> ~ 5 位置 的字符串</li></ol></li><li><ol start="4"><li>截取完整的字符串</li></ol></li><li><ol start="5"><li>从开始位置，每隔一个字符截取字符串</li></ol></li><li><ol start="6"><li>从索引 1 开始，每隔一个取一个</li></ol></li><li><ol start="7"><li>截取从 2 ~ <code>末尾 - 1</code> 的字符串</li></ol></li><li><ol start="8"><li>截取字符串末尾两个字符</li></ol></li><li><ol start="9"><li>字符串的逆序（面试题）</li></ol></li></ul><p><strong>答案</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">num_str = &quot;0123456789&quot;</span><br><span class="line"></span><br><span class="line"># 1. 截取从 2 ~ 5 位置 的字符串</span><br><span class="line">print(num_str[2:6])</span><br><span class="line"></span><br><span class="line"># 2. 截取从 2 ~ `末尾` 的字符串</span><br><span class="line">print(num_str[2:])</span><br><span class="line"></span><br><span class="line"># 3. 截取从 `开始` ~ 5 位置 的字符串</span><br><span class="line">print(num_str[:6])</span><br><span class="line"></span><br><span class="line"># 4. 截取完整的字符串</span><br><span class="line">print(num_str[:])</span><br><span class="line"></span><br><span class="line"># 5. 从开始位置，每隔一个字符截取字符串</span><br><span class="line">print(num_str[::2])</span><br><span class="line"></span><br><span class="line"># 6. 从索引 1 开始，每隔一个取一个</span><br><span class="line">print(num_str[1::2])</span><br><span class="line"></span><br><span class="line"># 倒序切片</span><br><span class="line"># -1 表示倒数第一个字符</span><br><span class="line">print(num_str[-1])</span><br><span class="line"></span><br><span class="line"># 7. 截取从 2 ~ `末尾 - 1` 的字符串</span><br><span class="line">print(num_str[2:-1])</span><br><span class="line"></span><br><span class="line"># 8. 截取字符串末尾两个字符</span><br><span class="line">print(num_str[-2:])</span><br><span class="line"></span><br><span class="line"># 9. 字符串的逆序（面试题）</span><br><span class="line">print(num_str[::-1])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> str </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python语法基础03-字典</title>
      <link href="/2019/03/23/Python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%8003-%E5%AD%97%E5%85%B8/"/>
      <url>/2019/03/23/Python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%8003-%E5%AD%97%E5%85%B8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-字典的定义"><a href="#1-字典的定义" class="headerlink" title="1. 字典的定义"></a>1. 字典的定义</h1><ul><li><code>dictionary</code>（字典） 是 <strong>除列表以外</strong> <code>Python</code> 之中 <strong>最灵活</strong> 的数据类型</li><li>字典同样可以用来 <strong>存储多个数据</strong><ul><li>通常用于存储 <strong>描述一个 <code>物体</code> 的相关信息</strong> </li></ul></li><li>和列表的区别<ul><li><strong>列表</strong> 是 <strong>有序</strong> 的对象集合</li><li><strong>字典</strong> 是 <strong>无序</strong> 的对象集合</li></ul></li><li>字典用 <code>{}</code> 定义</li><li>字典使用 <strong>键值对</strong> 存储数据，键值对之间使用 <code>,</code> 分隔<ul><li><strong>键</strong> <code>key</code> 是索引</li><li><strong>值</strong> <code>value</code> 是数据</li><li><strong>键</strong> 和 <strong>值</strong> 之间使用 <code>:</code> 分隔</li><li><strong>键必须是唯一的</strong></li><li><strong>值</strong> 可以取任何数据类型，但 <strong>键</strong> 只能使用 <strong>字符串</strong>、<strong>数字</strong>或 <strong>元组</strong></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xiaoming = &#123;<span class="string">"name"</span>: <span class="string">"小明"</span>,</span><br><span class="line">            <span class="string">"age"</span>: <span class="number">18</span>,</span><br><span class="line">            <span class="string">"gender"</span>: <span class="keyword">True</span>,</span><br><span class="line">            <span class="string">"height"</span>: <span class="number">1.75</span>&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/03/23/Python语法基础03-字典/002_字典示意图.png" alt="002_字典示意图"></p><h1 id="2-字典常用操作"><a href="#2-字典常用操作" class="headerlink" title="2. 字典常用操作"></a>2. 字典常用操作</h1><ul><li>在 <code>ipython3</code> 中定义一个 <strong>字典</strong>，例如：<code>xiaoming = {}</code></li><li>输入 <code>xiaoming.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>字典</strong> 能够使用的函数如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [1]: xiaoming.</span><br><span class="line">xiaoming.clear       xiaoming.items       xiaoming.setdefault</span><br><span class="line">xiaoming.copy        xiaoming.keys        xiaoming.update</span><br><span class="line">xiaoming.fromkeys    xiaoming.pop         xiaoming.values</span><br><span class="line">xiaoming.get         xiaoming.popitem</span><br></pre></td></tr></table></figure><blockquote><p>有关 <strong>字典</strong> 的 <strong>常用操作</strong> 可以参照上图练习</p></blockquote><h1 id="3-循环遍历"><a href="#3-循环遍历" class="headerlink" title="3. 循环遍历"></a>3. 循环遍历</h1><ul><li><strong>遍历</strong> 就是 <strong>依次</strong> 从 <strong>字典</strong> 中获取所有键值对</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for 循环内部使用的 `key 的变量` in 字典</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> xiaoming:</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"%s: %s"</span> % (k, xiaoming[k]))</span><br></pre></td></tr></table></figure><blockquote><p>提示：在实际开发中，由于字典中每一个键值对保存数据的类型是不同的，所以针对字典的循环遍历需求并不是很多</p></blockquote><h1 id="4-应用场景"><a href="#4-应用场景" class="headerlink" title="4. 应用场景"></a>4. <strong>应用场景</strong></h1><ul><li>尽管可以使用 <code>for in</code> 遍历 <strong>字典</strong></li><li>但是在开发中，更多的应用场景是：<ul><li>使用 <strong>多个键值对</strong>，存储 <strong>描述一个 <code>物体</code> 的相关信息</strong> —— 描述更复杂的数据信息</li><li>将 <strong>多个字典</strong> 放在 <strong>一个列表</strong> 中，再进行遍历，在循环体内部针对每一个字典进行 <strong>相同的处理</strong></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">card_list = [&#123;<span class="string">"name"</span>: <span class="string">"张三"</span>,</span><br><span class="line">              <span class="string">"qq"</span>: <span class="string">"12345"</span>,</span><br><span class="line">              <span class="string">"phone"</span>: <span class="string">"110"</span>&#125;,</span><br><span class="line">             &#123;<span class="string">"name"</span>: <span class="string">"李四"</span>,</span><br><span class="line">              <span class="string">"qq"</span>: <span class="string">"54321"</span>,</span><br><span class="line">              <span class="string">"phone"</span>: <span class="string">"10086"</span>&#125;</span><br><span class="line">             ]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dict </tag>
            
            <tag> 字典 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python语法基础02-元组</title>
      <link href="/2019/03/23/Python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%8002-%E5%85%83%E7%BB%84/"/>
      <url>/2019/03/23/Python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%8002-%E5%85%83%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="1-元组"><a href="#1-元组" class="headerlink" title="1. 元组"></a>1. 元组</h1><h2 id="1-1-元组的定义"><a href="#1-1-元组的定义" class="headerlink" title="1.1 元组的定义"></a>1.1 元组的定义</h2><ul><li><code>Tuple</code>（元组）与列表类似，不同之处在于元组的 <strong>元素不能修改</strong><ul><li><strong>元组</strong> 表示多个元素组成的序列</li><li><strong>元组</strong> 在 <code>Python</code> 开发中，有特定的应用场景</li></ul></li><li>用于存储 <strong>一串 信息</strong>，<strong>数据</strong> 之间使用 <code>,</code> 分隔</li><li>元组用 <code>()</code> 定义</li><li>元组的 <strong>索引</strong> 从 <code>0</code> 开始<ul><li><strong>索引</strong> 就是数据在 <strong>元组</strong> 中的位置编号</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info_tuple = (<span class="string">"zhangsan"</span>, <span class="number">18</span>, <span class="number">1.75</span>)</span><br></pre></td></tr></table></figure><p><strong>创建空元组</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info_tuple = ()</span><br></pre></td></tr></table></figure><p><strong>元组中只包含一个元素</strong> 时，需要 <strong>在元素后面添加逗号</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info_tuple = (<span class="number">50</span>, )</span><br></pre></td></tr></table></figure><p><img src="/2019/03/23/Python语法基础02-元组/003_元组示意图.png" alt="003_元组示意图-w500"></p><h2 id="1-2-元组常用操作"><a href="#1-2-元组常用操作" class="headerlink" title="1.2 元组常用操作"></a>1.2 元组常用操作</h2><ul><li>在 <code>ipython3</code> 中定义一个 <strong>元组</strong>，例如：<code>info = ()</code></li><li>输入 <code>info.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>元组</strong> 能够使用的函数如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info.count  info.index</span><br></pre></td></tr></table></figure><blockquote><p>有关 <strong>元组</strong> 的 <strong>常用操作</strong> 可以参照上图练习</p></blockquote><h2 id="1-3-循环遍历"><a href="#1-3-循环遍历" class="headerlink" title="1.3 循环遍历"></a>1.3 循环遍历</h2><ul><li><strong>取值</strong> 就是从 <strong>元组</strong> 中获取存储在指定位置的数据</li><li><strong>遍历</strong> 就是 <strong>从头到尾</strong> <strong>依次</strong> 从 <strong>元组</strong> 中获取数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for 循环内部使用的变量 in 元组</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> info:</span><br><span class="line"></span><br><span class="line">    循环内部针对元组元素进行操作</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure><blockquote><ul><li>在 <code>Python</code> 中，可以使用 <code>for</code> 循环遍历所有非数字型类型的变量：<strong>列表</strong>、<strong>元组</strong>、<strong>字典</strong> 以及 <strong>字符串</strong></li><li>提示：在实际开发中，除非 <strong>能够确认元组中的数据类型</strong>，否则针对元组的循环遍历需求并不是很多</li></ul></blockquote><h2 id="1-4-应用场景"><a href="#1-4-应用场景" class="headerlink" title="1.4 应用场景"></a>1.4 应用场景</h2><ul><li>尽管可以使用 <code>for in</code> 遍历 <strong>元组</strong></li><li>但是在开发中，更多的应用场景是：<ul><li><strong>函数的 参数 和 返回值</strong>，一个函数可以接收 <strong>任意多个参数</strong>，或者 <strong>一次返回多个数据</strong><ul><li>有关 <strong>函数的参数 和 返回值</strong>，在后续 <strong>函数高级</strong> 给大家介绍</li></ul></li><li><strong>格式字符串</strong>，格式化字符串后面的 <code>()</code> 本质上就是一个元组</li><li><strong>让列表不可以被修改</strong>，以保护数据安全</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info = (<span class="string">"zhangsan"</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"%s 的年龄是 %d"</span> % info)</span><br></pre></td></tr></table></figure><h1 id="2-元组和列表之间的转换"><a href="#2-元组和列表之间的转换" class="headerlink" title="2.  元组和列表之间的转换"></a>2.  元组和列表之间的转换</h1><ul><li>使用 <code>list</code> 函数可以把元组转换成列表</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(元组)</span><br></pre></td></tr></table></figure><ul><li>使用 <code>tuple</code> 函数可以把列表转换成元组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple(列表)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tuple </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python语法基础01-列表</title>
      <link href="/2019/03/22/Python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%8001-%E5%88%97%E8%A1%A8/"/>
      <url>/2019/03/22/Python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%8001-%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-知识点提要"><a href="#1-知识点提要" class="headerlink" title="1. 知识点提要"></a>1. 知识点提要</h1><ul><li>Python 中数据类型可以分为 <strong>数字型</strong> 和 <strong>非数字型</strong></li><li>数字型<ul><li>整型 (<code>int</code>)</li><li>浮点型（<code>float</code>）</li><li>布尔型（<code>bool</code>） <ul><li>真 <code>True</code> <code>非 0 数</code> —— <strong>非零即真</strong></li><li>假 <code>False</code> <code>0</code></li></ul></li><li>复数型 (<code>complex</code>)<ul><li>主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题</li></ul></li></ul></li><li><p>非数字型</p><ul><li>字符串</li><li>列表</li><li>元组</li><li>字典</li></ul></li><li><p>在 <code>Python</code> 中，所有 <strong>非数字型变量</strong> 都支持以下特点：</p><ol><li>都是一个 <strong>序列</strong> <code>sequence</code>，也可以理解为 <strong>容器</strong></li><li><strong>取值</strong> <code>[]</code></li><li><strong>遍历</strong> <code>for in</code></li><li><strong>计算长度</strong>、<strong>最大/最小值</strong>、<strong>比较</strong>、<strong>删除</strong></li><li><strong>链接</strong> <code>+</code> 和 <strong>重复</strong> <code>*</code></li><li><strong>切片</strong></li></ol></li></ul><h1 id="2-列表"><a href="#2-列表" class="headerlink" title="2. 列表"></a>2. 列表</h1><h2 id="2-1-列表的定义"><a href="#2-1-列表的定义" class="headerlink" title="2.1 列表的定义"></a>2.1 列表的定义</h2><ul><li><code>List</code>（列表） 是 <code>Python</code> 中使用 <strong>最频繁</strong> 的数据类型，在其他语言中通常叫做 <strong>数组</strong></li><li>专门用于存储 <strong>一串 信息</strong></li><li>列表用 <code>[]</code> 定义，<strong>数据</strong> 之间使用 <code>,</code> 分隔</li><li>列表的 <strong>索引</strong> 从 <code>0</code> 开始<ul><li><strong>索引</strong> 就是数据在 <strong>列表</strong> 中的位置编号，<strong>索引</strong> 又可以被称为 <strong>下标</strong></li></ul></li></ul><blockquote><p>注意：从列表中取值时，如果 <strong>超出索引范围</strong>，程序会报错</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name_list = [<span class="string">"zhangsan"</span>, <span class="string">"lisi"</span>, <span class="string">"wangwu"</span>]</span><br></pre></td></tr></table></figure><p><img src="/2019/03/22/Python语法基础01-列表/001_列表示意图.png" alt="001_列表示意图"></p><h2 id="2-2-列表常用操作"><a href="#2-2-列表常用操作" class="headerlink" title="2.2 列表常用操作"></a>2.2 列表常用操作</h2><ul><li>在 <code>ipython3</code> 中定义一个 <strong>列表</strong>，例如：<code>name_list = []</code></li><li>输入 <code>name_list.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>列表</strong> 能够使用的 <strong>方法</strong> 如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [1]: name_list.</span><br><span class="line">name_list.append   name_list.count    name_list.insert   name_list.reverse</span><br><span class="line">name_list.clear    name_list.extend   name_list.pop      name_list.sort</span><br><span class="line">name_list.copy     name_list.index    name_list.remove</span><br></pre></td></tr></table></figure><table><thead><tr><th>序号</th><th>分类</th><th>关键字 / 函数 / 方法</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>增加</td><td>列表.insert(索引, 数据)</td><td>在指定位置插入数据</td></tr><tr><td></td><td></td><td>列表.append(数据)</td><td>在末尾追加数据</td></tr><tr><td></td><td></td><td>列表.extend(列表2)</td><td>将列表2 的数据追加到列表</td></tr><tr><td>2</td><td>修改</td><td>列表[索引] = 数据</td><td>修改指定索引的数据</td></tr><tr><td>3</td><td>删除</td><td>del 列表[索引]</td><td>删除指定索引的数据</td></tr><tr><td></td><td></td><td>列表.remove[数据]</td><td>删除第一个出现的指定数据</td></tr><tr><td></td><td></td><td>列表.pop</td><td>删除末尾数据</td></tr><tr><td></td><td></td><td>列表.pop(索引)</td><td>删除指定索引数据</td></tr><tr><td></td><td></td><td>列表.clear</td><td>清空列表</td></tr><tr><td>4</td><td>统计</td><td>len(列表)</td><td>列表长度</td></tr><tr><td></td><td></td><td>列表.count(数据)</td><td>数据在列表中出现的次数</td></tr><tr><td>5</td><td>排序</td><td>列表.sort()</td><td>升序排序</td></tr><tr><td></td><td></td><td>列表.sort(reverse=True)</td><td>降序排序</td></tr><tr><td></td><td></td><td>列表.reverse()</td><td>逆序、反转</td></tr></tbody></table><h3 id="del-关键字"><a href="#del-关键字" class="headerlink" title="del 关键字"></a>del 关键字</h3><ul><li>使用 <code>del</code> 关键字(<code>delete</code>) 同样可以删除列表中元素</li><li><code>del</code> 关键字本质上是用来 <strong>将一个变量从内存中删除的</strong></li><li>如果使用 <code>del</code> 关键字将变量从内存中删除，后续的代码就不能再使用这个变量了</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> name_list[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><blockquote><p>在日常开发中，要从列表删除数据，建议 <strong>使用列表提供的方法</strong></p></blockquote><h3 id="关键字、函数和方法"><a href="#关键字、函数和方法" class="headerlink" title="关键字、函数和方法"></a>关键字、函数和方法</h3><ul><li><strong>关键字</strong> 是 Python 内置的、具有特殊意义的标识符</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> keyword</span><br><span class="line">In [<span class="number">2</span>]: print(keyword.kwlist)</span><br><span class="line">In [<span class="number">3</span>]: print(len(keyword.kwlist))</span><br></pre></td></tr></table></figure><blockquote><p>关键字后面不需要使用括号</p></blockquote><ul><li><strong>函数</strong> 封装了独立功能，可以直接调用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名(参数)</span><br></pre></td></tr></table></figure><blockquote><p>函数需要死记硬背</p></blockquote><ul><li><strong>方法</strong> 和函数类似，同样是封装了独立的功能</li><li><strong>方法</strong> 需要通过 <strong>对象</strong> 来调用，表示针对这个 <strong>对象</strong> 要做的操作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象.方法名(参数)</span><br></pre></td></tr></table></figure><blockquote><p>在变量后面输入 <code>.</code>，然后选择针对这个变量要执行的操作，记忆起来比函数要简单很多</p></blockquote><h2 id="2-3-循环遍历"><a href="#2-3-循环遍历" class="headerlink" title="2.3 循环遍历"></a>2.3 循环遍历</h2><ul><li><p><strong>遍历</strong> 就是 <strong>从头到尾</strong> <strong>依次</strong> 从 <strong>列表</strong> 中获取数据</p><ul><li>在 <strong>循环体内部</strong> 针对 <strong>每一个元素</strong>，执行相同的操作</li></ul></li><li><p>在 <code>Python</code> 中为了提高列表的遍历效率，专门提供的 <strong>迭代 iteration 遍历</strong></p></li><li>使用 <code>for</code> 就能够实现迭代遍历</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for 循环内部使用的变量 in 列表</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> name_list:</span><br><span class="line"></span><br><span class="line">    <span class="comment">#循环内部针对列表元素进行操作</span></span><br><span class="line">    print(name)</span><br></pre></td></tr></table></figure><p><img src="/2019/03/22/Python语法基础01-列表/002_forin循环流程图.png" alt="002_forin循环流程图-w420"></p><h2 id="2-4-应用场景"><a href="#2-4-应用场景" class="headerlink" title="2.4 应用场景"></a>2.4 <strong>应用场景</strong></h2><ul><li>尽管 <code>Python</code> 的 <strong>列表</strong> 中可以 <strong>存储不同类型的数据</strong></li><li>但是在开发中，更多的应用场景是：<ol><li><strong>列表</strong> 存储相同类型的数据</li><li>通过 <strong>迭代遍历</strong>，在循环体内部，针对列表中的每一项元素，执行相同的操作</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> list </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux基础04-远程管理命令</title>
      <link href="/2019/03/21/Linux%E5%9F%BA%E7%A1%8004-%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/03/21/Linux%E5%9F%BA%E7%A1%8004-%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="1-关机-重启"><a href="#1-关机-重启" class="headerlink" title="1.关机/重启"></a>1.关机/重启</h1><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>含义</th></tr></thead><tbody><tr><td>01</td><td>shutdown  选项  时间</td><td>shutdown</td><td>关机/重新启动</td></tr></tbody></table><h2 id="1-1-shutdown"><a href="#1-1-shutdown" class="headerlink" title="1.1 shutdown"></a>1.1 shutdown</h2><ul><li><code>shutdown</code>命令可以<strong>安全关闭</strong>或者重新启动系统</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-r</td><td>重新启动</td></tr></tbody></table><blockquote><p><strong>提示</strong>：</p><ul><li><strong>不指定选项和参数</strong>，默认表示<strong>1分钟</strong>之后关闭电脑</li><li>远程维护服务器时，最好不要关闭系统，而应该重新启动系统</li></ul></blockquote><ul><li><p>常用命令示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>重新启动操作系统，其中 now 表示现在</span><br><span class="line"><span class="meta">$</span> shutdown -r now</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>立刻关机，其中 now 表示现在</span><br><span class="line"><span class="meta">$</span> shutdown now</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>系统在今天的 13:14 会关机</span><br><span class="line"><span class="meta">$</span> shutdown 13:14</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>系统再过十分钟后自动关机</span><br><span class="line"><span class="meta">$</span> shutdown +10</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>取消之前指定的关机计划</span><br><span class="line"><span class="meta">$</span> shutdown -c</span><br></pre></td></tr></table></figure></li></ul><h1 id="2-查看或配置网卡信息"><a href="#2-查看或配置网卡信息" class="headerlink" title="2. 查看或配置网卡信息"></a>2. 查看或配置网卡信息</h1><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ifconfig</td><td>configure a network interface</td><td>查看/配置计算机当前的网卡配置信息</td></tr><tr><td>02</td><td>ping ip地址</td><td>ping</td><td>检测到目标ip地址的链接是否正常</td></tr></tbody></table><h2 id="2-1-ifconfig"><a href="#2-1-ifconfig" class="headerlink" title="2.1 ifconfig"></a>2.1 ifconfig</h2><ul><li><p><code>ifconfig</code>可以查看/配置计算机当前的网卡配置信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>查看网卡配置信息</span><br><span class="line"><span class="meta">$</span> ifconfig</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>查看网卡对应的IP地址</span><br><span class="line"><span class="meta">$</span> ifconfig | grep inet</span><br></pre></td></tr></table></figure><blockquote><p>提示：一台计算机中有可能会有一个物理地址和多个虚拟网卡，在Linux中物理网卡的名字通常以<code>ensXX</code>表示</p></blockquote></li><li><p><code>127.0.0.1</code>被称为本地回环/环回地址，一般用来测试本机网卡是否正常</p></li></ul><h2 id="2-2-ping"><a href="#2-2-ping" class="headerlink" title="2.2 ping"></a>2.2 ping</h2>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>检测到目标主机是否连接正常</span><br><span class="line"><span class="meta">$</span> ping IP地址</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>检测本地网卡工作正常</span><br><span class="line"><span class="meta">$</span> ping 127.0.0.1</span><br></pre></td></tr></table></figure><ul><li><p><code>ping</code> 一般用于检测当前计算机到目标计算机之间的网络 <strong>是否通畅</strong>，<strong>数值越大，速度越慢</strong></p><blockquote><ul><li><code>ping</code>的的工作原理与潜水艇的声纳相似，<code>ping</code>这个命令就是取自声呐的声音</li><li>网络管理员之间也常将<code>ping</code>用作动词——<strong>ping一下计算机X，看他是否开着</strong></li></ul></blockquote></li></ul><h1 id="3-远程登录和复制文件"><a href="#3-远程登录和复制文件" class="headerlink" title="3. 远程登录和复制文件"></a>3. 远程登录和复制文件</h1><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ssh  用户名@ip</td><td>secure shell</td><td>关机/重新启动</td></tr><tr><td>02</td><td>scp  用户名@ip：文件名或路径  用户名@ip：文件名或路径</td><td>secure copy</td><td>远程复制文件</td></tr></tbody></table><h2 id="3-1-ssh基础"><a href="#3-1-ssh基础" class="headerlink" title="3.1 ssh基础"></a>3.1 ssh基础</h2><p>在 Linux 中 SSH 是 <strong>非常常用</strong> 的工具，通过 <strong>SSH 客户端</strong> 我们可以连接到运行了 <strong>SSH 服务器</strong> 的远程机器上</p><ul><li><strong>SSH 客户端</strong>是一种使用 <code>Secure Shell（SSH）</code> 协议连接到远程计算机的软件程序</li><li><code>ssh</code>是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议<ul><li>利用 <code>SSH 协议</code> 可以有效<strong>防止远程管理过程中的信息泄露</strong></li><li>通过 <code>SSH 协议</code> 可以对所有传输的数据进行加密，也能够防止 DNS 欺骗和 IP 欺骗</li></ul></li><li><code>SSH</code> 的另一项优点是传输的数据可以是经过压缩的，所以可以加快传输的速度</li></ul><h3 id="1-域名-和-端口号"><a href="#1-域名-和-端口号" class="headerlink" title="1) 域名 和 端口号"></a>1) 域名 和 端口号</h3><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><ul><li>由一串 <strong>用点分隔</strong> 的名字组成，例如：<code>www.itcast.cn</code></li><li>是 <strong>IP 地址</strong> 的别名，方便用户记忆</li></ul><h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><ul><li><strong>IP 地址</strong>：通过 <strong>IP 地址</strong> 找到网络上的 <strong>计算机</strong></li><li><strong>端口号</strong>：通过 <strong>端口号</strong> 可以找到 <strong>计算机上运行的应用程序</strong><ul><li><strong>SSH 服务器</strong> 的默认端口号是 <code>22</code>，如果是默认端口号，在连接的时候，可以省略</li></ul></li><li>常见服务端口号列表：</li></ul><table><thead><tr><th>序号</th><th>服务</th><th>端口号</th></tr></thead><tbody><tr><td>01</td><td>SSH服务器</td><td>22</td></tr><tr><td>02</td><td>Web服务器</td><td>80</td></tr><tr><td>03</td><td>HTTPS</td><td>443</td></tr><tr><td>04</td><td>FTP服务器</td><td>21</td></tr></tbody></table><h3 id="2-SSH-客户端的简单使用"><a href="#2-SSH-客户端的简单使用" class="headerlink" title="2) SSH 客户端的简单使用"></a>2) SSH 客户端的简单使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh [-p port] user@remote</span><br></pre></td></tr></table></figure><ul><li><code>user</code> 是在远程机器上的用户名，如果不指定的话默认为当前用户</li><li><code>remote</code> 是远程机器的地址，可以是 <strong>IP</strong>／<strong>域名</strong>，或者是 <strong>后面会提到的别名</strong></li><li><code>port</code> 是 <strong>SSH Server 监听的端口</strong>，如果不指定，就为默认值 <code>22</code></li></ul><blockquote><p>提示：</p><ul><li>使用 <code>exit</code> 退出当前用户的登录</li></ul><p>注意：</p><ul><li><code>ssh</code> 这个终端命令只能在 <code>Linux</code> 或者 <code>UNIX</code> 系统下使用</li><li>如果在 <code>Windows</code> 系统中，可以安装 <code>PuTTY</code> 或者 <code>XShell</code> 客户端软件即可</li></ul><p>提示：</p><ul><li>在工作中，SSH 服务器的端口号很有可能<strong>不是 22</strong>，如果遇到这种情况就需要使用 <code>-p</code> 选项，指定正确的端口号，否则无法正常连接到服务器</li></ul></blockquote><h3 id="3-Windows-下-SSH-客户端的安装"><a href="#3-Windows-下-SSH-客户端的安装" class="headerlink" title="3) Windows 下 SSH 客户端的安装"></a>3) Windows 下 SSH 客户端的安装</h3><ul><li><code>Putty</code> <a href="http://www.chiark.greenend.org.uk/%7Esgtatham/putty/latest.html" target="_blank" rel="noopener">http://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html</a></li><li><code>XShell</code> <a href="http://xshellcn.com" target="_blank" rel="noopener">http://xshellcn.com</a></li></ul><blockquote><p>建议从官方网站下载正式的安装程序</p></blockquote><h2 id="3-2-scp"><a href="#3-2-scp" class="headerlink" title="3.2 scp"></a>3.2 <code>scp</code></h2><ul><li>scp 就是 <code>secure copy</code>，是一个在 Linux 下用来进行 <strong>远程拷贝文件</strong> 的命令</li><li>它的<strong>地址格式与 ssh 基本相同</strong>，<strong>需要注意的是</strong>，在指定端口时用的是大写的 <code>-P</code> 而不是小写的</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把本地当前目录下的 01.py 文件 复制到 远程 家目录下的 Desktop/01.py</span></span><br><span class="line"><span class="comment"># 注意：`:` 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径</span></span><br><span class="line">scp -P port 01.py user@remote:Desktop/01.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把远程 家目录下的 Desktop/01.py 文件 复制到 本地当前目录下的 01.py</span></span><br><span class="line">scp -P port user@remote:Desktop/01.py 01.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加上 -r 选项可以传送文件夹</span></span><br><span class="line"><span class="comment"># 把当前目录下的 demo 文件夹 复制到 远程 家目录下的 Desktop</span></span><br><span class="line">scp -r demo user@remote:Desktop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把远程 家目录下的 Desktop 复制到 当前目录下的 demo 文件夹</span></span><br><span class="line">scp -r user@remote:Desktop demo</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-r</td><td>若给出的源文件是目录文件，则 scp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名</td></tr><tr><td>-P</td><td>若远程 SSH 服务器的端口不是 22，需要使用大写字母 -P 选项指定端口</td></tr></tbody></table><blockquote><p>注意：</p><ul><li><code>scp</code> 这个终端命令只能在 <code>Linux</code> 或者 <code>UNIX</code> 系统下使用</li><li>如果在 <code>Windows</code> 系统中，可以安装 <code>PuTTY</code>，使用 <code>pscp</code> 命令行工具或者安装 <code>FileZilla</code> 使用 <code>FTP</code> 进行文件传输</li></ul></blockquote><h3 id="FileZilla"><a href="#FileZilla" class="headerlink" title="FileZilla"></a><code>FileZilla</code></h3><ul><li>官方网站：<a href="https://www.filezilla.cn/download/client" target="_blank" rel="noopener">https://www.filezilla.cn/download/client</a></li><li><code>FileZilla</code> 在传输文件时，使用的是 <code>FTP 服务</code> 而不是 <code>SSH 服务</code>，因此端口号应该设置为 <code>21</code></li></ul><h2 id="3-3-SSH-高级"><a href="#3-3-SSH-高级" class="headerlink" title="3.3 SSH 高级"></a>3.3 SSH 高级</h2><ul><li>免密码登录</li><li>配置别名</li></ul><blockquote><p>提示：有关 SSH 配置信息都保存在用户家目录下的 <code>.ssh</code> 目录下</p></blockquote><h3 id="1）免密码登录"><a href="#1）免密码登录" class="headerlink" title="1）免密码登录"></a>1）免密码登录</h3><p><strong>步骤</strong></p><ul><li>配置公钥<ul><li>执行 <code>ssh-keygen</code> 即可生成 SSH 钥匙，一路回车即可</li></ul></li><li>上传公钥到服务器<ul><li>执行 <code>ssh-copy-id -p port user@remote</code>，可以让远程服务器记住我们的公钥</li></ul></li></ul><blockquote><p>非对称加密算法</p><ul><li>使用 <strong>公钥</strong> 加密的数据，需要使用 <strong>私钥</strong> 解密</li><li>使用 <strong>私钥</strong> 加密的数据，需要使用 <strong>公钥</strong> 解密</li></ul></blockquote><h3 id="2-配置别名"><a href="#2-配置别名" class="headerlink" title="2) 配置别名"></a>2) 配置别名</h3><p>每次都输入 <code>ssh -p port user@remote</code>，时间久了会觉得很麻烦，特别是当 <code>user</code>, <code>remote</code> 和 <code>port</code> 都得输入，而且还不好记忆</p><p>而 <strong>配置别名</strong> 可以让我们进一步偷懒，譬如用：<code>ssh mac</code> 来替代上面这么一长串，那么就在 <code>~/.ssh/config</code> 里面追加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host mac</span><br><span class="line">    HostName ip地址</span><br><span class="line">    User itheima</span><br><span class="line">    Port 22</span><br></pre></td></tr></table></figure><p><strong>保存之后，即可用 ssh mac 实现远程登录了，scp 同样可以使用</strong></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux基础03-文件相关命令</title>
      <link href="/2019/03/21/Linux%E5%9F%BA%E7%A1%8003-%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/03/21/Linux%E5%9F%BA%E7%A1%8003-%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="1-创建和删除操作"><a href="#1-创建和删除操作" class="headerlink" title="1. 创建和删除操作"></a>1. 创建和删除操作</h1><h2 id="1-1-touch"><a href="#1-1-touch" class="headerlink" title="1.1 touch"></a>1.1 touch</h2><ul><li>如果文件不存在，可以创建一个空白文件。</li><li>如果文件已经存在，可以修改文件的末次修改日期。</li></ul><h2 id="1-2-mkdir"><a href="#1-2-mkdir" class="headerlink" title="1.2 mkdir"></a>1.2 mkdir</h2><ul><li>创建一个新的目录</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-p</td><td>可以递归创建目录</td></tr></tbody></table><blockquote><p>新建目录的名称不能与当前目录中已有的目录或文件夹同名。</p></blockquote><h2 id="1-3-rm"><a href="#1-3-rm" class="headerlink" title="1.3 rm"></a>1.3 rm</h2><ul><li>删除文件或目录</li></ul><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-f</td><td>强制删除，忽略不存在的文件，无需提示</td></tr><tr><td>-r</td><td>递归地删除目录下的内容，删除文件夹时必须加此参数</td></tr></tbody></table><p><strong>注意！</strong>不要使用rm  -rf  /* 命令！！！在虚拟机里面可以试试，然后重装。</p><h1 id="2-拷贝和移动文件"><a href="#2-拷贝和移动文件" class="headerlink" title="2. 拷贝和移动文件"></a>2. 拷贝和移动文件</h1><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>tree[目录名]</td><td>tree</td><td>以树形图列出文件目录结构</td></tr><tr><td>02</td><td>cp  源文件  目标文件</td><td>copy</td><td>复制文件或目录</td></tr><tr><td>03</td><td>mv  源文件  目标文件</td><td>move</td><td>移动文件或目录/文件或目录重命名</td></tr></tbody></table><h2 id="2-1-tree"><a href="#2-1-tree" class="headerlink" title="2.1 tree"></a>2.1 tree</h2><ul><li><code>tree</code>命令可以以树形图列出文件目录结构</li><li><code>tree ~</code> <code>tree /</code></li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-d</td><td>只显示目录</td></tr></tbody></table><h2 id="2-2-cp"><a href="#2-2-cp" class="headerlink" title="2.2 cp"></a>2.2 cp</h2><ul><li><code>cp</code>命令的功能是将给出的文件或目录复制到另一个文件或目录中，相当于DOS下的<code>copy</code>命令。</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-r</td><td>已经存在的目标文件直接覆盖，不会提示</td></tr><tr><td>-i</td><td>覆盖文件前提示</td></tr><tr><td>-r</td><td>若给出的源文件是目录文件，则cp将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名。</td></tr></tbody></table><h2 id="2-3-mv"><a href="#2-3-mv" class="headerlink" title="2.3 mv"></a>2.3 mv</h2><ul><li><code>mv</code>命令可以用来移动文件或目录，也可以给文件或目录重命名。</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-i</td><td>覆盖文件前提示</td></tr></tbody></table><h1 id="3-查看文件内容"><a href="#3-查看文件内容" class="headerlink" title="3. 查看文件内容"></a>3. 查看文件内容</h1><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>cat 文件名</td><td>concatenate</td><td>查看文件内容、创建文件、文件合并、追加文件内容等功能</td></tr><tr><td>02</td><td>more 文件名</td><td>more</td><td>分屏显示文件内容</td></tr><tr><td>03</td><td>grep 搜索文本文件名</td><td>grep</td><td>搜索文本文件内容</td></tr></tbody></table><h2 id="3-1-cat"><a href="#3-1-cat" class="headerlink" title="3.1 cat"></a>3.1 cat</h2><ul><li><code>cat</code>命令可以用来查看文件内容、创建文本、文件合并、追加文本内容等功能</li><li><code>cat</code>会一次显示所有的内容，适合查看内容较少的文本文件</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-b</td><td>对非空输出行编号</td></tr><tr><td>-n</td><td>对输出的所有行编号</td></tr></tbody></table><blockquote><p>Linux中还有一个<code>nl</code>的命令和<code>cat -b</code>的效果等价。</p></blockquote><h2 id="3-2-more"><a href="#3-2-more" class="headerlink" title="3.2 more"></a>3.2 more</h2><ul><li><code>more</code>命令可以用于分屏显示较多的文件内容，每次只显示一页内容</li><li>适合于查看内容较多的文本文件</li></ul><p>使用<code>more</code>的操作键：</p><table><thead><tr><th>操作键</th><th>功能</th></tr></thead><tbody><tr><td>空格键</td><td>显示手册页的下一页</td></tr><tr><td>Enter</td><td>一次滚动手册的一行</td></tr><tr><td>b</td><td>回滚一屏</td></tr><tr><td>f</td><td>前滚一屏</td></tr><tr><td>q</td><td>退出</td></tr><tr><td>/word</td><td>搜索word字符串</td></tr></tbody></table><h2 id="3-3-grep"><a href="#3-3-grep" class="headerlink" title="3.3 grep"></a>3.3 grep</h2><ul><li>Linux系统中grep命令是一种强大的文本搜索工具</li><li>grep允许对文本文件进行模式查找，所谓模式查找，又被称为正则表达式</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-n</td><td>显示匹配行及行号</td></tr><tr><td>-v</td><td>显示不包含匹配文本的所有行（相当于求反）</td></tr><tr><td>-i</td><td>忽略大小写</td></tr></tbody></table><ul><li>常用的两种模式查找</li></ul><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>^a</td><td>行首，搜索以a开头的行</td></tr><tr><td>a$</td><td>行尾，搜索以a结束的行</td></tr></tbody></table><h1 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h1><h2 id="4-1-echo-文字内容"><a href="#4-1-echo-文字内容" class="headerlink" title="4.1 echo  文字内容"></a>4.1 echo  文字内容</h2><ul><li><code>echo</code>会在终端中显示参数指定的文字，通常会和重定向联合使用</li></ul><h2 id="4-2-重定向-gt-和-gt-gt"><a href="#4-2-重定向-gt-和-gt-gt" class="headerlink" title="4.2 重定向 &gt; 和 &gt;&gt;"></a>4.2 重定向 &gt; 和 &gt;&gt;</h2><ul><li>Linux允许将命令执行结果重定向到一个文件</li><li>将文本显示到终端上的内容 输出 / 追加到指定文件中</li></ul><p>注意：</p><ul><li><code>&gt;</code>表示输出，会覆盖文件原有的内容</li><li><code>&gt;&gt;</code>表示追加，会将内容追加到已有文件的末尾</li></ul><h2 id="4-3-管道"><a href="#4-3-管道" class="headerlink" title="4.3 管道 |"></a>4.3 管道 |</h2><ul><li>Linux允许将 <strong>一个命令的输出</strong> 可以<strong>通过</strong> 作为<strong>另一个命令的输入</strong></li><li>可以理解现实生活中的管子，管子的一头塞东西进去，另一头取出来。这里 | 的左右分为两端，左端塞东西（写），右端取东西（读）。</li></ul><p>常用的管道命令有：</p><ul><li><code>more</code>分屏显示内容</li><li><code>grep</code>在命令执行结果的基础上查询指定的文本</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux基础02-目录相关命令</title>
      <link href="/2019/03/21/Linux%E5%9F%BA%E7%A1%8002-%E7%9B%AE%E5%BD%95%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/03/21/Linux%E5%9F%BA%E7%A1%8002-%E7%9B%AE%E5%BD%95%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="1-ls命令说明"><a href="#1-ls命令说明" class="headerlink" title="1. ls命令说明"></a>1. ls命令说明</h1><blockquote><p><strong>Linux下文件和目录的特点</strong></p><ul><li>Linux文件或目录名称最长可以有256个字符</li><li>以<code>.</code>开头的文件为隐藏文件，需要<code>-a</code>参数才能显示</li><li><code>.</code>代表当前目录</li><li><code>..</code>代表上一级目录</li><li><code>/</code>代表根目录</li><li><code>~</code>代表<strong>当前用户</strong>home目录</li></ul></blockquote><h2 id="1-1-ls常用选项"><a href="#1-1-ls常用选项" class="headerlink" title="1.1 ls常用选项"></a>1.1 ls常用选项</h2><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-a</td><td>显示指定目录下所有子目录与文件</td></tr><tr><td>-l</td><td>以列表方式显示文件的详细信息</td></tr><tr><td>-h</td><td>配合 -l 以人性化的方式显示文件大小</td></tr></tbody></table><h2 id="1-2-ls通配符的使用"><a href="#1-2-ls通配符的使用" class="headerlink" title="1.2 ls通配符的使用"></a>1.2 ls通配符的使用</h2><table><thead><tr><th>通配符</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>代表任意个数字字符</td></tr><tr><td>？</td><td>代表任意一个字符，至少一个</td></tr><tr><td>[]</td><td>表示可以匹配字符组中的任意一个</td></tr><tr><td>[abc]</td><td>匹配a、b、c中的任意一个</td></tr><tr><td>[a-f]</td><td>匹配从a 到 f 范围内的任意一个字符</td></tr></tbody></table><p>说明：这里是正则表达式的知识。</p><h1 id="2-切换目录"><a href="#2-切换目录" class="headerlink" title="2. 切换目录"></a>2. 切换目录</h1><h2 id="2-1-cd"><a href="#2-1-cd" class="headerlink" title="2.1 cd"></a>2.1 cd</h2><ul><li><code>cd</code>是<strong>change directory</strong>的简写，其作用是更改当前的工作目录。</li></ul><blockquote><p>注意：Linux所有的目录和文件名都是大小写敏感的。</p></blockquote><table><thead><tr><th>命令</th><th>含义</th></tr></thead><tbody><tr><td>cd</td><td>切换到当前用户的主目录（/home/用户目录）</td></tr><tr><td>cd ~</td><td>切换到当前用户的主目录（/home/用户目录）</td></tr><tr><td>cd .</td><td>保持在当前目录不变</td></tr><tr><td>cd ..</td><td>切换到上级目录</td></tr><tr><td>cd -</td><td>可以在最近两次工作目录之间来回切换</td></tr></tbody></table><h2 id="2-2-相对路径和绝对路径"><a href="#2-2-相对路径和绝对路径" class="headerlink" title="2.2 相对路径和绝对路径"></a>2.2 相对路径和绝对路径</h2><ul><li><strong>相对路径</strong> 在输入路径时，最前面不是 / 或者 ~，表示相对当前目录所在的目录位置。</li><li><strong>绝对路径</strong> 在输入路径时，最前面是 / 或者 ~，表示从根目录 / 家目录开始的具体位置。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux基础01-Linux命令简介</title>
      <link href="/2019/03/21/Linux%E5%9F%BA%E7%A1%8001-Linux%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B/"/>
      <url>/2019/03/21/Linux%E5%9F%BA%E7%A1%8001-Linux%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="1-常用Linux命令的基本使用"><a href="#1-常用Linux命令的基本使用" class="headerlink" title="1. 常用Linux命令的基本使用"></a>1. 常用Linux命令的基本使用</h1><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ls</td><td>list</td><td>查看当前文件夹下的内容</td></tr><tr><td>02</td><td>pwd</td><td>print work directory</td><td>查看当前文件夹路径</td></tr><tr><td>03</td><td>cd[目录名]</td><td>change directory</td><td>切换文件夹</td></tr><tr><td>04</td><td>touch[文件名]</td><td>touch</td><td>新建文件</td></tr><tr><td>05</td><td>mkdir[目录名]</td><td>make directory</td><td>创建目录</td></tr><tr><td>06</td><td>rm[文件名]</td><td>remove</td><td>删除指定的文件名</td></tr><tr><td>07</td><td>clear</td><td>clear</td><td>清屏</td></tr></tbody></table><blockquote><p><strong><em>小技巧</em></strong></p><ul><li><code>ctrl + shift + =</code><strong>放大</strong>终端窗口的字体显示</li><li><code>ctrl + -</code><strong>缩小</strong>终端窗口的字体显示 </li></ul></blockquote><h1 id="2-自动补全"><a href="#2-自动补全" class="headerlink" title="2. 自动补全"></a>2. 自动补全</h1><h2 id="2-1-自动补全"><a href="#2-1-自动补全" class="headerlink" title="2.1 自动补全"></a>2.1 自动补全</h2><p>在敲出<code>文件</code>/<code>目录</code>/<code>命令</code>的前几个字母之后，按下<code>tab</code>键</p><ul><li>如果输入的没有歧义，系统会自动补全</li><li>如果还有其他<code>文件</code>/<code>目录</code>/<code>命令</code>,再按一下<code>tab</code>键，系统会提示可能存在的命令。</li></ul><h2 id="2-2-曾经使用过的命令"><a href="#2-2-曾经使用过的命令" class="headerlink" title="2.2 曾经使用过的命令"></a>2.2 曾经使用过的命令</h2><ul><li>按<code>上</code>/<code>下</code>光标键可以在曾经使用的命令之间来回切换</li><li>如果想要退出选择，并且不想执行当前选中的命令，可以按<code>ctrl + c</code></li></ul><h1 id="3-Linux终端命令格式"><a href="#3-Linux终端命令格式" class="headerlink" title="3. Linux终端命令格式"></a>3. Linux终端命令格式</h1><h2 id="3-1-终端命令格式"><a href="#3-1-终端命令格式" class="headerlink" title="3.1 终端命令格式"></a>3.1 终端命令格式</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command [-options] [parameter]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li><code>command</code>：命令名，相应功能的英文单词或单词的缩写</li><li><code>[-options]</code>:选项，可用来对命令进行控制，也可以省略</li><li><code>parameter</code>:传给命令的参数，可以是<strong>零个、一个或者多个</strong></li></ul><h2 id="3-2-查阅命令帮助信息"><a href="#3-2-查阅命令帮助信息" class="headerlink" title="3.2 查阅命令帮助信息"></a>3.2 查阅命令帮助信息</h2><ul><li><p><strong>–help</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command --help</span><br></pre></td></tr></table></figure><p>说明：显示<code>command</code>命令的帮助信息</p></li><li><p><strong>man</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man command</span><br></pre></td></tr></table></figure><p>说明：查阅<code>command</code>命令的使用手册</p><blockquote><p><code>man</code>是manual的缩写，是Linux提供的一个手册，包含了绝大多数的命令、函数的详细使用说明</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>少年时代的爱,不过是表演【选自意林】</title>
      <link href="/2019/01/30/%E5%B0%91%E5%B9%B4%E6%97%B6%E4%BB%A3%E7%9A%84%E7%88%B1,%E4%B8%8D%E8%BF%87%E6%98%AF%E8%A1%A8%E6%BC%94%E3%80%90%E9%80%89%E8%87%AA%E6%84%8F%E6%9E%97%E3%80%91/"/>
      <url>/2019/01/30/%E5%B0%91%E5%B9%B4%E6%97%B6%E4%BB%A3%E7%9A%84%E7%88%B1,%E4%B8%8D%E8%BF%87%E6%98%AF%E8%A1%A8%E6%BC%94%E3%80%90%E9%80%89%E8%87%AA%E6%84%8F%E6%9E%97%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;高中的时候，我曾经交往过一个女朋友。有一天我半夜从梦中醒来，突然无比的想她。那时候手机还没有像现在这样普及，我的思念自然无从寄托。在床上瞪了一会儿眼睛以后，我跳起来麻利地穿好衣服，出门去找她了。尽管第二天上早自习我就能够见到她。那时候我以为了方便学习的名义在外面自己租房住，所以也不会遇到宿管大爷这种阻碍，可以来一场说走就走。出了门才发现外面下着大雪，地上已经有着厚厚的积雪，天空中雪花还如筛灰一般落下。但心怀着爱情的炽热，我丝毫没觉得冷。北方下雪的冬夜格外寂静，此时已经是凌晨两点以后，街上没有一个行人，只有我自己踏在积雪上的声音格外清晰。我穿过那条横穿这个小县城的街道，来到我当时女朋友家的楼下。然而我什么都做不了，楼门紧锁，况且即使开着我也没勇气在半夜里去挑战她母亲的忍耐度。于是我在楼下冒着大雪站了一会儿，抽了一支烟，惆怅了一阵子之后，就顺道拐去了网吧……直到很久以后，时过境迁，妹子已经再无联系，而我也不是那能半夜扛住风雪的鸡血少年，我才领悟自己当时的心态。那不过是一种表演罢了，除了把自己感动一下，制造一点自己痴情的假象，一点意义都没有。在感情中，我们往往觉得自己掏心掏肺，所做所为能够感天动地，闻者伤心，见者叹息，为什么偏偏感动不了你？我们总是容易用一种自虐的方式制造出一种痴情的假象来使得自己站在感情的道德制高点上，获得一种畸形的满足感和安全感。其实无论是雪夜去对方家楼下站会儿或者是冒着大雨给她送一杯奶茶什么的，自己回想起来往往觉得如乔峰大战聚贤庄、关羽千里走单骑一样壮怀激烈，而对于对方来说，一杯奶茶就是一杯奶茶，无法承载起你想要在上面寄托的山崩地裂的情怀。少年的时候，总是迫不及待地将自己的满腔爱意表达出来，而结果往往是陷入表演之中而不自知。所以两个人的记忆才会出现偏差，那些你觉得刻骨铭心的过去，对方往往没有同样的感觉，甚至茫然不知。成长的标志就是懂得克制自己。克制自己的情绪，克制自己的表演欲，甚至克制自己的喜欢。少年时候，喜欢一个人恨不能把她变成自己身体的一部分，她刚说冷，我这边心里已经结冰了，她说难过，我立马如丧考妣，比她还难过，唯恐无法将自己的爱意表达出来。而事实上，谁也无法承担起另一个人的价值寄托，只有做一个独立、有价值的人，才能真正学会去爱另一个人。也千万不要尝试改变另一个人，这注定是徒劳的。做自己就好，爱情的真谛在于相互的吸引、志趣相投的同行，而不是追逐和依附。</p>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 情感 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>NTRU算法的分析</title>
      <link href="/2019/01/23/NTRU%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E6%9E%90/"/>
      <url>/2019/01/23/NTRU%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="NTRU简述"><a href="#NTRU简述" class="headerlink" title="NTRU简述"></a>NTRU简述</h2><p>&#160; &#160; &#160; &#160;NTRU(Number Theory Research Unit)公开密钥体制是由美国布朗大学三位数学教授(Jeffrey Hoffstein,JillPipher,Joseph H.Silverman)发明的，其安全性是基于数论中在一个非常大的维数格中寻找一个很短向量的数学难题。相对于离散对数或大数分解等公开秘密体制来说，它有许多优势。在安全性方面，NTRU算法具有抵抗量子计算攻击的能力，而RSA和ECC算法是无法抵抗量子计算的。</p><h2 id="NTRU算法的描述"><a href="#NTRU算法的描述" class="headerlink" title="NTRU算法的描述"></a>NTRU算法的描述</h2><h3 id="NTRU算法的数论基础"><a href="#NTRU算法的数论基础" class="headerlink" title="NTRU算法的数论基础"></a>NTRU算法的数论基础</h3><p>&#160; &#160; &#160; &#160;设有整数环Z、整数N$ \geq$2，用R表示多项式截断环时，R可以写成：R=Z[X]/(X^N^-1)，对于任意的正整数q，令R _q_ 代表模q的多项式截断环时，R _q_可以写成：    </p><p>$$ R _q_ =(Z/ _q_ Z )[X]/(X ^N^ -1) </p><p>​    可以证明当q时素数时，R具有可逆性。</p><h3 id="NTRU算法的描述-1"><a href="#NTRU算法的描述-1" class="headerlink" title="NTRU算法的描述"></a>NTRU算法的描述</h3><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 密码学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NTRU </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何在Hexo博客中添加网易云音乐播放器</title>
      <link href="/2019/01/23/%E5%A6%82%E4%BD%95%E5%9C%A8Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%B7%BB%E5%8A%A0%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/"/>
      <url>/2019/01/23/%E5%A6%82%E4%BD%95%E5%9C%A8Hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%B7%BB%E5%8A%A0%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%92%AD%E6%94%BE%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;在已经搭建好Github Page博客的前提下，我们可以在自己的博客中加上音乐播放器，那就非常完美啦！这里我选择网易云音乐。<a id="more"></a></p><h2 id="步骤一"><a href="#步骤一" class="headerlink" title="步骤一"></a>步骤一</h2><p>&#160; &#160; &#160; &#160;首先，打开网易云音乐网站，登录自己的账号打开自己的歌单（歌单可以在PC端或者APP客户端上自由创建），也可以不登录直接搜索自己最近最喜欢的一首歌，点击后找到生成外链的链接，如下图：</p><p><img src="/2019/01/23/如何在Hexo博客中添加网易云音乐播放器/1.jpg" alt="图1"></p><h2 id="步骤二"><a href="#步骤二" class="headerlink" title="步骤二"></a>步骤二</h2><p>&#160; &#160; &#160; &#160;你将会看到如下信息，网易云提供两种方式，一种iframe标签嵌套，另一个是flash插件，两种实现都可以。这里选择第一个。</p><p><img src="/2019/01/23/如何在Hexo博客中添加网易云音乐播放器/2.jpg" alt="图2"></p><h2 id="步骤三"><a href="#步骤三" class="headerlink" title="步骤三"></a>步骤三</h2><p>&#160; &#160; &#160; &#160;接下来，可以根据自己需求选择尺寸。</p><p><img src="/2019/01/23/如何在Hexo博客中添加网易云音乐播放器/3.jpg" alt="图3"></p><h2 id="步骤四"><a href="#步骤四" class="headerlink" title="步骤四"></a>步骤四</h2><p>&#160; &#160; &#160; &#160;然后，复制HTML代码，在根目录下的/theme/next/layout/_macro/sidebar.swig文件（侧边栏布局文件）中，选择你要添加播放器的位置，这里我选择添加在第136行处，并修改width=350，height=110。</p><p><img src="/2019/01/23/如何在Hexo博客中添加网易云音乐播放器/4.jpg" alt="图4"></p><h2 id="步骤五"><a href="#步骤五" class="headerlink" title="步骤五"></a>步骤五</h2><p>&#160; &#160; &#160; &#160;大功告成！效果如下图:</p><p><img src="/2019/01/23/如何在Hexo博客中添加网易云音乐播放器/5.jpg" alt="图5"></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github Page </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何在列表，字典，集合中根据条件筛选数据</title>
      <link href="/2019/01/17/%E5%A6%82%E4%BD%95%E5%9C%A8%E5%88%97%E8%A1%A8%EF%BC%8C%E5%AD%97%E5%85%B8%EF%BC%8C%E9%9B%86%E5%90%88%E4%B8%AD%E6%A0%B9%E6%8D%AE%E6%9D%A1%E4%BB%B6%E7%AD%9B%E9%80%89%E6%95%B0%E6%8D%AE/"/>
      <url>/2019/01/17/%E5%A6%82%E4%BD%95%E5%9C%A8%E5%88%97%E8%A1%A8%EF%BC%8C%E5%AD%97%E5%85%B8%EF%BC%8C%E9%9B%86%E5%90%88%E4%B8%AD%E6%A0%B9%E6%8D%AE%E6%9D%A1%E4%BB%B6%E7%AD%9B%E9%80%89%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="实际案例"><a href="#实际案例" class="headerlink" title="实际案例"></a>实际案例</h2><ol><li><p>过滤掉列表[3,9，-1，10,20，-2…]中的负数</p></li><li><p>筛选字典{‘LiLei’:79,’Jim’:88,’Lucy’:92…}中值高于90的项</p></li><li>筛选集合{77,89,32,20…}中能被3整除的元素</li></ol><p>对于以上问题，通常做法是通过迭代循环解决。比如问题1解决代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">-3</span>,<span class="number">-2</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">9</span>]</span><br><span class="line">res = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> data:</span><br><span class="line">    <span class="keyword">if</span> x &gt;= <span class="number">0</span>:</span><br><span class="line">        res.append(x)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><h2 id="在列表中根据条件筛选数据"><a href="#在列表中根据条件筛选数据" class="headerlink" title="在列表中根据条件筛选数据"></a>在列表中根据条件筛选数据</h2><ul><li><p>filter函数</p></li><li><p>列表解析</p><p>一.<strong>filter()</strong> 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。</p><p>该函数接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line">data = [randint(<span class="number">-10</span>, <span class="number">10</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">print(data)</span><br><span class="line">res = filter(<span class="keyword">lambda</span> x: x &gt;= <span class="number">0</span>, data)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><p>注：<strong>lambda</strong>函数是匿名函数</p><p>二.列表解析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x for x in data if x &gt;= 0]</span><br></pre></td></tr></table></figure></li></ul><h2 id="在字典中根据条件筛选数据"><a href="#在字典中根据条件筛选数据" class="headerlink" title="在字典中根据条件筛选数据"></a>在字典中根据条件筛选数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line">d = &#123;x: randint(<span class="number">60</span>, <span class="number">100</span>) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">21</span>)&#125;</span><br><span class="line">print(d)</span><br><span class="line">res = &#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> d.iteritems() <span class="keyword">if</span> v &gt; <span class="number">90</span>&#125;</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><h2 id="在集合中根据条件筛选数据"><a href="#在集合中根据条件筛选数据" class="headerlink" title="在集合中根据条件筛选数据"></a>在集合中根据条件筛选数据</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = [randint(<span class="number">-10</span>, <span class="number">10</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">s = set(data)</span><br><span class="line">res = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> s <span class="keyword">if</span> x%<span class="number">3</span> == <span class="number">0</span>&#125;</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> filter </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/10/19/hello-world/"/>
      <url>/2018/10/19/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
