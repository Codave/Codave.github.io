{"meta":{"title":"未来可期","subtitle":"技术博客","description":"不负过往，不惧未来。","author":"Codave","url":"https://codave.github.io"},"pages":[{"title":"关于","date":"2018-10-20T06:55:15.000Z","updated":"2019-01-23T08:11:17.850Z","comments":true,"path":"about/index.html","permalink":"https://codave.github.io/about/index.html","excerpt":"","text":"“人永远都无法知道自己该要什么，因为人只能活一次，既不能拿它跟前世相比，也不能在来生加以修正。没有任何方法可以检验哪种抉择是好的，因为不存在任何比较。一切都是马上经历，仅此一次，不能准备。”"},{"title":"分类","date":"2018-10-20T06:50:31.000Z","updated":"2018-10-21T01:41:51.465Z","comments":true,"path":"categories/index.html","permalink":"https://codave.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-10-20T06:48:56.000Z","updated":"2018-10-21T01:42:10.598Z","comments":true,"path":"tags/index.html","permalink":"https://codave.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"C++语法18-类模板与类函数","slug":"C-语法18-类模板与类函数","date":"2019-06-05T02:24:07.000Z","updated":"2019-06-05T13:17:38.846Z","comments":true,"path":"2019/06/05/C-语法18-类模板与类函数/","link":"","permalink":"https://codave.github.io/2019/06/05/C-语法18-类模板与类函数/","excerpt":"","text":"所谓类模板，实际上是建立一个通用类，其数据成员、成员函数的返回类型和形参类型不具体指定，用一个虚拟的类型来代表。使用类模板定义对象时，系统会根据实参的类型来取代模板中虚拟类型从而实现了不同类的功能。 定义一个类模板与定义函数模板的格式类似，必须以关键字template开始，后面是尖括号括起来的模板参数，然后是类名，其格式如下： template&lt;typename类型参数&gt; class 类名{ ​ 类成员声明 }； 也可以定义成如下形式： template class 类名{ ​ 类成员声明 }； 与函数模板类似，其中，template是一个声明模板的关键字，它表示声明一个模板。类型参数（通常用C++标示符表示，如T、Type等）实际上是一个虚拟的类型名，现在并未指定它是哪一种具体的类型，但使用类模板时，必须将类型参数实例化。类型参数前需要加关键字typename（或class），typename和class作用相同，都是表示其后的参数是一个虚拟的类型名（即类型参数）。 在声明中，预采用通用数据类型的数据成员、成员函数的参数或返回类型前面需要加上类型参数。 用类模板定义对象时，采用以下形式： 类模板名 &lt;实际类型名&gt;对象名[(实参表列)]； 12345678910111213141516171819202122232425类模板的使用举例#include&lt;iostream&gt;using namespace std;template&lt;typename T&gt;class Compare&#123; public: Compare(T a,T b)&#123; x=a;y=b; &#125; T max()&#123; return (x&gt;y)?x:y; &#125; private: T x,y;&#125;;int main()&#123; Compare&lt;int&gt; com1(3,7); Compare&lt;double&gt; com2(12.34,56.78); Compare&lt;char&gt; com3('a','x'); cout&lt;&lt;\"其中的最大值是：\"&lt;&lt;com1.max()&lt;&lt;nedl; cout&lt;&lt;\"其中的最大值是：\"&lt;&lt;com2.max()&lt;&lt;endl; cout&lt;&lt;\"其中的最大值是：\"&lt;&lt;com3.max()&lt;&lt;endl; return 0;&#125; 说明：类模板中的成员函数也可以在类模板体外进行定义。此时，若成员函数中有类型参数存在，则C++有以下一些特殊的规定： （1）需要在成员函数定义之前进行模板声明； （2）在成员函数名前缀上“类名&lt;类型参数&gt;::”。 在类模板体外定义的成员函数的一般形式如下： 1234template&lt;typename 类型参数&gt;函数类型 类名&lt;类型参数&gt;::成员函数名（形参表）&#123; ...&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://codave.github.io/categories/C/"}],"tags":[{"name":"类模板","slug":"类模板","permalink":"https://codave.github.io/tags/类模板/"},{"name":"模板类","slug":"模板类","permalink":"https://codave.github.io/tags/模板类/"}]},{"title":"C++语法17-函数模板与模板函数","slug":"C-语法17-函数模板与模板函数","date":"2019-06-05T02:23:36.000Z","updated":"2019-06-05T13:17:47.461Z","comments":true,"path":"2019/06/05/C-语法17-函数模板与模板函数/","link":"","permalink":"https://codave.github.io/2019/06/05/C-语法17-函数模板与模板函数/","excerpt":"","text":"所谓模板函数，实际上是建立一个通用函数，其函数返回类型和形参类型不具体指定，用一个虚拟的类型来代表。这个通用函数就称为函数模板。在调用函数时系统会根据实参的类型（模板实参）来取代模板中虚拟类型从而实现了不同函数的功能。 函数模板的声明格式如下： template 返回类型 函数名 （模板形参数） { ​ 函数体 } 也可以定义成如下形式： template 返回类型 函数名 （模板形参数） { ​ 函数体 } 说明： （1）在函数模板中允许使用多个类型参数。但是应当注意template定义部分的每个类型参数类型必须有关键字typename(或class)。 1234567891011#include&lt;iostream&gt;using namespace std;template&lt;typename type1,typename type2&gt;void myfunc(type1 x,type2 y)&#123; cout&lt;&lt;x&lt;&lt;\" \"&lt;&lt;y&lt;&lt;endl;&#125;int main()&#123; myfunc(10,\"hao\"); myfunc(0.123,10L); return 0;&#125; （2）在template语句与函数模板定义语句之间不允许有别的语句。 （3）同一般函数一样，函数模板也可以重载。 （4）函数模板与同名的非模板函数可以重载。在这种情况下，调用的顺序是：首先寻找一个参数完全匹配的废模板函数，如果找到了就调用它；若是没有找到，则寻找函数模板，将其实例化，产生一个匹配的模板函数，若找到了，就是用它。","categories":[{"name":"C++","slug":"C","permalink":"https://codave.github.io/categories/C/"}],"tags":[{"name":"函数模板","slug":"函数模板","permalink":"https://codave.github.io/tags/函数模板/"},{"name":"模板函数","slug":"模板函数","permalink":"https://codave.github.io/tags/模板函数/"}]},{"title":"C++语法16-虚函数","slug":"C++语法16-虚函数","date":"2019-04-27T12:27:05.000Z","updated":"2019-06-05T01:43:37.066Z","comments":true,"path":"2019/04/27/C++语法16-虚函数/","link":"","permalink":"https://codave.github.io/2019/04/27/C++语法16-虚函数/","excerpt":"","text":"虚函数是重载的另一种表现形式。这是一种动态的重载方式，它提供了一种更为灵活的运行时的多态性机制。虚函数允许函数调用与函数体之间的联系在运行时才建立，也就是在运行时才决定如何动作，即所谓的动态联编。 1. 虚函数的定义虚函数就是在基类中被关键字virtual说明，并在派生类中重新定义的函数。虚函数的作用是允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数。 虚基类的定义是在基类中进行的，它是在基类中需要定义为虚函数的成员函数的声明中冠以关键字virtual。定义虚基类的方法如下： virtual 函数类型 函数名（形参表）{ ​ 函数体 } 在基类中的某个成员函数被声明为虚函数后，此虚函数就可以在一个或多个派生类中被重新定义。在派生类中重新定义时，其函数原型，包括函数类型、函数名、参数个数、参数类型的顺序，都必须与基类中的原型完全相同。 12345678910111213141516171819202122232425262728293031虚函数的使用#include&lt;iostream&gt;using namespace std;class B0&#123; public: virtual void print(char* p)&#123; //定义虚函数print cout&lt;&lt;p&lt;&lt;\"print()\"&lt;&lt;endl; &#125;&#125;;class B1:public B0&#123; public: virtual void print(char* p)&#123; //重新定义虚函数print cout&lt;&lt;p&lt;&lt;\"print()\"&lt;&lt;endl; &#125;&#125;;class B2:public B1&#123; public: virtual void print(char* p)&#123; //重新定义虚函数print cout&lt;&lt;p&lt;&lt;\"print()\"&lt;&lt;endl; &#125;&#125;；int main()&#123; B0 ob0,*op; op=&amp;ob0; op-&gt;print(\"B0::\"); B1 ob1; op=&amp;ob1; op-&gt;print(\"B1::\"); B2 ob2; op=&amp;ob2;op-&gt;print(\"B2::\"); return 0;&#125; 说明： （1）若在基类中，只声明虚函数原型（需加上virtual），而在类外定义虚函数时，则不必再加virtual。 （2）在派生类中，虚函数被重新定义时，其函数的原型与基类中的函数原型（即包括函数类型、函数名、参数个数、参数类型、参数类型的顺序）都必须完全相同。 （3）C++规定，当一个成员函数被定义为虚函数后，其派生类中符合重新定义虚函数要求的同名函数都自动成为虚函数。因此，在派生类中重新定义该虚函数时，关键字virtual可以写也可以不写。但是，为了使程序更加清晰，最好在每一层派生类中定义该函数时都加上关键字virtual。 （4）如果在派生类中没有对基类的虚函数重新定义，则公有派生类继承其直接基类的虚函数。一个虚函数无论继承多少次，它仍然保持其虚函数的特性。 （5）虚函数必须是其所在类的成员函数，而不能是友元函数，也不能是静态成员函数，因为虚函数调用要靠特定的对象来决定该激活哪个函数。 （6）虽然使用对象名和点运算符的方式也可以调用虚函数，但是这种调用是在编译时进行的，是静态联编，它没有利用虚函数的特性。只有通过基类的指针访问虚函数时才能获得运行的多态性。 12345678910111213141516171819202122232425262728293031使用对象名和点运算符的方式调用虚函数。#include&lt;iostream&gt;using namespace std;class B0&#123; public: virtual void print(char* p)&#123; cout&lt;&lt;p&lt;&lt;\"print()\"&lt;&lt;endl; &#125;&#125;;class B1:public B0&#123; public: virtual void print(char* p)&#123; cout&lt;&lt;p&lt;&lt;\"print()\"&lt;&lt;endl; &#125;&#125;;class B2:public B1&#123; public: virtual void print(char* p)&#123; cout&lt;&lt;p&lt;&lt;\"print()\"&lt;&lt;endl; &#125;&#125;int main()&#123; B0 ob0; ob0.print(\"B0::\"); B1 ob1; ob1.print(\"B1::\"); B2 ob2; ob2.print(\"B2::\"); return 0;&#125; 2. 虚析构函数在C++中，不能声明虚析构函数，但是可以声明虚析构函数，之前介绍过，当派生类对象撤销时，一般先调用派生类的析构函数，然后再调用基类的析构函数。","categories":[{"name":"C++","slug":"C","permalink":"https://codave.github.io/categories/C/"}],"tags":[{"name":"虚函数","slug":"虚函数","permalink":"https://codave.github.io/tags/虚函数/"}]},{"title":"C++语法15-类型转换","slug":"C++语法15-类型转换","date":"2019-04-27T12:25:36.000Z","updated":"2019-06-04T14:32:18.405Z","comments":true,"path":"2019/04/27/C++语法15-类型转换/","link":"","permalink":"https://codave.github.io/2019/04/27/C++语法15-类型转换/","excerpt":"","text":"1. 系统预定义类型间的转换 类型转换是将一种类型的值转换为另一种类型值。对于系统预定义的标准类型（如int、float、double、char等），C++提供两种类型转换方式：一种是隐式类型转换；另一种是显示类型转换。 1.1 隐式类型转换 隐式类型转换主要遵循以下规则： （1）在赋值表达式A=B的情况下，赋值运算符右端B的值需要转换为A类型进行赋值。 （2）当char或short类型变量与int类型变量进行运算时，将char或short类型转换成int类型。 （3）当两个操作对象类型不一致时，在算术运算前，级别低的类型自动转换为级别高的类型。 1.2 显示类型转换编程人员在程序中可以明确地指出将一种数据类型转换成另一种指定的类型，这种转换成为显示类型转换。 2. 类类型与系统预定义类型间的转换对于用户自己定义的类类型而言，如何实现它们与其他数据类型之间的转换呢？通常，可归纳为以下：（1）通过转换构造函数进行类型转换。 （2）通过类型转换函数进行类型转换。 2.1 转换构造函数 转换构造函数也是构造函数的一种，它具有类型转换的作用，它的作用是将一个其他类型的数据转换成它所在类的对象。 通常，使用转换构造函数将一个指定的数据类型转换为类对象的方法如下： （1）先声明一个类。 （2）在这个类中定义一个只有一个参数的构造函数，参数是待转换类型的数据，在函数体中指定转换的方法。 （3）可以用以下形式进行类型转换。 类名（待转换类型的数据） 说明： （1）转换构造函数也是一种构造函数，它遵循构造函数的一般规则。转换构造函数只有一个参数，作用是将一个其他类型的数据转换它所在类的对象。但是，有一个参数的构造函数不一定是转换构造函数，它可以是普通的构造函数，仅仅起对象初始化的作用。 （2）转换构造函数不仅可以将一个系统预定义的标准类型数据转换成类的对象，也可以将另一个类的对象转换成构造函数所在的类对象。（不做详解） 2.2 类型转换函数通过转换构造函数可以将一个指定类型的数据转换为类的对象。但是不能反过来将一个类的对象转换成其他类型的数据，例如不能将一个Complex类的对象转换成double类型的数据。为此，C++提供了一个称为类型转换函数的函数来解决这个转换问题。类型转换的作用就是将一个类的对象转换成另一类型的数据。在类中，定义类型转换函数的一般格式为： operator 目标类型 （）{ ​ 函数体 } 其中，目标类型为希望转换成的类型名，它既可以是预定义的标准函数也可以是其他类的类型。类型转换函数的函数名为“operator 目标类型”，在函数名前面不能指定函数类型，也不能有参数。通常，其函数体的最后一条语句是return语句，返回值的类型是该函数的目标函数。 123456789101112131415161718192021222324//类型转换的应用#include&lt;iostream&gt;using namespaace std;class Complex&#123; public: Complex(double r=0,double i=0)&#123; real=r; imag=i; &#125; operator double()&#123; return real; &#125; private: double real,imag;&#125;;int main()&#123; Complex com(2.2,4.4); cout&lt;&lt;\"Complex类的对象com转换成double型的数据为：\"； cout&lt;&lt;double(com)&lt;&lt;endl； return 0;&#125; 关于类型转换函数，有以下几点注意事项： （1）类型转换函数只能定义为一个类的成员函数而不能定义为类的友元函数。类型转换函数也可以在类体中声明函数原型，而将函数体定义在类的外部。 （2）类型转换函数既没有参数，也不能在函数名前面指定函数类型。 （3）类型函数中必须有return语句，即必须送回目标类型的数据作为函数的返回值。 （4）一个类可以定义多个类型转换函数。C++编译器将根据类型转换函数名自动地选择一个合适的类型转换函数予以调用。 2.3 转换构造函数和类型转换函数的综合应用12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;class Complex&#123; public: Complex()&#123;&#125; //不带参数的构造函数 Complex(int r,int i)&#123; //带两个参数的构造函数 real=r;imag=i; &#125; Complex（int x)&#123; //转换构造函数，将int类型 real=imag=i/2; &#125; operator int()&#123; return real+imag; &#125; void print()&#123; cout&lt;&lt;\"real:\"&lt;&lt;real&lt;&lt;\"\\t\"&lt;&lt;\"imag:\"&lt;&lt;imag&lt;&lt;endl; &#125; private: int real,imag;&#125;;int main()&#123; Complex a1(1,2),a2(3,4); Complex a3; a3=a1+a2; a3.print(); return 0；&#125; 分析这个程序，读者一定会感到奇怪，类Complex中有没有定义将两个对象相加的运算符重载函数，怎么还可以进行“a1+a2”的操作呢 ？这是由于C++自动进行隐式转换的缘故。这个自动进行类型转换过程的步骤如下： （1）寻找两个Complex类对象相加的运算符重载函数，程序中未找到。 （2）寻找能将Complex类的对象转换成int型数据的类型转换函数operator int()，程序中找到。于是调用其分别将 对象a1和a2隐式转换成int类型的数据3和7。 （3）寻找将两个整数相加的运算符函数，这个运算符函数已经在C++系统中预定义。于是调用这个运算符函数将两个int类型的数据3和7相加得到10。 （4）由于语句“a3=a1+a2;”的赋值号左边是Complex类的对象a3,而右边是int类型数据10，于是隐式调用转换构造函数将int类型数10转换成Complex类的一个临时对象（其real和image都是5），然后将这个临时对象的值赋给Complex类对象a3，执行结果是对象a3的real和image也分别是5。","categories":[{"name":"C++","slug":"C","permalink":"https://codave.github.io/categories/C/"}],"tags":[{"name":"转换构造函数","slug":"转换构造函数","permalink":"https://codave.github.io/tags/转换构造函数/"},{"name":"类型转换函数","slug":"类型转换函数","permalink":"https://codave.github.io/tags/类型转换函数/"}]},{"title":"C++语法14-运算符重载","slug":"C++语法14-运算符重载","date":"2019-04-26T09:02:50.000Z","updated":"2019-04-27T11:35:53.809Z","comments":true,"path":"2019/04/26/C++语法14-运算符重载/","link":"","permalink":"https://codave.github.io/2019/04/26/C++语法14-运算符重载/","excerpt":"","text":"在C++中，除了可以对函数重载外，还可以对大多数运算符实施重载。运算符重载与函数重载相比，稍微复杂一点。运算符重载是通过创建运算符重载函数来实现的。运算符重载函数可以是在类外定义的普通函数，也可以是类的成员函数或友元函数。 1. 在类外定义的运算符重载函数C++为运算符重载提供了一种方法，即在进行运算符重载时，必须定义一个运算符重载函数，其名字为operator，后随一个要重载的运算符。例如，要重载“+”号，应该写一个名字为operator的函数。其他的运算符重载函数也应该以同样的方式命名。 C++语言对运算符重载制定了一些规则： （1）C++中绝大部分的运算符允许重载，不能重载的运算符只有以下几个： . 成员访问运算符 .* 成员指针访问运算符 :: 作用域运算符 Sizeof 长度运算符 ？: 条件运算符 （2）C++语言中只能对已有的C++运算符进行重载，不允许用户自己定义新的运算符。例如，虽然某些程序语言将“*”作为指数运算符，但是C++语言编程时不能重载“ “，因为” * “不是C++运算符。 （3）重载不能改变运算符的操作对象（即操作数）的个数。 （4）重载不能改变运算符原有的优先顺序。 （5）重载不能改变运算符原有的结合特性。 （7）运算符重载的参数至少应有一个是类对象（或类对象的引用）。也就是说，运算符重载函数的参数不能全部是C++标准型。（这项规定的目的是，防止用户修改用于标准类型数据的运算符性质） （8）运算符重载函数可以是普通函数，也可以是类的成员函数，还可以是类的友元函数。 （9）一般而言，用于类对象的运算符必须重载，但是赋值运算符“ = ”例外，不必用户进行重载。通常情况下，赋值运算符“ = ”可用于同类对象之间的相互赋值。 2. 友元运算符重载函数运算符重载是通过创建运算符重载函数来实现的，运算符重载函数定义了重载的运算符将要进行的操作。如果运算符重载函数是在类的外部定义的普通函数，这个运算符重载函数只能访问类中的公有数据成员，而不能访问类的私有成员。实际上，类中的数据成员常常是私有成员或保护成员，为此运算符重载函数一般采用如下两种形式定义：一是定义为它将要操作的类的成员函数（简称为成员运算符重载函数）；二是定义为类的友元函数（简称为友元运算符重载函数）。 2.1 定义友元运算符重载函数的语法形式（1）在类的内部，定义友元运算符重载函数的格式如下： friend 函数类型 operator运算符（形参表）{ ​ 函数体 } （2）友元运算符重载函数也可以在类中声明友元函数的原型，在类外定义。 在类中，声明友元运算符重载函数原型的格式如下： class X { … friend 函数类型 operator运算符（形参表）； … }; 在类外，定义友元运算符重载函数的格式如下： 函数类型 operator运算符（形参表）{ ​ 函数体 } 注意：由于友元运算符重载函数不是该类的成员函数，所以在类外定义时不需要缀上类名。 2.2 双目运算符重载双目运算符（或称二元运算符）有两个操作数，通常在运算符的左右两侧。当用友元函数重载双目运算符时，两个操作数都要传递给运算符重载函数。 一般而言，如果在类X中采用友元函数重载双目运算符@，而aa和bb是类X的两个对象，则以下两种函数调用方法是等价的： aa@bb; //隐式调用 operator@(aa,bb); //显示调用 说明： （1）有时，在函数返回的时候，可以直接用类的构造函数来生成一个临时对象，而不用对该对象进行命名。 12345678910Complex operator+(Complex&amp; a,Complex&amp; b)&#123; Complex temp; temp.real=a.real+b.real; temp.real=a.imag+b.imag; return temp;&#125;改为Complex operator+(Complex&amp; a,Complex&amp; b)&#123; return Complex(a.real+b.real,a.imag+b.imag); //此处建立了一个临时对象，它没有对象名&#125; 2.3 单目运算重载符单目运算符只有一个操作数，如-a、&amp;b、!c、++p等。重载单目运算符的方法与重载双目运算符的方法是类似的。用友元函数重载单目运算符时，需要一个显示的操作数。 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;class Coord&#123; public: Coord(int i=0,int j=0)&#123; x=i; y=j; &#125; void print()&#123; cout&lt;&lt;\"x:\"&lt;&lt;x&lt;&lt;\",y: \"&lt;&lt;endl; &#125; friend Coord operator++(Coord &amp;op)&#123; ++op.x; ++op.y; return op; &#125; private: int x,y;&#125;;int main()&#123; Coord ob(10,20); ob.print(); ++ob; ob.print(); operator++ (ob); ob.print(); return 0;&#125;程序运行结果：x:10, y:20x:11, y:21x:12, y:22 注意： 使用友元函数重载单目运算符“++”时，采用对象引用参数传递操作数，如果采用对象传递操作数，结果是不正确的。是因为形参是对象时，是通过传值的方法传递参数的，函数体内对形参op的所有修改都无法传到函数体外。 一般而言，如果在类X中采用友元函数重载单目运算符@，而aa是类X的对象，则以下两种函数调用方法是等价的： @aa； //隐式调用 operator@(aa); //显示调用 说明： （1）运算符重载函数operator@可以返回任何类型，甚至可以是void类型，但通常返回类型与它所操作的类的类型相同，这样可以使重载运算符用在复杂的表达式中。 （2）有的运算符不能定义为友元运算符重载函数，如赋值运算符“=”、下标运算符“[ ]”、函数调用运算符“()”等。 3. 成员运算符重载函数 在C++中，可以把运算符重载函数定义成某个类的成员函数，称为成员运算符重载函数。 3.1 定义成员运算符重载函数的语法形式（1）在类的内部，定义成员运算符重载函数的格式如下： 函数类型 operator 运算符（形参表）{ ​ 函数体 } （2）成员运算符重载函数也可以在类中声明成员函数的原型，在类外定义。 在类的内部，声明成员运算符重载函数原型的格式如下： class X { ​ //… ​ 函数类型 operator运算符（形参表）； ​ //… }; 在类外，定义成员函数运算符重载函数的格式如下： 函数类型 X::operator运算符（形参表）{ ​ 函数体 } 注意：由于成员运算符重载函数是该类的成员函数，所以在类外定义时需要缀上类名。 3.2 双目运算符重载 对双目运算符而言，成员运算符重载函数的形参表中仅有一个参数，它作为运算符的右操作数。另一个操作数（左操作数）是隐含的，是该类的当前对象，它是通过this指针隐含地传递给函数的。 一般而言，如果在类X中采用成员函数重载双目运算符@，成员运算符函数operator@所需的一个操作数由对象aa通过this指针隐含地传递，它的另一个操作数bb在参数表中显示，则以下两种函数调用方法是等价的： aa@bb; //隐式调用 aa.operator@(bb); //显示调用 3.3 单目运算符重载对单目运算符而言，成员运算符重载函数的参数表中没有参数，此时当前对象作为运算符的一个操作数。 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;class Coord&#123; public: Coord(int i=0,int j=0); void print(); Coord operator++(); private: int x,y;&#125;;Coord::Coord(int i,int j)&#123; x=i; y=j;&#125;void Coord::print()&#123; cout&lt;&lt;\"x: \"&lt;&lt; x &lt;&lt; ,y: \"&lt;&lt; y &lt;&lt; endl;&#125;Coord Coord::operator++()&#123; ++x; ++y; return *this;&#125;int mian()&#123; Coord ob(10,20); ob.print(); ++ob; //隐式调用运算符重载函数operator++ ob.print(); ob.operator++(); //显示调用运算符重载函数operator++ ob.print(); return 0;&#125; 由于this指针是指向当前对象的指针，因此语句“return *this；”返回的是当前对象的值，即调用运算符重载函数operator++的对象ob的值。 不难看出，对类Coord重载了运算符“++”后，对类对象的加1操作变得非常方便，就像对整型数进行加1操作一样。 4. 成员运算符重载函数与友元运算符重载函数的比较（1）对双目运算符而言，成员运算符重载函数参数表中含有一个参数，而友元运算符重载函数参数表中有两个参数；对单目运算符而言，成员运算符函数重载函数参数表中没有参数，而友元运算符重载函数参数表中有一个参数。 （2）双目运算符一般可以被重载为友元运算符重载函数或成员运算符重载函数，但有一种情况，必须使用友元函数。 1例如，如果将一个复数与一个整数相加，可用成员运算符函数重载“+”运算符 （3）成员运算符函数和友元运算符函数都可以用习惯方式调用，也可以用它们专用的方式调用。 习惯调用形式 友元运算符重载函数调用形式 成员运算符重载函数调用形式 a+b operator+(a,b) a.operator+(b) -a operator-(a) a.operator-( ) a++ operator++(a,0) a.operator++(0) （4）C++的大部分运算符既可以说明为成员运算符重载函数，又可以说明为友元运算符重载函数。究竟选择哪一种运算符函数好一些，没有定论，这主要取决于实际情况和程序员的习惯。 一般而言，对于双目运算符，将它重载为友元运算符重载函数比重载为成员运算符重载函数便于使用。对于单目运算符，则选择成员运算符函数较好。如果运算符所需的操作数（尤其是第一个操作数）希望有隐式类型转换，则运算符重载函数必须用友元函数，而不能用成员函数。 以下的经验可供参考： 对于单目运算符，建议选择成员函数； 对于运算符“=、( )、[ ]、-&gt;、”只能作为成员函数； 对于运算符“+=、-=、/=、*=、&amp;=、!=、~=、%=、&lt;&lt;=、&gt;&gt;=”，建议重载为成员函数； 对于其他运算符，建议重载为友元函数。","categories":[{"name":"C++","slug":"C","permalink":"https://codave.github.io/categories/C/"}],"tags":[{"name":"运算符重载","slug":"运算符重载","permalink":"https://codave.github.io/tags/运算符重载/"}]},{"title":"C++语法13-基类与派生类对象之间的赋值兼容关系","slug":"C++语法13-基类与派生类对象之间的赋值兼容关系","date":"2019-04-26T07:16:25.000Z","updated":"2019-04-26T09:00:08.242Z","comments":true,"path":"2019/04/26/C++语法13-基类与派生类对象之间的赋值兼容关系/","link":"","permalink":"https://codave.github.io/2019/04/26/C++语法13-基类与派生类对象之间的赋值兼容关系/","excerpt":"","text":"在一定条件下，不同类型的数据之间可以进行类型转换，例如可以将整型数据赋给双精度型变量。在赋值之前，先把整型数据转换成为双精度型数据，然后再把它赋给双精度变量。这种不同类型数据之间的自动转换和赋值，称为赋值兼容。在基类和派生类对象之间也存在赋值兼容关系，基类和派生类对象之间的赋值兼容规则是指在需要基类对象的任何地方，都可以使用公有派生类的对象来替代。 通过前面的学习我们知道，通过公有继承，派生类保留了基类中构造函数、析构函数之外的所有成员，基类的公有或保护成员的访问权限在派生类中全部按原样保留了下来，在派生类外可以调用基类的公有成员函数访问基类的私有成员。因此，公有派生类具有基类的全部功能，凡是基类能够实现的功能，公有派生类都能实现。我们可以将派生类对象的值赋给基类对象，在用到基类对象的时候可以用其子对象代替。 根据赋值兼容规则，在基类Base的对象可以使用的任何地方，都可以使用派生类Derived的对象来替代，但只能使用从基类继承来的成员。具体表现在以下几个方面： （1）派生类对象可以向基类对象赋值，即用派生类对象中从基类继承过来的数据成员，逐个赋值给基类对象的数据成员。 （2）派生类对象可以初始化基类对象的引用。 ​ Base b; //定义基类Base的对象b ​ Derived d; //定义基类Base的公有派生类Derived的对象b ​ Base &amp;br=d; //定义基类Base的对象的引用br，并用派生类Derived的对象d对其初始化 （3）派生类对象的地址可以赋给指向基类对象的指针。 ​ Derived d; ​ Base *bp = &d; （4）如果函数的形参是基类对象或基类对象的引用，在调用函数时可以用派生类对象作为实参。 1234567891011121314class Base&#123; public: int i; ...&#125;;class Derived:public Base&#123; ...&#125;;class fun(Base &amp;bb)&#123; cout&lt;&lt;bb.i&lt;&lt;endl;&#125;在调用函数fun时可以用派生类Derived的对象d4作为实参：fun(d4); 下面是一个使用赋值兼容规则的例子： 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;class Base&#123; public: int i; Base(int x)&#123; i=x; &#125; void show()&#123; cout&lt;&lt;\"Base\"&lt;&lt;i&lt;&lt;endl; &#125;&#125;;class Derived:public Base&#123; public: Derived(int x):Base(x)&#123;&#125;&#125;;void fun(Base &amp;bb)&#123; cout&lt;&lt;bb.i&lt;&lt;endl;&#125;;int main()&#123; Base b1(100); b1.show(); Derived d1(11); b1=d1; //用派生类对象d1给基类对象b1赋值 b1.show(); Derived d2(22); //用派生类对象d2来初始化基类对象的引用b2 Base &amp;b2=d2; b2.show(); Derived d3(33); Base *b3=&amp;d3; //把派生类对象的地址赋值给指向基类的指针b3 b3-&gt;show(); Derived d4(44); fun(d4); //派生类的对象d4作为函数fun的实参 return 0;&#125; 说明： （1）声明为指向基类对象的指针可以指向它的公有派生的对象，但不允许指向它的私有派生的对象。 123456789101112class Base&#123; ...&#125;;class Derived:private Base&#123; ...&#125;;int main()&#123; Base op1,*ptr; //定义基类Base的对象op1及指向基类Base的指针ptr Derive op2; //定义派生类Derived的对象op2 ptr=&amp;op1; //将指针ptr指向基类对象op1 ptr=&amp;op2; //错误，不允许将指向基类的Base的指针ptr指向它的私有派生类对象op2&#125; （2）允许将一个声明为指向基类的指针指向其公有派生类的对象，但是不能将一个声明为指向派生类对象的指针指向其基类的一个对象。 1234567891011class Base&#123; ...&#125;;class Derived:public Base&#123; ...&#125;;int main()&#123; Base obj1; //定义基类对象obj1 Derive obj2,*ptr; //定义派生类对象obj2及指向派生类的指针ptr ptr=&amp;obj2; //将指向派生类对象的指针ptr指向派生类对象ptr ptr=&amp;obj1; //错误，试图将指向派生类对象的指针ptr指向其基类对象obj1","categories":[{"name":"C++","slug":"C","permalink":"https://codave.github.io/categories/C/"}],"tags":[{"name":"-赋值兼容","slug":"赋值兼容","permalink":"https://codave.github.io/tags/赋值兼容/"}]},{"title":"C++语法12-多重继承","slug":"C++语法12-多重继承","date":"2019-04-25T08:41:09.000Z","updated":"2019-04-26T06:52:40.164Z","comments":true,"path":"2019/04/25/C++语法12-多重继承/","link":"","permalink":"https://codave.github.io/2019/04/25/C++语法12-多重继承/","excerpt":"","text":"派生类只有一个基类，这种派生方法称为单继承或单基派生。当一个派生类具有两个或多个基类时，这种派生方法称为多重继承或多基派生。 1. 多重继承派生类的声明在C++中，声明具有两个以上基类的派生类与声明单基派生类的形式相似，只需将要继承的多个基类用逗号分隔即可，其声明的一般形式如下： class 派生类名：继承方式1 基类名1，…… ，继承方式n 基类名n{ ​ 派生类新增的数据成员和成员函数 }； 注意：对基类成员的访问必须是无二义性的，例如下列程序段对基类成员的访问是二义性的，必须想办法消除二义性。 1234567891011121314clas X&#123; public: int f();&#125;;class Y&#123; public: int f(); int g();&#125;;class Z:public X,public Y&#123; public: int g(); int h();&#125;; 如果定义类Z的对象obj： Z obj; 则以下对函数f()的访问是二义性的： obj.f(); //二义性错误，不知调用的是类X的f(),还是类Y的f() 使用成员名限定可以消除二义性，例如： obj.X::f(); //调用类X的f() obj.Y::f(); //调用类Y的f() 2. 多重继承派生类的构造函数与析构函数多重继承下派生类构造函数的定义形式与单继承派生类构造函数的定义形式相似，只是n个基类的构造函数之间用逗号分隔。多重继承下派生类构造函数定义的一般形式如下： 派生类名（参数总表）：基类名1（参数表1），基类名2（参数表2），…… , 基类名n（参数名n）{ ​ 派生类新增成员的初始化语句 } 派生类的参数个数必须包含完成所有基类初始化所需的参数个数。 多重继承的构造函数的执行顺序与单继承构造函数的执行顺序相同，也是遵循先执行基类的构造函数，再执行对象成员的构造函数，最后执行派生类构造函数的原则。在多个基类之间，则严格按照派生类声明时从左向右的顺序来排列先后。 由于析构函数是不带参数的，在派生类中是否要定义析构函数与它所属的基类无关，所以与单继承情况类似，基类的析构函数不会因为派生类没有析构函数而得不到执行，他们各自是独立的。析构函数和构造函数的执行顺序正好是相反的。 3. 虚基类如果一个类有多个直接基类，而这些直接基类又有一个共同的基类，则在最低层的派生类中会保留这个间接的共同基类数据成员的多份同名成员。在访问这些同名的成员时，必须在派生类对象名后面增加直接基类名，使其惟一的标识一个成员，以免产生二义性。 3.1 虚基类的概念在C++中，如果想使这个公共的基类只产生一个复制，则可以将这个基类说明成虚基类。这就要求从类 Base派生新类时，使用关键字virtual将类Base说明成虚基类。 虚基类在派生类中的声明，其语法形式如下： Class 派生类名： virtual 继承方式 基类名{ …… } 经过这样的声明后，当基类通过多条派生路径被一个派生类继承时，该派生类只继承该基类一次，也就是说，基类成员只保留一次。 12345678910111213141516171819202122232425262728293031323334353637383940虚基类的使用#include&lt;iostream&gt;using namespace std;class Base&#123; public: &#123; a=5; cout&lt;&lt;\"Base a=\"&lt;&lt;a&lt;&lt;endl; //a=5 &#125; protected: int a;&#125;;class Base1:virtual public Base&#123; public: int b1; Base1()&#123; a=a+10; cout&lt;&lt;\"Base1 a=\"&lt;&lt;a&lt;&lt;endl; //a=15 &#125;&#125;;class Base2:virtual public Base&#123; public: int b2; Base2()&#123; a=a+20; cout&lt;&lt;\"Base2 a=\"&lt;&lt;a&lt;&lt;endl; //a=35 &#125;&#125;;class Derived:public Base1,public Base2&#123; public: int d; Derived()&#123; cout&lt;&lt;\"Derived a=\"&lt;&lt;a&lt;&lt;endl; //a=35 &#125;&#125;;int main()&#123; Derived obj; return 0;&#125; 3.2 虚基类的初始化虚基类的初始化与一般的多继承的初始化在语法上是一样的，但构造函数的调用顺序不同。在使用虚基类机制时应该注意一下几点： （1）如果在虚基类中定义有带形参的构造函数，并且没有定义默认形式的构造函数，则整个继承结构中，所有直接或间接的派生类都必须在构造函数的成员初始化列表中列出对虚函数类构造函数的调用，以初始化在虚基类中定义的数据成员。 （2）建立一个对象时，如果这个对象中含有从虚基类继承来的成员，则虚基类的成员是由最远派生类的构造函数通过调用虚基类的构造函数进行初始化的。该派生类的其他基类对虚基类构造函数的调用都自动被忽略。 （3）若同一层次中同时包含虚基类和非虚基类，应先调用虚基类中的构造函数，再调用非虚基类的构造函数，最后调用派生类构造函数。 （4）对于多个虚基类，构造函数的执行顺序仍然是先左后右，自上而下。 （5）对于非虚基类，构造函数的执行顺序仍然是先左后右，自上而下。 （6）若虚基类由非虚基类派生而来，则仍然先调用基类构造函数，再调用派生类的构造函数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152虚基类的派生类构造函数的执行顺序。#include&lt;iostream&gt;using namespace std;class Base&#123; public: Base(int sa)&#123; a=sa; cout&lt;&lt;\"Coustructing Base\"&lt;&lt;endl; &#125; private: int a;&#125;;class Base1:virtual public Base&#123; public: Base1(int sa,int sb):Base(sa)&#123; b=sb; cout&lt;&lt;\"Constructing Base1\"&lt;&lt;endl; &#125; private: int b;&#125;;class Base2:virtual public Base&#123; public: Base2(int sa,int sc)&#123; c=sc; cout&lt;&lt;\"Constructing Base2\"&lt;&lt;endl; &#125; private: int c;&#125;;class Derived:public Base1,public Base2&#123; public: Derived(int sa,int sb,int sc,int sd): Base(sa),Base1(sa,sb),Base2(sa,sc)&#123; d=sd; cout&lt;&lt;\"Constructing Derived\"&lt;&lt;endl; &#125; private: int d;&#125;;int main()&#123; Derived obj(2,4,6,8); return 0;&#125;程序运行结果：Coustructing BaseConstructing Base1Constructing Base2Constructing Derived 不难看出，上述程序中虚基类Base的构造函数只执行了一次。显然，当Derived的构造函数调用了虚基类Base的构造函数之后，类Base1和类Base2对Base构造函数的调用被忽略了。这也是初始化虚基类和初始化非虚基类不同的地方。 说明： （1）关键字virtual与派生方式关键字（public或private）的先后顺序无关紧要，它只说明是“虚拟派生”。 1234567class Derived:virtual public Base&#123; ......&#125;;class Derived:public virtual Base&#123; ......&#125;;这两个虚拟派生的声明是等价的。 （2）一个基类在作为某些派生类虚基类的同时，又作为另一些派生类的非虚基类，这种情况是允许的。","categories":[{"name":"C++","slug":"C","permalink":"https://codave.github.io/categories/C/"}],"tags":[{"name":"多重继承","slug":"多重继承","permalink":"https://codave.github.io/tags/多重继承/"}]},{"title":"C++语法11-调整基类成员在派生类中的访问属性的其他方法","slug":"C++语法11-调整基类成员在派生类中的访问属性的其他方法","date":"2019-04-24T13:27:03.000Z","updated":"2019-04-25T08:40:18.922Z","comments":true,"path":"2019/04/24/C++语法11-调整基类成员在派生类中的访问属性的其他方法/","link":"","permalink":"https://codave.github.io/2019/04/24/C++语法11-调整基类成员在派生类中的访问属性的其他方法/","excerpt":"","text":"1. 同名成员在定义派生类的时候，C++语言允许在派生类中说明的成员与基类中的成员名字相同，也就是说，派生类可以重新说明与基类成员同名的成员。如果在派生类中定义了与基类成员同名的成员，则称派生类成员覆盖了基类的同名成员，在派生类中使用这个名字意味着访问在派生类中重新说明的成员。为了在派生类中使用基类的同名成员，必须在该成员名之前加上基类名和作用域标示符”::”，即必须使用如下格式才能访问到基类的同名成员。 基类名::成员名 2. 访问声明我们已经知道，对于公有继承，基类的公有成员函数也就是派生类的公有成员函数，这意味着外界可以用派生类的对象调用基类的公有成员函数。但是对于私有继承，基类的公有成员函数变成了派生类的私有成员函数了。这是 外界就无法利用派生类的对象直接调用基类的成员函数，而只能通过调用派生类的成员函数（内含调用基类成员函数的语句）间接地调用基类的成员函数。 访问声明的方法就是把基类的保护成员或公有成员直接写至私有派生类定义式中的同名段中，同时给成员名前冠以基类名和作用域标示符 :: 。利用这种方法，该成员就成为派生类的保护类或公有成员了。 说明： （1）数据成员也可以使用访问声明。 （2）访问声明中只含不带类型和参数的函数或变量名。 （3）访问声明不能改变成员在基类中的访问属性，也就是说，访问声明只能把原基类的保护成员调整为私有派生类的保护成员，把原基类的公有成员调整为私有派生类的公有成员。但是对基类的私有成员不能使用访问声明。 （4）对于基类中的重载函数名，访问声明将对基类中所有同名函数起作用。这意味着对于重载函数使用访问声明时要慎重。","categories":[{"name":"C++","slug":"C","permalink":"https://codave.github.io/categories/C/"}],"tags":[{"name":"同名成员","slug":"同名成员","permalink":"https://codave.github.io/tags/同名成员/"},{"name":"访问声明","slug":"访问声明","permalink":"https://codave.github.io/tags/访问声明/"}]},{"title":"C++语法10-派生类的构造和析构","slug":"C++语法10-派生类的构造和析构","date":"2019-04-22T04:54:34.000Z","updated":"2019-04-24T13:18:10.680Z","comments":true,"path":"2019/04/22/C++语法10-派生类的构造和析构/","link":"","permalink":"https://codave.github.io/2019/04/22/C++语法10-派生类的构造和析构/","excerpt":"","text":"派生类继承了基类的成员，实现了原有代码的重用，这仅仅是引入继承的目的之一。引入继承的更主要的目的是代码的扩充，只有在派生类中通过添加新的成员，加入新的功能，类的派生才更有意义。但是基类的构造函数和析构函数不能被继承，在派生类中，如果对派生类新增的成员进行初始化，就需要加入派生类的构造函数。与此同时，对所有从基类继承下来的成员的初始化工作，还是由基类的构造函数完成的，但是我们必须在派生类中对基类的构造函数所需要的参数进行设置。同样，对撤销派生类对象时的扫尾、清理工作也需要加入新的析构函数来完成。 1. 派生类构造函数和析构函数的执行顺序通常情况下，当创建派生类的对象时，首先执行基类的构造函数，随后再执行派生类的构造函数；当撤销派生类对象时，则先执行派生类的析构函数，随后再执行基类的析构函数。 2. 派生类构造函数和析构函数的构造规则2.1 简单的派生类的构造函数当基类的构造函数没有参数，或没有显示定义构造函数时，派生类可以不向基类传递参数，甚至可以不定义构造函数。当基类含有带参数的构造函数时，派生类必须定义构造函数，以提供把参数传递给基类构造函数的途径。 在C++中，派生类构造函数的一般格式为： 1234派生类名（总参数表）：基类名（参数表）&#123; 派生类新增数据成员的初始化语句&#125; 下面的程序说明如何传递一个参数给派生类的构造函数和传递一个参数给基类的构造函数。 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class Student&#123; //声明基类Student public: Student(int number1,string name1,float score1)&#123; //基类构造函数 number=number1; name=name1; score=score1; &#125; void print()&#123; cout&lt;&lt;\"number:\"&lt;&lt;number&lt;&lt;endl; cout&lt;&lt;\"name:\"&lt;&lt;name&lt;&lt;endl; cout&lt;&lt;\"score:\"&lt;&lt;score&lt;&lt;endl; &#125; protected: int number; string name; float score;&#125;;class UStudent:public Student&#123; //声明公有派生类Ustudent public: UStudent(int number1,string name1,float score1,string major1) :Student(number1,name1,score1)//定义派生类构造函数要加上调用的基类的构造函数及其参数 &#123; major=major1; &#125; void print1()&#123; print(); count&lt;&lt;\"major:\"&lt;&lt;major&lt;&lt;endl; &#125; private： string major;&#125;int main()&#123; UStudent stu(22116,\"张志\"，95，\"信息安全\")； stu.print(); return 0;&#125; 说明： （1）可以将派生类构造函数定义在类的外部，而在类体内只写该函数的声明。 1UStudent(int number1,string name1,float score1,string major1); 而在类的外部定义派生类的构造函数： 12345UStudent::UStudent(int number1,string name1,float score1,string major1):Student(number1,name1,score1)//定义派生类构造函数要加上调用的基类的构造函数及其参数&#123; major=major1&#125; 注意：在类中声明派生类构造函数时，不包括基类构造函数名及其参数表(即Student(number1,name1,score1))，只在类外定义构造函数时才将它列出。 （2）若在类使用默认构造函数或不带参数的构造函数，则在派生类中定义构造函数时可略去”：基类名（参数表）”，此时若派生类不需要构造函数，则可不定义派生类构造函数。 （3）当基类构造函数不带参数时，派生类不一定需要定义构造函数，然后当基类的构造函数哪怕只带有一个参数，它所有的派生类都必须定义构造函数，甚至所定义的派生类构造函数的函数体可能为空，仅仅起参数的传递作用。 2.2 派生类的析构函数 在派生类中可以根据需要定义自己的析构函数，用来对派生类中的所增加的成员进行清理工作。基类的清理工作仍然由基类的析构函数负责。由于析构函数是不带参数的，在派生系统中是否要自定义析构函数与它所属基类的析构函数无关。在执行派生类的析构函数时，系统会自动调用基类的析构函数，对基类的对象进行清理工作。 2.3 含有对象成员（子对象）的派生类的构造函数当派生类中含有内嵌的对象成员（也称子对象）时，其构造函数的一般形式为： 派生类名（参数总表）：基类名（参数表0），对象成员名1（参数表1），……，对象成员名n（参数表n）{ ​ 派生类新增成员的初始化语句； } 在定义派生类对象时，构造函数的执行顺序如下： 调用基类的构造函数，对基类数据成员初始化； 调用内嵌对象成员的构造函数，对内嵌对象成员的数据成员初始化； 执行派生类的构造函数体，对派生类数据成员初始化。 撤销对象时，析构函数的调用顺序与构造函数的调用顺序正好相反。 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;using namespace std;class Base&#123; public: Base(int i)&#123; x=i; cout&lt;&lt;\"Constrcting base class\\n\"; &#125; ~Base()&#123; cout&lt;&lt;\"Destructing base class\\n\"; &#125; void show()&#123; cout&lt;&lt;\"x=\"&lt;&lt;x&lt;&lt;endl; &#125; private: int x;&#125;;class Derived:public Base&#123; public: Derived(int i):Base(i),d(i) //缀上要调用的基类构造函数和对象成员构造函数 &#123; cout&lt;&lt;\"Constructing derived class\\n\"; &#125; ~Derived()&#123; cout&lt;&lt;\"Destructing derived class\\n\"; &#125; private: Base d;&#125;;int main()&#123; Derived obj(5); obj.show(); return 0;&#125; 说明： （1）在派生类中含有多个内嵌对象成员时，调用内嵌对象成员的构造函数顺序由它们在类中声明的顺序确定。 （2）如果派生类的基类也是一个派生类，每个派生类只需要负责其直接基类数据成员的初始化。依次上溯。","categories":[{"name":"C++","slug":"C","permalink":"https://codave.github.io/categories/C/"}],"tags":[{"name":"构造函数","slug":"构造函数","permalink":"https://codave.github.io/tags/构造函数/"},{"name":"析构函数","slug":"析构函数","permalink":"https://codave.github.io/tags/析构函数/"},{"name":"派生类","slug":"派生类","permalink":"https://codave.github.io/tags/派生类/"}]},{"title":"C++语法09-派生类的概念","slug":"C++语法09-派生类的概念","date":"2019-04-21T13:24:59.000Z","updated":"2019-04-22T04:50:41.875Z","comments":true,"path":"2019/04/21/C++语法09-派生类的概念/","link":"","permalink":"https://codave.github.io/2019/04/21/C++语法09-派生类的概念/","excerpt":"","text":"1. 派生类的声明声明一个派生类的一般格式为： 123Class 派生类名：[继承方式] 基类名&#123; 派生类新增的数据成员和成员函数&#125;； 如果不显示地给出继承方式关键字，系统默认为私有继承（private)。 2. 基类成员在派生类中的访问属性派生类可以继承基类中除了构造函数与析构函数之外的成员，但是这些成员的访问属性在派生过程中是可以调整的。从基类继承来的成员在派生类中的访问属性是由继承方式控制的。 基类中的成员 在公有派生类中的访问属性 在私有派生类中的访问属性 在保护派生类中的访问属性 私有成员 不可直接访问 不可直接访问 不可直接访问 公有成员 公有 私有 保护 保护成员 保护 私有 保护 从上表中可以归纳出以下几点： （1）基类中的私有成员 ​ 无论哪种继承方式，基类中的私有成员不允许派生类继承，即在派生类中是不可直接访问的。 （2）基类中的公有成员 ​ 当类的继承方式为公有继承时，基类中的所有公有成员在派生类中仍以公有成员的身份出现。 ​ 当类的继承方式为私有继承时，基类中的所有公有成员在派生类中仍以私有成员的身份出现。 ​ 当类的继承方式为保护继承时，基类中的所有公有成员在派生类中仍以保护成员的身份出现。 （3）基类中的保护成员 ​ 当类的继承方式为公有继承时，基类中的所有保护成员在派生类中仍以保护成员的身份出现。 ​ 当类的继承方式为私有继承时，基类中的所有保护成员在派生类中仍以私有成员的身份出现。 ​ 当类的继承方式为保护继承时，基类中的所有保护成员在派生类中仍以保护成员的身份出现。 3. 派生类对基类成员的访问规则派生类对基类成员的访问形式主要有以下两种： （1）内部访问。由派生类中新增的成员函数对基类继承来的成员的访问 （2）对象访问。由派生类外部，通过派生类的对象对从基类继承来的成员的访问。 3.1 私有继承的访问规则 基类中的成员 私有成员 公有成员 保护成员 内部访问 不可访问 可访问 可访问 对象访问 不可访问 不可访问 不可访问 说明： （1）基类中的私有成员在被私有继承时既不能被派生类的对象访问，也不能被派生类的成员函数访问，只能被基类自己的成员函数访问。因此，我们在设计积累时，总要为它的私有数据成员提供公有成员函数，如成员函数showx等，以便使派生类可以间接访问这些数据成员。 （2）经历了私有继承之后，所有基类的成员都成为了派生类的私有成员或不可直接访问的成员，如果进一步派生的话，基类的全部成员都无法在新的派生类中被访问。 3.2 公有继承的访问规则 基类中的成员 私有成员 公有成员 保护成员 内部访问 不可访问 可访问 可访问 对象访问 不可访问 可访问 不可访问 3.3 保护继承的访问规则 基类中的成员 私有成员 公有成员 保护成员 内部访问 不可访问 可访问 可访问 对象访问 不可访问 不可访问 不可访问","categories":[{"name":"C++","slug":"C","permalink":"https://codave.github.io/categories/C/"}],"tags":[{"name":"派生","slug":"派生","permalink":"https://codave.github.io/tags/派生/"},{"name":"继承","slug":"继承","permalink":"https://codave.github.io/tags/继承/"}]},{"title":"C++语法08-常类型","slug":"C++语法08-常类型","date":"2019-04-21T12:02:24.000Z","updated":"2019-04-21T12:45:16.835Z","comments":true,"path":"2019/04/21/C++语法08-常类型/","link":"","permalink":"https://codave.github.io/2019/04/21/C++语法08-常类型/","excerpt":"","text":"程序中各种形式的数据共享，在不同程度上破坏了数据的安全性。常类型的引入，就是为了既保证数据共享又防止数据被改动。常类型是指使用类型修饰符const说明的类型，常类型的变量或对象成员的值在程序运行期间是不可改变的。 1. 常引用如果在说明引用时用const修饰，则被说明的引用为常引用。如果用常引用作形参，便不会产生对实参的不希望的更改。常引用的说明形式如下： const 类型 &amp;引用名； 在实际应用中，常引用往往用来作函数的形参，这样的参数称为常参数。 2. 常对象如果在说明对象时用const修饰，则被说明的对象为常对象。常对象的数据成员值在对象的整个生存期内不能被改变。常对象的说明该形式如下： 类名 const 对象名[(参数名)]；或者 const 类名 对象名[(参数表)]； 注意：在定义对象时必须进行初始化，而且不能被更新。 3. 常对象成员3.1 常数据成员类的数据成员可以是常量或者常引用，使用const说明的数据成员称为常数据成员。如果在一个类中说明了常数据成员，那么构造函数就只能通过成员初始化列表对该数据成员进行初始化，而其他任何函数都不能对该成员赋值。 3.2 常成员函数在类中使用关键字const说明的成员函数为常成员函数，常成员函数的说明格式如下： 类型说明符 函数名（参数表）const； const是函数类型的一个组成部分，因此在声明函数和定义函数时都要有关键字const。在调用时不必加const。 说明： （1）常成员函数可以访问常数据成员，也可以访问普通数据成员。常数据成员可以被常成员函数访问，也可以被普通成员函数访问。 数据成员 普通成员函数 常成员函数 普通数据成员 可以访问，也可以改变值 可以访问，但不可以改变值 常数据成员 可以访问，但不可以改变值 可以访问，但不可以改变值 常对象的数据成员 不允许访问和改变值 可以访问，但不可以改变值 （2）如果将一个对象说明为常对象，则通过该对象只能调用它的常成员函数，而不能调用普通的成员函数。常成员函数是常对象的唯一的对外接口，这是C++从语法机制上对常对象的保护。 （3）常成员函数不能更新对象的数据成员，也不能调用该类中的普通成员函数，这就保证了在常成员函数中绝对不会更新数据成员的值。","categories":[{"name":"C++","slug":"C","permalink":"https://codave.github.io/categories/C/"}],"tags":[{"name":"常引用","slug":"常引用","permalink":"https://codave.github.io/tags/常引用/"},{"name":"常函数","slug":"常函数","permalink":"https://codave.github.io/tags/常函数/"}]},{"title":"C++语法07-类的组合","slug":"C++语法07-类的组合","date":"2019-04-21T10:36:48.000Z","updated":"2019-04-21T12:01:10.578Z","comments":true,"path":"2019/04/21/C++语法07-类的组合/","link":"","permalink":"https://codave.github.io/2019/04/21/C++语法07-类的组合/","excerpt":"","text":"在类中定义的数据成员一般都是基本的数据类型或复合数据类型。但是还可以根据需要使用其他类的对象作为正在声明的类的数据成员。在一个类中内嵌另一个类的对象作为数据成员，称为类的组合。该内嵌对象称为对象成员，也成为子对象。 使用对象成员着重要注意的问题是如何完成对象成员的初始化工作。当创建类的对象时，如果这个类具有内嵌的对象成员，那么内嵌对象成员也将被自动创建。因此，在创建对象时既要对本类的基本数据成员初始化，又要对内嵌的对象成员进行初始化。含有对象成员的类，其构造函数和不含对象成员的构造函数有所不同。 123456Class X&#123; 类名1 对象成员1； 类名2 对象成员2； ... 类名n 对象成员n;&#125;; 一般来说，类X的构造函数的定义形式为： X::X（形参表0）：对象成员1（形参表1），对象成员2（形参表2），……{ ​ //类X的构造函数体 } 当调用构造函数X::X()时，首先按各内嵌对象成员在类声明中的顺序依次调用它们的构造函数，对这些对象初始化。最后再执行类X的构造函数体，初始化类X中的其他成员。析构函数的调用顺序与构造函数的调用顺序相反。 12345678910111213141516171819202122232425262728293031323334例：对象成员的初始化。#include&lt;iostream&gt;using namespace std;class A&#123;public: A(int x1,float y1)&#123; x=x1; y=y1; &#125; void show()&#123; cout&lt;&lt;\"\\n x=\"&lt;&lt; x &lt;&lt; \"y=\" &lt;&lt;y; &#125;private: int x; float y;&#125;;class B&#123;public: B(int x1,float y1, int z1):a(x1,y1)&#123; z=z1; &#125; void show()&#123; a.show(); cout&lt;&lt;\"z=\"&lt;&lt; z; &#125;private: A a; int z;&#125;;int main()&#123; B b(11,22,33); b.show(); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://codave.github.io/categories/C/"}],"tags":[{"name":"类的组合","slug":"类的组合","permalink":"https://codave.github.io/tags/类的组合/"}]},{"title":"C++语法06-静态成员","slug":"C++语法06-静态成员","date":"2019-04-21T05:50:01.000Z","updated":"2019-04-21T08:20:37.629Z","comments":true,"path":"2019/04/21/C++语法06-静态成员/","link":"","permalink":"https://codave.github.io/2019/04/21/C++语法06-静态成员/","excerpt":"","text":"1. 静态数据成员 为了实现同一个类的多个对象之间的数据共享，C++提出了静态数据成员的概念。在一个类中 ，若将一个数据成员说明成static，这种成员被称为静态数据成员。与一般的数据成员不同，无论建立多少个类的对象，都只有一个静态数据成员的拷贝。从而实现了同一个类中的不同对象之间的数据共享。 定义静态数据成员的格式如下： static 数据类型 数据成员名 说明： （1）静态数据成员的定义与普通数据成员相似，但前面要加上static关键字。 （2）静态数据成员的初始化与普通数据成员不同。静态数据成员初始化应在类外单独进行，而且应在定义对象之前进行。一般在主函数main之前，类声明之后的特殊地带为它提供定义和初始化。 12初始化的格式如下：数据类型 类名：：静态数据成员名=初始值； （3）静态数据成员属于类（准确地说，是属于类对象的集合），而不像普通数据成员那样属于某一对象，因此可以使用使用“类名：”访问静态的数据成员。 12用类名访问静态数据成员的格式如下：类名：静态数据成员名 （4）静态数据成员与静态变量一样，是在编译时创建并初始化。它在该类的任何对象被建立之前就存在。因此，公有的静态数据成员可以在对象定义之前被访问。对象定义后，公有的静态数据成员，也可以通过对象进行访问。 12对象名.静态数据成员名；对象指针-&gt;静态数据成员名； （5）私有静态数据成员不能在类外直接访问，必须通过公有的成员函数访问。 （6）C++支持静态数据成员的一个重要原因是可以不必使用全局变量。依赖于全局变量的类几乎都是违反面向对象程序设计的封装特性的。静态数据成员主要用作类的所有对象所共有的数据，如统计总数、平均数等。 2. 静态成员函数 在类定义中，前面有static说明的成员函数被称为静态成员函数。静态成员函数属于整个类，是该类所有对象共享的成员函数，而不是类中的某个对象。 1234567定义静态成员函数的格式如下：static 返回类型 静态成员函数名（参数表）;与静态数据成员类似，调用公有静态成员函数的一般格式有如下几种：(1) 类名::静态成员函数名（实参名）(2) 对象.静态成员函数名（实参名）(3) 对象指针-&gt;静态成员函数名（实参名） 例：静态成员函数访问静态数据成员。 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;using namespace std;class Small_cat&#123;public: Small_cat(double w); static void total_disp();private: double weight; static double total_weight; static double total_number;&#125;;Small_cat::Small_cat(double w)&#123; weight=w; total_weight+=w; total_number++;&#125;void Small_cat::display()&#123; cout&lt;&lt;\"这只小猫的重量是：\"&lt;&lt;weight&lt;&lt;\"千克\\n\";&#125;void Small_cat::total_disp()&#123; cout&lt;&lt;total_number&lt;&lt;\"只小猫的总重量是：\"； cout&lt;&lt;total_weight&lt;&lt;\"千克\"&lt;&lt;endl;&#125;double Small_cat::total_weight = 0;double Small_cat::total_number = 0;int main()&#123; Small_cat w1(0.5),w2(0.6),w3(0.4); w1.display(); w2.display(); w3.display(); Samll_cat::total_disp(); return 0;&#125; 下面对静态成员函数的使用再作几点说明： （1）一般情况下，静态函数成员主要用来访问静态数据成员。当它与静态数据成员一起使用时，达到了对同一个类中对象之间共享数据的目的。 （2）私有静态成员函数不能做类外部的函数和对象访问。 （3）使用静态成员函数的一个原因是，可以用它在建立任何对象之前调用静态成员函数，以处理静态数据成员，这是普通成员函数不能实现的功能。 123456int main()&#123; Small_cat::total_disp(); //可以用它在建立任何对象之前调用静态成员函数 Small_cat w1(0.5),w2(0.6),w3(0.4); ... return 0; &#125; （4）编译系统将静态成员函数限定为内部连接，也就是说，与现行文件相连接的其他文件中的同名函数不会与该函数发生冲突，维护了该函数使用的安全性，这是使用静态成员函数的另一个原因。 （5）静态成员函数是类的一部分，而不是对象的一部分。 （6）静态成员函数与非静态成员函数的重要的区别是：非静态成员函数有this指针，而静态成员函数没有this指针。静态成员函数可以直接访问本类中的静态数据成员，因为静态数据成员同样是属于类的，可以直接访问。一般而言，静态成员函数不访问类中的非静态成员。若确实需要访问非静态数据成员，静态成员函数只能通过对象名（或对象指针、对象引用）访问该对象的非静态成员。","categories":[{"name":"C++","slug":"C","permalink":"https://codave.github.io/categories/C/"}],"tags":[{"name":"静态成员","slug":"静态成员","permalink":"https://codave.github.io/tags/静态成员/"}]},{"title":"C++语法05-对象的赋值和复制","slug":"C++语法05-对象的赋值和复制","date":"2019-04-20T13:36:51.000Z","updated":"2019-04-21T08:21:10.024Z","comments":true,"path":"2019/04/20/C++语法05-对象的赋值和复制/","link":"","permalink":"https://codave.github.io/2019/04/20/C++语法05-对象的赋值和复制/","excerpt":"","text":"1. 对象赋值语句 这里所指的对象的赋值是指对其中的数据成员赋值，而不是对成员函数赋值。 例如：A和B是同一类的两个对象，那么下述对象赋值语句 B=A；就能把对象A的数据成员的值逐位复制给对象B。 说明： （1）在使用对象赋值语句进行对象赋值时，两个对象的类型必须相同，如对象的类型不相同，编译时将出错。 （2） 两个对象之间的赋值，仅仅使这些对象中数据成员相同，而两个对象仍是分离的。 （3）将一个对象的值赋给另一个对象时，多数情况下都是成功的，但当类中存在指针时，可能会产生错误。 2. 拷贝构造函数 拷贝构造函数是一种特殊的构造函数，其形参是本类对象的引用。拷贝构造函数的作用是，在建立一个新的对象时，使用一个已经存在的对象去初始化这个新对象。 例如： Point p2（p1); 其作用是，在建立新对象p2时，用已经存在的对象p1去初始化新对象p2，在这个过程中就要调用拷贝构造函数。 拷贝构造函数具有以下特点： （1）因为该函数也是一种构造函数，所以其函数名与类名相同，并且该函数也没有返回值类型。 （2）该函数只有一个参数，并且是同类对象的引用。 （3）每个类都必须有一个拷贝构造构造函数。程序员可以自定义拷贝构造函数，用于按照需要初始化新对象。如果程序员没有定义类的拷贝构造函数，系统就会自动生成产生一个默认拷贝构造函数，用于复制出数据成员值完全相同的新对象。 2.1 自定义拷贝构造函数自定义拷贝函数的一般形式如下： 类名：：类名（const 类名 &amp;对象名）{ ​ //拷贝构造函数的函数体 } 调用拷贝构造函数的一般形式为： （1）代入法： 类名 对象2（对象1）； （2）赋值法： 类名 对象2 = 对象1； 2.2 默认拷贝构造函数 每个类都必须有一个拷贝构造函数。如果程序员没有定义拷贝构造函数，系统就会自动生成一个默认拷贝构造函数，用于复制出完全相同的新对象。 在通常情况下，默认拷贝函数是能够胜任工作的，但如果类中有指针类型时，调用默认拷贝构造函数有时会产生错误，使用时要予以注意。 2.3 调用拷贝构造函数的3种情况 普通的构造函数是在对象创建时被调用，而拷贝构造函数在以下3种情况下都会被调用。 （1）当用类的一个对象去初始化该类的另一个对象时，拷贝构造函数将会被调用。 12Point p2(p1);Point p3=p1; （2）当函数的形参是类的对象，在调用函数进行形参和实参结合时，拷贝构造函数将会调用。 123456789void fun1(Point p)&#123; p.print();&#125;int main()&#123; Point p1(10,20); fun1(p1); return 0;&#125; （3）当函数的返回值是类的对象，在函数调用完毕将返回值（对象）带回函数调用处时。此时就会调用拷贝构造函数，将此对象复制给一个临时对象并传到该函数的调用处。 12345678910Point fun2()&#123; Point p1(10,30); return p1;&#125;int main()&#123; Point p2; p2=fun2(); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://codave.github.io/categories/C/"}],"tags":[{"name":"对象赋值","slug":"对象赋值","permalink":"https://codave.github.io/tags/对象赋值/"},{"name":"对象复制","slug":"对象复制","permalink":"https://codave.github.io/tags/对象复制/"}]},{"title":"C++语法04-向函数传递对象","slug":"C++语法04-向函数传递对象","date":"2019-04-20T12:31:32.000Z","updated":"2019-04-21T08:21:01.898Z","comments":true,"path":"2019/04/20/C++语法04-向函数传递对象/","link":"","permalink":"https://codave.github.io/2019/04/20/C++语法04-向函数传递对象/","excerpt":"","text":"1. 使用对象作为函数参数 对象可以作为参数传递给函数，其方法与传递基本类型的变量相同。在向函数传递对象时，是通过“传值调用”传递给函数的，即单向传递，只由实参传给形参，而不能由形参传回来给实参。因此函数中对对象的任何修改均不影响调用该函数的对象（实参）本身。 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;class Tr&#123; public: Tr(int n)&#123; i=n; &#125; void set_i(int n)&#123; i=n; &#125; int get_i()&#123; return i; &#125; private: int i;&#125;;void sqr_it(Tr ob)&#123; ob.set_i(ob.get_i()*ob.get_i()); cout&lt;&lt;\"在函数sqr_it内，形参对象ob的数据成员i的值为：\"&lt;&lt;ob.get_i(); //100 cout&lt;&lt;endl;&#125;int main()&#123; Tr obj(10); cout&lt;&lt;\"调用函数sqr_it前，实参对象obj的数据成员i的值为：\"; //10 cout&lt;&lt;obj.get_i()&lt;&lt;endl; sqr_it(obj); cout&lt;&lt;\"调用函数sqr_it后，实参对象obj的数据成员i的值为：\"; //10 cout&lt;&lt;obj.get_i(); return 0;&#125; 2. 使用对象指针作为函数参数 对象指针可以作为函数的参数，使用对象指针作为函数参数可以实现“传址调用”，即在函数调用时使实参对象和形参对象指针变量指向同一内存地址，在函数调用过程中，对形参对象指针值的改变也同样影响着实参对象的值。当函数的形参是对象指针时，调用函数的对应实参应该是某个对象的地址值。 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;class Tr&#123; public: Tr(int n)&#123; i=n; &#125; void set_i(int n)&#123; i=n; &#125; int get_i()&#123; return i; &#125; private: int i;&#125;;void sqr_it(Tr *ob)&#123; ob-&gt;set_i(ob-&gt;get_i()*ob-&gt;get_i()); cout&lt;&lt;\"在函数sqr_it内，形参对象ob的数据成员i的值为：\"&lt;&lt;ob-&gt;get_i(); //100 cout&lt;&lt;endl;&#125;int main()&#123; Tr obj(10); cout&lt;&lt;\"调用函数sqr_it前，实参对象obj的数据成员i的值为：\"; //10 cout&lt;&lt;obj.get_i()&lt;&lt;endl; sqr_it(&amp;obj); //传地址 cout&lt;&lt;\"调用函数sqr_it后，实参对象obj的数据成员i的值为：\"; //100 cout&lt;&lt;obj.get_i(); return 0;&#125; 3. 使用对象引用作为函数参数 在实际中，使用对象引用作为函数参数非常普遍，大部分程序员喜欢用对象引用取代对象指针作为函数参数。因为使用对象引用作为函数参数不但具有对象指针用作函数参数的优点，而且用对象引用作为函数参数将更简单、更直接。 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;using namespace std;class Tr&#123; public: Tr(int n)&#123; i=n; &#125; void set_i(int n)&#123; i=n; &#125; int get_i()&#123; return i; &#125; private: int i;&#125;;void sqr_it(Tr &amp;ob)&#123; ob.set_i(ob.get_i()*ob.get_i()); cout&lt;&lt;\"在函数sqr_it内，形参对象ob的数据成员i的值为：\"&lt;&lt;ob.get_i(); //100 cout&lt;&lt;endl;&#125;int main()&#123; Tr obj(10); cout&lt;&lt;\"调用函数sqr_it前，实参对象obj的数据成员i的值为：\"; //10 cout&lt;&lt;obj.get_i()&lt;&lt;endl; sqr_it(obj); cout&lt;&lt;\"调用函数sqr_it后，实参对象obj的数据成员i的值为：\"; //100 cout&lt;&lt;obj.get_i(); return 0;&#125;","categories":[{"name":"C++","slug":"C","permalink":"https://codave.github.io/categories/C/"}],"tags":[{"name":"函数传参","slug":"函数传参","permalink":"https://codave.github.io/tags/函数传参/"}]},{"title":"C++语法03-对象数组与对象指针","slug":"C++语法03-对象数组与对象指针","date":"2019-04-20T05:20:06.000Z","updated":"2019-04-21T08:20:51.181Z","comments":true,"path":"2019/04/20/C++语法03-对象数组与对象指针/","link":"","permalink":"https://codave.github.io/2019/04/20/C++语法03-对象数组与对象指针/","excerpt":"","text":"1. 对象数组 所谓对象数组是指每一个数组元素都是对象的数组，也就是说，若一个类有若干个对象，我们把这一系列的对象用一个数组来存放。对象数组的元素是对象，不仅具有数据成员，而且还有函数成员。 定义一个一维数组的格式如下： 类名 数组名[下标表达式] 例如有10个复数，每个复数的属性包括实部与虚部。如果为每一个复数建立一个对象，需要分别取10个对象名。显然用程序处理起来很不方便。这时可以定义一个复数类Complex的对象数组，每一个数组元素是Complex类的一个对象，例如： 1Complex com[10]; //定义类Complex的对象数组com,含有10个对象数组元素 在建立数组时，同样要调用构造函数。有几个数组元素就要调用几次构造函数。例如有10个数组元素 ，就要调用10次构造函数。类Complex的构造函数有两个参数，分别用于给实部数据和虚部数据赋值。如果构造函数只有1个参数，在定义对象数组时可以直接在等号后面的花括号内提供实参。 123456789101112131415161718192021//用只有1个参数的构造函数给对象数组赋值#include&lt;iostream&gt;using namespace std;class exam&#123; public: exam(int n)&#123; x=n; &#125; int get_x()&#123; return x; &#125; private: int x;&#125;;int main()&#123; exam ob1[4]=&#123;11, 22, 33,44&#125;; //用只有1个参数的构造函数给对象数组赋值 for(int i=0;i&lt;4;i++)&#123; cout&lt;&lt;ob1[i].get_x()&lt;&lt;''; &#125; return 0;&#125; 与基本数据类型的数组一样，在使用对象数组时也只能访问单个数组元素，其一般形式是： ​ 数组名 [下标].成员名 以上例子中构造函数只有一个参数，如果构造函数有多个参数，在定义对象数组时应当怎样实现初始化？我们只要在花括号中分别写出构造函数并指定实参即可。例如： 12345Complex com[3]=&#123; //定义对象数组com Complex(1.1, 2.2); Complex(3.3, 4.4); Complex(5.5, 6.6)&#125;; 由于这个对象数组有3个对象数组元素，因此在建立对象数组时，3次调用构造函数，对每一个对象数组元素初始化。当1个数组中的数组元素被删除时，系统会调用析构函数来完成扫尾工作，有几个对象数组元素就会调用几次析构函数。 2. 对象指针 每一个对象在初始化后都会在内存占有一定的空间。因此，既可以通过对象名访问一个对象，也可以通过对象地址来访问一个对象。对象指针就是用于存放对象地址的变量。 声明对象指针的一般语法形式为： ​ 类名 *对象指针名 （1）用指针访问单个对象成员： ​ 说明对象指针的语法和说明其他数据类型指针的语法相同。使用对象指针时，首先要把它指向一个已创建的对象，然后才能引用该对象的成员。 ​ 在一般情况下，用点运算符“.”来访问对象成员，当用指向对象的指针来访问对象成员时，就要用“-&gt;”操作符。 （2）用对象指针访问对象数组 ​ 对象指针不仅能引用单个对象，也能访问对象数组。 123456789101112int main()&#123; exe ob[2]; //定义类exe的对象数组ob[2] exe *p; //定义指向类exe的对象指针变量p ob[0].set_a(10); // ob[0].set_b(20); p=ob; p-&gt;show_a(); p++; //一般而言，当指针加1或减1时，它总是指向其基本类型中相邻的一个元素，对象指针也是如此 p-&gt;show_a(); return 0;&#125; 3. this指针// TODO","categories":[{"name":"C++","slug":"C","permalink":"https://codave.github.io/categories/C/"}],"tags":[{"name":"对象数组","slug":"对象数组","permalink":"https://codave.github.io/tags/对象数组/"},{"name":"对象指针","slug":"对象指针","permalink":"https://codave.github.io/tags/对象指针/"}]},{"title":"C++语法02-构造函数和析构函数","slug":"C++语法02-构造函数和析构函数","date":"2019-04-19T12:58:37.000Z","updated":"2019-04-20T05:19:06.852Z","comments":true,"path":"2019/04/19/C++语法02-构造函数和析构函数/","link":"","permalink":"https://codave.github.io/2019/04/19/C++语法02-构造函数和析构函数/","excerpt":"","text":"1. 对象的初始化和构造函数 类是一种抽象的数据类型，它不占存储空间，不能容纳具体的数据。因此在类声明中不能给数据成员赋初值。与使用变量一样，使用对象时也应该先定义，后使用。在定义对象时，对数据成员赋初值，称为对象的初始化。在定义对象时，如果某一数据成员没有被赋值，则它的值是不可预知的。对象是一个实体，在使用对象时，它的每一个数据成员都应该有确定的值。 如果一个类中的所有成员，都是共有的，则可以在定义对象时对数据成员进行初始化。例如： 123456class Complex&#123; public: double real; double imag;&#125;;Complex c1=&#123;1.1,2.2&#125;; 说明：这种方法类似于结构体变量初始化的方法。但是，如果类中包含私有的或保护的成员时，就不能用这种方法进行初始化。除了调用公有成员函数来给数据成员赋值，C++提供了一个更好的方法，利用构造函数来完成对象的初始化。 构造函数是一种特殊的成员函数，它主要用于为对象分配对象，进行初始化。构造函数的名字必须和类名相同，而不能由用户任意命名。它可以有任意类型的参数，但不能具有返回值类型。它不需要用户来调用，而是在建立对象时自动执行的。 在建立对象的同时，采用构造函数给成员赋初值，通常有以下两种形式。 形式1： 类名 对象名[(实参表)] 形式2： 类名 *指针变量名=new 类名[(实参表)] 说明：这时编译系统开辟了一段内存空间，并在此空间中存放了一个Complex类对象，同时调用了该类的构造函数给数据成员赋初值。这个对象没有名字，称为无名对象。但是该对象有地址，这个地址存放在指针变量pa中。访问用new动态建立的对象一般是不用对象的，而是通过指针访问。 注意： （1）当new建立的对象使用结束时，不再需要它时，可以用delete运算符予以释放delete pa。 （2）与普通成员函数一样，构造函数的函数体可写在类体内（系统将构造函数作为内联函数处理），也可以写在类体外。 （3）构造函数一般声明为公有函数，它是在定义对象的同时被自动调用的，而且只执行一次。 （4）如果没有给类定义构造函数，则编译系统自动地生成一个默认构造函数。（这个默认的构造函数不带任何参数，函数体是空的，它只能为对象开辟数据成员存储空间，而不能给对象中的数据成员赋值） （5）构造函数可以不带参数，例如： 123456Complex()&#123; //不带参数的构造函数 real=0; imag=0;&#125;Complex A; //定义类Complex的对象A时调用不要带参数，也不要要带括号！！！ 2. 用成员初始化列表对数据成员初始化 C++还提供另一种初始化数据成员的方法——用成员初始化列表对数据成员初始化。这种方法不在函数体内用赋值语句对数据成员初始化，而是在函数首部实现的。 带有成员初始化列表的构造函数的一般形式如下： 类名：：构造函数名（[参数表])[:(成员初始化列表)]{ ​ //构造函数体 } 成员初始化列表的一般形式为： 数据成员名1（初始值1），数据成员名2（初始值2），….. 注意: （1）对于用const修饰的数据成员，或是引用类型的数据成员，是不允许用赋值语句直接赋值的。因此，只能用成员初始化列表对其进行初始化。 （2）数据成员是按照它们在类中声明的顺序进行初始化的，与它们在成员初始化列表中列出的顺序无关。 3. 构造函数的重载 与一般的成员函数一样，C++允许构造函数重载，以适应不同的场合。 注意： （1）使用无参构造函数创建对象时，应该用语句“Date date1；”，而不能用语句“Date date1()；”。因为语句“Date date1()；”表示声明一个名为date1的普通函数，此函数的返回值为Date类型。 （2）如果在类中用户没有定义构造函数，系统会自动提供一个函数体为空的默认构造函数。但是，只要类中定义了一个构造函数（不一定是无参构造函数），系统将不再给它提供默认构造函数。 4. 带默认参数的构造函数 对于带参数的构造函数，在定义对象时必须给构造函数的形参传递参数的值，否则构造函数将不被执行。但在实际使用中，有些构造函数的参数值在大部分情况是相同的，只有在特殊情况下才需要改变它的参数值。 说明： （1）如果构造函数在类的声明外定义，那么默认参数在类内声明构造函数原型时指定，而不能在类外构造函数定义时指定。因为类的声明是放在头文件中的，用户可以看到，而构造函数的定义是类的实现细节，用户往往看不到。因此，在声明时指定默认参数，可以保证用户在建立对象时知道怎么使用默认参数。 （2）如果构造函数的全部参数都指定了默认值，则在定义对象时可以指定1个或几个实参，也可以不给出实参，这时的构造函数也属于默认构造函数。因为一个类只能有一个默认构造函数，因此不能同时再声明无参数的默认构造函数。否则，编译系统将无法识别应该调用哪个构造函数，因此产生了二义性。 （3）在一个类中定义了全部是默认参数的构造函数后，不能再定义重载构造函数。 123456例如在一个类中有以下构造函数的声明Complex(double r=0.0, double i=0.0);Complex(double r);如果用以下语句定义对象Complex S2（1.1）； //无法判断应该调用以上哪个构造函数 因此，一般不要同时使用构造函数的重载和有默认参数的构造函数。 5. 析构函数 析构函数也是一种特殊的成员函数。它执行与构造函数相反的操作，通常用于执行一些清理任务，如释放分配给对象的内存空间等。析构函数有如下一些特点： （1）析构函数名与类名相同，但它前面必须加一个波浪号（~）。 （2）析构函数不返回任何值。在定义析构函数时，是不能说明它的类型的，甚至说明为void也不行。 （3）析构函数没有参数，因此它不能被重载。一个类可以有多个构造函数，但只能有一个析构函数。 （4）撤销对象时，编译系统会自动地调用析构函数。 说明： （1）每个类必须有一个析构函数。若没有显示地为一个类定义析构函数，则编译系统会自动地生成一个默认析构函数。**对于大多数而言，这个默认析构函数就能满足要求。但是，如果在一个对象撤销之前需要完成另外一些处理工作的话，则应该显示地定义析构函数。例如： 1234567891011121314class String_data&#123; public: String_data(char *s)&#123; str=new char[strlen(s)+1]; strcpy(str, s); &#125; ~String_data()&#123; delete str; &#125; void get_info(char*); void sent_info(char*); private: char *str;&#125; 这是构造函数和析构函数最常见的用法，即在构造函数中用运算符new为字符串分配存储空间，最后在析构函数中用运算符delete释放已分配的存储空间。 （2）除了在主函数结束（或调用exit函数）时，对象被撤销，系统会自动调用析构函数外，在以下情况，析构函数也会被调用： 如果一个对象被定义在一个函数体内，则当这个函数被调用结束时，该对象将释放，析构函数被自动调用。 若一个对象时使用new运算符动态创建的，在使用delete运算符释放它时，delete会自动调用析构函数。","categories":[{"name":"C++","slug":"C","permalink":"https://codave.github.io/categories/C/"}],"tags":[{"name":"构造函数","slug":"构造函数","permalink":"https://codave.github.io/tags/构造函数/"},{"name":"析构函数","slug":"析构函数","permalink":"https://codave.github.io/tags/析构函数/"}]},{"title":"C++语法01-类和对象的基本概念","slug":"C++语法01-类和对象的基本概念","date":"2019-04-07T12:52:37.000Z","updated":"2019-04-21T09:05:03.634Z","comments":true,"path":"2019/04/07/C++语法01-类和对象的基本概念/","link":"","permalink":"https://codave.github.io/2019/04/07/C++语法01-类和对象的基本概念/","excerpt":"","text":"1. 结构体的扩充 结构体是C语言的一种自定义的数据类型，在结构体中可以含有多种不同类型的数据。C++语言对结构体类型进行了扩充，它不仅可以含有不同类型的数据，而且还可以含有函数。 例如下面声明了一个扩充的结构体Complex: 12345678910111213struct Complex&#123; //声明了一个名为Complex的结构体 double real; //复试的实部 double imag; //复试的虚部 void init(double r,double i)&#123; real=r; imag=i; &#125; double abscomplex()&#123; double t; t=real*real+imag*imag; return sqrt(t); &#125;&#125;; 结构体中的数据和成员都是结构体的成员，在C++中，通常把结构体中的数据成为数据成员，把函数称为成员函数。为了访问这些成员函数，必须先定义该结构体类型的变量，然后像访问结构体中的数据一样进行访问。 C++提供了一种比结构体更安全有效的数据类型-类。类与结构体的扩充形式十分相似。上面的结构体类型Complex可以用类改写如下： 12345678910111213class Complex&#123; //声明了一个名为Complex的类 double real; //数据成员，复试的实部 double imag; //数据成员，复试的虚部 void init(double r,double i)&#123; //成员函数 real=r; imag=i; &#125; double abscomplex()&#123; //成员函数 double t; t=real*real+imag*imag; return sqrt(t); &#125;&#125;; 类是一种数据类型，它是一种用户定义的抽象的函数类型。C++规定，在默认情况下，类中的成员是私有的，结构体中成员是共有的。 2. 类的声明可以得出，类类型声明的一般形式如下： 123456class 类名&#123; [private:] 私有数据成员和成员函数 [public:] 公有数据成员和成员函数&#125;； 说明： (1)私有成员(用private声明)包括数据成员和成员函数只能被类内的成员函数访问，公有成员(用public声明)包括数据成员和成员函数既可被类内的成员函数访问，也可被类外的对象访问。 (2)除了private和public之外，类中的成员还可以用另一个关键字protected来说明。被protected说明的数据成员和成员函数称为保护成员。保护成员可以由本类的成员函数访问，也可以由本类的派生类的成员函数访问。 (3)数据成员可以是任何数据成员，但不能是用自动(auto)、寄存器(register)或外部(extern)进行说明。 3. 成员函数的定义 类的成员函数是函数的一种，它也有函数名、返回值类型和参数表，用法和普通函数差不多，只是它属于一个类的成员。成员函数可以访问本类中任何成员（包括private、protected、public）。 成员函数的三种定义方式 第一种：在类声明中只给出成员函数的原型，而将成员函数的定义放在类的外部。(类内声明，类外定义) 这种成员函数在类外定义的一般形式如下： 12345返回值类型 类名：：成员函数名（参数表）&#123; 函数体 &#125; 说明：在类声明中，成员函数的原型的参数表中可以不说明参数的名字，而只说明它们的类型。但是，在类外定义成员函数时，不但要说明参数表中的参数的类型，还必须要指出其参数名。 第二种：将成员函数直接定义在类的内部。 说明：编译器会将这些函数隐含地定义为内联成员函数。这种定义内联成员内联函数的方法没有使用关键字inline进行声明，因此称为隐式定义。 第三种：在类内函数原型声明前或在类外定义成员函数前冠以关键字inline，因此称为显示定义。 说明：可以在声明函数原型和定义函数时同时写inline，也可以在其中一处声明inline，效果是相同的。都能按内联函数处理 。使用inline定义内联函数时，必须将类的声明和内联成员函数的定义都放在同一个文件（或同一个头文件中），否则编译时无法进行代码置换。 4. 对象的定义及使用4.1 对象的定义可以用以下两种方法定义对象： （1）在声明类的同时，直接定义对象。即直接在声明类的右花括号“}”后，直接写出属于该类的对象名表。例如： 12345678class Point&#123; public: void setpoint(int,int); int getx(); int gety(); private: int x,y;&#125;op1,op2; 在声明类Point的同时，直接定义了对象op1,op2。 （2）声明了类之后，在使用时再定义对象。其一般形式如下：类名 对象名1，对象名2，..... ; 例如Point op1,op2; 4.2 对象中成员的访问 不论是数据成员，还是函数成员，只要是公有的，在类的外部可以通过类的对象进行访问。访问对象中的成员通常有一下三种方法。 （1）通过对象名和对象选择符访问对象中的成员 ​ 其一般形式是： 对象名.数据成员名 或者 对象名.成员函数名[(实参表)] ​ 说明：.叫做对象选择符，简称点运算符 （2）通过指向对象的指针访问对象中的成员 ​ 在定义对象时，若我们定义的是指向此对象的指针，则访问此对象的成员时，不能用.操作符，而应该使用-&gt;操作符。例如： 12345678class Date&#123; public: int year;&#125;;...Date d,*ptr;ptr=&amp;d;cout&lt;&lt;ptr-&gt;year; 在此，ptr-&gt;year表示ptr当前指向对象中d中的成员year，因为（*ptr)就是对象d，(*ptr).year表示的也就是对象d中的成员year。所以有如下等价关系： （3）通过对象的引用访问对象中的成员 ​ 如果为了一个对象定义了一个引用，也就是为这个对象起了一个别名、因此完全可以通过引用来访问对象中的成员，其方法与通过对象名来访问对象中的成员是相同的。例如： 123456789class Date&#123; public: int year;&#125;;...Date d1;Date &amp;d2=d1;cout&lt;&lt;d1.year;cout&lt;&lt;d2.year; 由于d2是d1的引用（即d2和d1占有相同的存储单），因此d2.year和d1.year是相同的。","categories":[{"name":"C++","slug":"C","permalink":"https://codave.github.io/categories/C/"}],"tags":[{"name":"类和对象","slug":"类和对象","permalink":"https://codave.github.io/tags/类和对象/"}]},{"title":"Linux基础07-其他命令","slug":"Linux基础07-其他命令","date":"2019-03-24T05:03:16.000Z","updated":"2019-04-21T09:09:26.911Z","comments":true,"path":"2019/03/24/Linux基础07-其他命令/","link":"","permalink":"https://codave.github.io/2019/03/24/Linux基础07-其他命令/","excerpt":"","text":"1. 查找文件 find 命令功能非常强大，通常用来在 特定的目录下 搜索 符合条件的文件 序号 命令 作用 01 find [路径] -name “*.py” 查找指定路径下扩展名是 .py 的文件，包括子目录 如果省略路径，表示在当前文件夹下查找 之前学习的通配符，在使用 find 命令时同时可用 有关 find 的高级使用，见高级语法 演练目标 搜索桌面目录下，文件名包含 1 的文件 1find -name \"*1*\" 搜索桌面目录下，所有以 .txt 为扩展名的文件 1find -name \"*.txt\" 搜索桌面目录下，以数字 1 开头的文件 1find -name \"1*\" 2. 软链接 序号 命令 作用 01 ln -s 被链接的源文件 链接文件 建立文件的软链接，用通俗的方式讲类似于 Windows 下的快捷方式 注意： 没有-s选项建立的是一个硬链接文件,两个文件占用相同大小的硬盘空间，工作中几乎不会建立文件的硬链接 源文件要使用绝对路径，不能使用相对路径，这样可以方便移动链接文件后，仍然能够正常使用 演练目标 将桌面目录下的 01.py 移动到 demo/b/c 目录下 在桌面目录下新建01.py的软链接FirstPython 分别使用 相对路径 和 绝对路径 建立 FirstPython 的软链接 将 FirstPython 移动到 demo 目录下，对比使用 相对路径 和 绝对路径 的区别 硬链接简介 在使用 ln 创建链接时，如果没有 -s 选项，会创建一个 硬链接，而不是软链接 硬链接演练 在 ~/Desktop/demo 目录下建立 ~/Desktop/demo/b/c/01.py 的硬链接 01_hard 使用 ls -l 查看文件的硬链接数（硬链接——有多少种方式可以访问文件或者目录） 删除 ~/Desktop/demo/b/c/01.py，并且使用 tree 来确认 demo 目录下的三个链接文件 在 Linux 中，文件名 和 文件的数据 是分开存储的 提示： 在 Linux 中，只有文件的 硬链接数 == 0 才会被删除 使用 ls -l 可以查看一个文件的硬链接的数量 在日常工作中，几乎不会建立文件的硬链接，知道即可 3. 打包压缩 打包压缩 是日常工作中备份文件的一种方式 在不同操作系统中，常用的打包压缩方式是不同的 Windows 常用 rar Mac 常用 zip Linux 常用 tar.gz 3.1 打包 ／ 解包 tar 是 Linux 中最常用的 备份工具，此命令可以 把一系列文件 打包到 一个大文件中，也可以把一个 打包的大文件恢复成一系列文件 tar 的命令格式如下： 12345# 打包文件tar -cvf 打包文件.tar 被打包的文件／路径...# 解包文件tar -xvf 打包文件.tar tar 选项说明 选项 含义 c 生成档案文件，创建打包文件 x 解开档案文件 v 列出归档解档的详细过程，显示进度 f 指定档案文件名称，f 后面一定是 .tar 文件，所以必须放选项最后 注意：f 选项必须放在最后，其他选项顺序可以随意 打包解包演练 删除桌面下的所有内容 在桌面下新建三个空白文件 01.py、02.py、03.py 将这三个文件打一个 py.tar 的包 新建 tar 目录，并且将 py.tar 移动到 tar 目录下 解包 py.tar 3.2 压缩／解压缩1) gzip tar与gzip命令结合可以使用实现文件打包和压缩 tar 只负责打包文件，但不压缩 用 gzip 压缩 tar 打包后的文件，其扩展名一般用 xxx.tar.gz 在 Linux 中，最常见的压缩文件格式就是 xxx.tar.gz 在 tar 命令中有一个选项 -z 可以调用 gzip，从而可以方便的实现压缩和解压缩的功能 命令格式如下： 12345678# 压缩文件tar -zcvf 打包文件.tar.gz 被压缩的文件／路径...# 解压缩文件tar -zxvf 打包文件.tar.gz# 解压缩到指定路径tar -zxvf 打包文件.tar.gz -C 目标路径 选项 含义 -C 解压缩到指定目录，注意：要解压缩的目录必须存在 2) bzip2 tar 与 bzip2 命令结合可以使用实现文件 打包和压缩（用法和 gzip 一样） tar 只负责打包文件，但不压缩， 用 bzip2 压缩 tar 打包后的文件，其扩展名一般用 xxx.tar.bz2 在 tar 命令中有一个选项 -j 可以调用 bzip2，从而可以方便的实现压缩和解压缩的功能 命令格式如下： 12345# 压缩文件tar -jcvf 打包文件.tar.bz2 被压缩的文件／路径...# 解压缩文件tar -jxvf 打包文件.tar.bz2 4. 软件安装4.1 通过 apt 安装／卸载软件 apt 是 Advanced Packaging Tool，是 Linux 下的一款安装包管理工具 可以在终端中方便的 安装／卸载／更新软件包 12345678# 1. 安装软件$ sudo apt install 软件包# 2. 卸载软件$ sudo apt remove 软件名# 3. 更新已安装的包$ sudo apt upgrade 安装演练12345# 一个小火车提示$ sudo apt install sl# 一个比较漂亮的查看当前进程排名的软件$ sudo apt install htop 4.2 配置软件源在Ubantu18.04版本在系统设置里面是找不到软件源设置界面按钮的，可用如下指令帮助启动图形界面以便设置软件源。 1sudo update-manager -c -d 如果希望在 ubuntu 中安装软件，更加快速，可以通过设置镜像源，选择一个访问网速更快的服务器，来提供软件下载／安装服务 提示：更换服务器之后，需要一个相对比较长时间的更新过程，需要耐心等待。更新完成后，再安装软件都会从新设置的服务器下载软件了 所谓镜像源，就是所有服务器的内容是相同的（镜像），但是根据所在位置不同，国内服务器通常速度会更快一些！","categories":[{"name":"Linux","slug":"Linux","permalink":"https://codave.github.io/categories/Linux/"}],"tags":[{"name":"Linux基础","slug":"Linux基础","permalink":"https://codave.github.io/tags/Linux基础/"}]},{"title":"Linux基础06-系统信息相关命令","slug":"Linux基础06-系统信息相关命令","date":"2019-03-24T05:02:08.000Z","updated":"2019-03-24T05:32:16.651Z","comments":true,"path":"2019/03/24/Linux基础06-系统信息相关命令/","link":"","permalink":"https://codave.github.io/2019/03/24/Linux基础06-系统信息相关命令/","excerpt":"","text":"1. 时间和日期 序号 命令 作用 01 date 查看系统时间 02 cal calendar 查看日历，-y 选项可以查看一年的日历 2. 磁盘信息 序号 命令 作用 01 df -h disk free 显示磁盘剩余空间 02 du -h [目录名] disk usage 显示目录下的文件大小 选项说明 参数 含义 -h 以人性化的方式显示文件大小 3. 进程信息 所谓 进程，通俗地说就是 当前正在执行的一个程序 序号 命令 作用 01 ps aux process status 查看进程的详细状况 02 top 动态显示运行中的进程并且排序 03 kill [-9] 进程代号 终止指定代号的进程，-9 表示强行终止 ps 默认只会显示当前用户通过终端启动的应用程序 ps 选项说明功能 选项 含义 a 显示终端上的所有进程，包括其他用户的进程 u 显示进程的详细状态 x 显示没有控制终端的进程 提示：使用 kill 命令时，最好只终止由当前用户开启的进程，而不要终止 root 身份开启的进程，否则可能导致系统崩溃 要退出 top 可以直接输入 q","categories":[{"name":"Linux","slug":"Linux","permalink":"https://codave.github.io/categories/Linux/"}],"tags":[{"name":"Linux基础","slug":"Linux基础","permalink":"https://codave.github.io/tags/Linux基础/"}]},{"title":"Linux基础05-用户权限相关命令","slug":"Linux基础05-用户权限相关命令","date":"2019-03-24T05:00:11.000Z","updated":"2019-03-24T07:06:01.559Z","comments":true,"path":"2019/03/24/Linux基础05-用户权限相关命令/","link":"","permalink":"https://codave.github.io/2019/03/24/Linux基础05-用户权限相关命令/","excerpt":"","text":"1. 用户 和 权限 的基本概念1.1 基本概念 用户 是 Linux 系统工作中重要的一环，用户管理包括 用户 与 组 管理 在 Linux 系统中，不论是由本机或是远程登录系统，每个系统都必须拥有一个账号，并且对于不同的系统资源拥有不同的使用权限 在 Linux 中，可以指定 每一个用户 针对 不同的文件或者目录 的 不同权限 对 文件／目录 的权限包括： 序号 权限 英文 缩写 数字代号 01 读 read r 4 02 写 write w 2 03 执行 excute x 1 1.2 组 为了方便用户管理，提出了 组 的概念 在实际应用中，可以预先针对 组 设置好权限，然后 将不同的用户添加到对应的组中，从而不用依次为每一个用户设置权限 1.3 ls -l 扩展 ls -l 可以查看文件夹下文件的详细信息，从左到右依次是： 权限，第 1 个字符如果是 d 表示目录 硬链接数，通俗地讲，就是有多少种方式，可以访问到当前目录／文件 拥有者，家目录下 文件／目录 的拥有者通常都是当前用户 组，在 Linux 中，很多时候，会出现组名和用户名相同的情况，后续会讲 大小 时间 名称 ￼ 1.4 chmod 简单使用 chmod 可以修改 用户／组 对 文件／目录 的权限 命令格式如下： 1chmod +/-rwx 文件名|目录名 提示：以上方式会一次性修改 拥有者 / 组 权限，有关 chmod 的高级用法，后续会讲 1.5 超级用户 Linux 系统中的 root 账号通常 用于系统的维护和管理，对操作系统的所有资源 具有所有访问权限 在大多数版本的 Linux 中，都不推荐 直接使用 root 账号登录系统 在 Linux 安装的过程中，系统会自动创建一个用户账号，而这个默认的用户就称为“标准用户” sudo su 是 substitute user 的缩写，表示 使用另一个用户的身份 sudo 命令用来以其他身份来执行命令，预设的身份为 root 用户使用 sudo 时，必须先输入密码，之后有 5 分钟的有效期限，超过期限则必须重新输入密码 若其未经授权的用户企图使用 sudo，则会发出警告邮件给管理员 2. 组管理 终端命令 提示：创建组 / 删除组 的终端命令都需要通过 sudo 执行 序号 命令 作用 01 groupadd 组名 添加组 02 groupdel 组名 删除组 03 cat /etc/group 确认组信息 04 chgrp -R 组名 文件/目录名 递归修改文件/目录的所属组 提示： 组信息保存在 /etc/group 文件中 /etc 目录是专门用来保存 系统配置信息 的目录 在实际应用中，可以预先针对 组 设置好权限，然后 将不同的用户添加到对应的组中，从而不用依次为每一个用户设置权限 演练目标 在 python 用户的桌面文件夹下创建 Python学习 目录 新建 dev 组 将 Python学习 目录的组修改为 dev 3. 用户管理 终端命令 提示：创建用户 / 删除用户 / 修改其他用户密码 的终端命令都需要通过 sudo 执行 3.1 创建用户／设置密码／删除用户 序号 命令 作用 说明 01 useradd -m -g 组 新建用户名 添加新用户 -m 自动建立用户家目录-g 指定用户所在的组，否则会建立一个和同名的组 02 passwd 用户名 设置用户密码 如果是普通用户，直接用 passwd 可以修改自己的账户密码 03 userdel -r 用户名 删除用户 -r 选项会自动删除用户家目录 04 cat /etc/passwd \\ grep 用户名 确认用户信息 新建用户后，用户信息会保存在 /etc/passwd 文件中 提示： 创建用户时，如果忘记添加 -m 选项指定新用户的家目录 —— 最简单的方法就是删除用户，重新创建 创建用户时，默认会创建一个和用户名同名的组名 用户信息保存在 /etc/passwd 文件中 3.2 查看用户信息 序号 命令 作用 01 id [用户名] 查看用户 UID 和 GID 信息 02 who 查看当前所有登录的用户列表 03 whoami 查看当前登录用户的账户名 passwd 文件/etc/passwd 文件存放的是用户的信息，由 6 个分号组成的 7 个信息，分别是 用户名 密码（x，表示加密的密码） UID（用户标识） GID（组标识） 用户全名或本地帐号 家目录 登录使用的 Shell，就是登录之后，使用的终端命令，ubuntu 默认是 dash usermod usermod 可以用来设置 用户 的 主组 ／ 附加组 和 登录 Shell，命令格式如下： 主组：通常在新建用户时指定，在 etc/passwd 的第 4 列 GID 对应的组 附加组：在 etc/group 中最后一列表示该组的用户列表，用于指定 用户的附加权限 提示：设置了用户的附加组之后，需要重新登录才能生效！ 12345678# 修改用户的主组（passwd 中的 GID）usermod -g 组 用户名# 修改用户的附加组usermod -G 组 用户名# 修改用户登录 Shellusermod -s /bin/bash 用户名 注意：默认使用 useradd 添加的用户是没有权限使用 sudo 以 root 身份执行命令的，可以使用以下命令，将用户添加到 sudo 附加组中 1usermod -G sudo 用户名 which 提示 /etc/passwd 是用于保存用户信息的文件 /usr/bin/passwd 是用于修改用户密码的程序 which 命令可以查看执行命令所在位置，例如： 123456789which ls# 输出# /bin/lswhich useradd# 输出# /usr/sbin/useradd bin 和 sbin 在 Linux 中，绝大多数可执行文件都是保存在 /bin、/sbin、/usr/bin、/usr/sbin /bin（binary）是二进制执行文件目录，主要用于具体应用 /sbin（system binary）是系统管理员专用的二进制代码存放目录，主要用于系统管理 /usr/bin（user commands for applications）后期安装的一些软件 /usr/sbin（super user commands for applications）超级用户的一些管理程序 提示： cd 这个终端命令是内置在系统内核中的，没有独立的文件，因此用 which 无法找到 cd 命令的位置 3.3 切换用户 序号 命令 作用 说明 01 su - 用户名 切换用户，并且切换目录 - 可以切换到用户家目录，否则保持位置不变 02 exit 退出当前登录账户 su 不接用户名，可以切换到 root，但是不推荐使用，因为不安全 exit 示意图如下： 4. 修改文件权限 序号 命令 作用 01 chown 修改拥有者 02 chgrp 修改组 03 chmod 修改权限 命令格式如下： 12345678# 修改文件|目录的拥有者chown 用户名 文件名|目录名# 递归修改文件|目录的组chgrp -R 组名 文件名|目录名# 递归修改文件权限chmod -R 755 文件名|目录名 chmod 在设置权限时，可以简单地使用三个数字分别对应 拥有者 ／ 组 和 其他 用户的权限 12# 直接修改文件|目录的 读|写|执行 权限，但是不能精确到 拥有者|组|其他chmod +/-rwx 文件名|目录名 ￼ 常见数字组合有（u表示用户／g表示组／o表示其他）： 777 ===&gt; u=rwx,g=rwx,o=rwx 755 ===&gt; u=rwx,g=rx,o=rx 644 ===&gt; u=rw,g=r,o=r chmod 演练目标 将 01.py 的权限修改为 u=rwx,g=rx,o=r 将 123.txt 的权限修改为 u=rw,g=r,o=- 将 test 目录以及目录下的 所有 文件权限修改为 u=rwx,g=rwx,o=rx","categories":[{"name":"Linux","slug":"Linux","permalink":"https://codave.github.io/categories/Linux/"}],"tags":[{"name":"Linux基础","slug":"Linux基础","permalink":"https://codave.github.io/tags/Linux基础/"}]},{"title":"Python语法基础04-字符串","slug":"Python语法基础04-字符串","date":"2019-03-23T04:22:58.000Z","updated":"2019-03-23T09:18:10.826Z","comments":true,"path":"2019/03/23/Python语法基础04-字符串/","link":"","permalink":"https://codave.github.io/2019/03/23/Python语法基础04-字符串/","excerpt":"","text":"1. 字符串的定义 字符串 就是 一串字符，是编程语言中表示文本的数据类型 在 Python 中可以使用 一对双引号 &quot; 或者 一对单引号 &#39; 定义一个字符串 虽然可以使用 \\&quot; 或者 \\&#39; 做字符串的转义，但是在实际开发中： 如果字符串内部需要使用 &quot;，可以使用 &#39; 定义字符串 如果字符串内部需要使用 &#39;，可以使用 &quot; 定义字符串 可以使用 索引 获取一个字符串中 指定位置的字符，索引计数从 0 开始 也可以使用 for 循环遍历 字符串中每一个字符 大多数编程语言都是用 &quot; 来定义字符串 1234string = \"Hello Python\"for c in string: print(c) 2. 字符串的常用操作 在 ipython3 中定义一个 字符串，例如：hello_str = &quot;&quot; 输入 hello_str. 按下 TAB 键，ipython 会提示 字符串 能够使用的 方法 如下： 12345678910111213141516In [1]: hello_str.hello_str.capitalize hello_str.isidentifier hello_str.rindexhello_str.casefold hello_str.islower hello_str.rjusthello_str.center hello_str.isnumeric hello_str.rpartitionhello_str.count hello_str.isprintable hello_str.rsplithello_str.encode hello_str.isspace hello_str.rstriphello_str.endswith hello_str.istitle hello_str.splithello_str.expandtabs hello_str.isupper hello_str.splitlineshello_str.find hello_str.join hello_str.startswithhello_str.format hello_str.ljust hello_str.striphello_str.format_map hello_str.lower hello_str.swapcasehello_str.index hello_str.lstrip hello_str.titlehello_str.isalnum hello_str.maketrans hello_str.translatehello_str.isalpha hello_str.partition hello_str.upperhello_str.isdecimal hello_str.replace hello_str.zfillhello_str.isdigit hello_str.rfind 提示：正是因为 python 内置提供的方法足够多，才使得在开发时，能够针对字符串进行更加灵活的操作！应对更多的开发需求！ 1) 判断类型 - 9 方法 说明 string.isspace() 如果 string 中只包含空格，则返回 True string.isalnum() 如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True string.isalpha() 如果 string 至少有一个字符并且所有字符都是字母则返回 True string.isdecimal() 如果 string 只包含数字则返回 True，全角数字 string.isdigit() 如果 string 只包含数字则返回 True，全角数字、⑴、\\u00b2 string.isnumeric() 如果 string 只包含数字则返回 True，全角数字，汉字数字 string.istitle() 如果 string 是标题化的(每个单词的首字母大写)则返回 True string.islower() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True string.isupper() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True 2) 查找和替换 - 7 方法 说明 string.startswith(str) 检查字符串是否是以 str 开头，是则返回 True string.endswith(str) 检查字符串是否是以 str 结束，是则返回 True string.find(str, start=0, end=len(string)) 检测 str 是否包含在 string 中，如果 start 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 -1 string.rfind(str, start=0, end=len(string)) 类似于 find()，不过是从右边开始查找 string.index(str, start=0, end=len(string)) 跟 find() 方法类似，不过如果 str 不在 string 会报错 string.rindex(str, start=0, end=len(string)) 类似于 index()，不过是从右边开始 string.replace(old_str, new_str, num=string.count(old)) 把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过 num 次 3) 大小写转换 - 5 方法 说明 string.capitalize() 把字符串的第一个字符大写 string.title() 把字符串的每个单词首字母大写 string.lower() 转换 string 中所有大写字符为小写 string.upper() 转换 string 中的小写字母为大写 string.swapcase() 翻转 string 中的大小写 4) 文本对齐 - 3 方法 说明 string.ljust(width) 返回一个原字符串左对齐，并使用空格填充至长度 width 的新字符串 string.rjust(width) 返回一个原字符串右对齐，并使用空格填充至长度 width 的新字符串 string.center(width) 返回一个原字符串居中，并使用空格填充至长度 width 的新字符串 5) 去除空白字符 - 3 方法 说明 string.lstrip() 截掉 string 左边（开始）的空白字符 string.rstrip() 截掉 string 右边（末尾）的空白字符 string.strip() 截掉 string 左右两边的空白字符 6) 拆分和连接 - 5 方法 说明 string.partition(str) 把字符串 string 分成一个 3 元素的元组 (str前面, str, str后面) string.rpartition(str) 类似于 partition() 方法，不过是从右边开始查找 string.split(str=””, num) 以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1 个子字符串，str 默认包含 ‘\\r’, ‘\\t’, ‘\\n’ 和空格 string.splitlines() 按照行(‘\\r’, ‘\\n’, ‘\\r\\n’)分隔，返回一个包含各行作为元素的列表 string.join(seq) 以 string 作为分隔符，将 seq 中所有的元素（的字符串表示）合并为一个新的字符串 3. 字符串的切片 切片 方法适用于 字符串、列表、元组 切片 使用 索引值 来限定范围，从一个大的 字符串 中 切出 小的 字符串 列表 和 元组 都是 有序 的集合，都能够 通过索引值 获取到对应的数据 字典 是一个 无序 的集合，是使用 键值对 保存数据 1字符串[开始索引:结束索引:步长] 注意： 指定的区间属于 左闭右开 型 [开始索引, 结束索引) =&gt; 开始索引 &gt;= 范围 &lt; 结束索引 从 起始 位开始，到 结束位的前一位 结束（不包含结束位本身) 从头开始，开始索引 数字可以省略，冒号不能省略 到末尾结束，结束索引 数字可以省略，冒号不能省略 步长默认为 1，如果连续切片，数字和冒号都可以省略 索引的顺序和倒序 在 Python 中不仅支持 顺序索引，同时还支持 倒序索引 所谓倒序索引就是 从右向左 计算索引 最右边的索引值是 -1，依次递减 4. 演练需求 截取从 2 ~ 5 位置 的字符串 截取从 2 ~ 末尾 的字符串 截取从 开始 ~ 5 位置 的字符串 截取完整的字符串 从开始位置，每隔一个字符截取字符串 从索引 1 开始，每隔一个取一个 截取从 2 ~ 末尾 - 1 的字符串 截取字符串末尾两个字符 字符串的逆序（面试题） 答案 1234567891011121314151617181920212223242526272829303132num_str = &quot;0123456789&quot;# 1. 截取从 2 ~ 5 位置 的字符串print(num_str[2:6])# 2. 截取从 2 ~ `末尾` 的字符串print(num_str[2:])# 3. 截取从 `开始` ~ 5 位置 的字符串print(num_str[:6])# 4. 截取完整的字符串print(num_str[:])# 5. 从开始位置，每隔一个字符截取字符串print(num_str[::2])# 6. 从索引 1 开始，每隔一个取一个print(num_str[1::2])# 倒序切片# -1 表示倒数第一个字符print(num_str[-1])# 7. 截取从 2 ~ `末尾 - 1` 的字符串print(num_str[2:-1])# 8. 截取字符串末尾两个字符print(num_str[-2:])# 9. 字符串的逆序（面试题）print(num_str[::-1])","categories":[{"name":"Python","slug":"Python","permalink":"https://codave.github.io/categories/Python/"}],"tags":[{"name":"str","slug":"str","permalink":"https://codave.github.io/tags/str/"}]},{"title":"Python语法基础03-字典","slug":"Python语法基础03-字典","date":"2019-03-23T04:22:05.000Z","updated":"2019-03-23T09:22:09.396Z","comments":true,"path":"2019/03/23/Python语法基础03-字典/","link":"","permalink":"https://codave.github.io/2019/03/23/Python语法基础03-字典/","excerpt":"","text":"1. 字典的定义 dictionary（字典） 是 除列表以外 Python 之中 最灵活 的数据类型 字典同样可以用来 存储多个数据 通常用于存储 描述一个 物体 的相关信息 和列表的区别 列表 是 有序 的对象集合 字典 是 无序 的对象集合 字典用 {} 定义 字典使用 键值对 存储数据，键值对之间使用 , 分隔 键 key 是索引 值 value 是数据 键 和 值 之间使用 : 分隔 键必须是唯一的 值 可以取任何数据类型，但 键 只能使用 字符串、数字或 元组 1234xiaoming = &#123;\"name\": \"小明\", \"age\": 18, \"gender\": True, \"height\": 1.75&#125; 2. 字典常用操作 在 ipython3 中定义一个 字典，例如：xiaoming = {} 输入 xiaoming. 按下 TAB 键，ipython 会提示 字典 能够使用的函数如下： 12345In [1]: xiaoming.xiaoming.clear xiaoming.items xiaoming.setdefaultxiaoming.copy xiaoming.keys xiaoming.updatexiaoming.fromkeys xiaoming.pop xiaoming.valuesxiaoming.get xiaoming.popitem 有关 字典 的 常用操作 可以参照上图练习 3. 循环遍历 遍历 就是 依次 从 字典 中获取所有键值对 1234# for 循环内部使用的 `key 的变量` in 字典for k in xiaoming: print(\"%s: %s\" % (k, xiaoming[k])) 提示：在实际开发中，由于字典中每一个键值对保存数据的类型是不同的，所以针对字典的循环遍历需求并不是很多 4. 应用场景 尽管可以使用 for in 遍历 字典 但是在开发中，更多的应用场景是： 使用 多个键值对，存储 描述一个 物体 的相关信息 —— 描述更复杂的数据信息 将 多个字典 放在 一个列表 中，再进行遍历，在循环体内部针对每一个字典进行 相同的处理 1234567card_list = [&#123;\"name\": \"张三\", \"qq\": \"12345\", \"phone\": \"110\"&#125;, &#123;\"name\": \"李四\", \"qq\": \"54321\", \"phone\": \"10086\"&#125; ]","categories":[{"name":"Python","slug":"Python","permalink":"https://codave.github.io/categories/Python/"}],"tags":[{"name":"dict","slug":"dict","permalink":"https://codave.github.io/tags/dict/"},{"name":"字典","slug":"字典","permalink":"https://codave.github.io/tags/字典/"}]},{"title":"Python语法基础02-元组","slug":"Python语法基础02-元组","date":"2019-03-23T04:20:51.000Z","updated":"2019-03-23T09:21:36.475Z","comments":true,"path":"2019/03/23/Python语法基础02-元组/","link":"","permalink":"https://codave.github.io/2019/03/23/Python语法基础02-元组/","excerpt":"","text":"1. 元组1.1 元组的定义 Tuple（元组）与列表类似，不同之处在于元组的 元素不能修改 元组 表示多个元素组成的序列 元组 在 Python 开发中，有特定的应用场景 用于存储 一串 信息，数据 之间使用 , 分隔 元组用 () 定义 元组的 索引 从 0 开始 索引 就是数据在 元组 中的位置编号 1info_tuple = (\"zhangsan\", 18, 1.75) 创建空元组 1info_tuple = () 元组中只包含一个元素 时，需要 在元素后面添加逗号 1info_tuple = (50, ) 1.2 元组常用操作 在 ipython3 中定义一个 元组，例如：info = () 输入 info. 按下 TAB 键，ipython 会提示 元组 能够使用的函数如下： 1info.count info.index 有关 元组 的 常用操作 可以参照上图练习 1.3 循环遍历 取值 就是从 元组 中获取存储在指定位置的数据 遍历 就是 从头到尾 依次 从 元组 中获取数据 12345# for 循环内部使用的变量 in 元组for item in info: 循环内部针对元组元素进行操作 print(item) 在 Python 中，可以使用 for 循环遍历所有非数字型类型的变量：列表、元组、字典 以及 字符串 提示：在实际开发中，除非 能够确认元组中的数据类型，否则针对元组的循环遍历需求并不是很多 1.4 应用场景 尽管可以使用 for in 遍历 元组 但是在开发中，更多的应用场景是： 函数的 参数 和 返回值，一个函数可以接收 任意多个参数，或者 一次返回多个数据 有关 函数的参数 和 返回值，在后续 函数高级 给大家介绍 格式字符串，格式化字符串后面的 () 本质上就是一个元组 让列表不可以被修改，以保护数据安全 123info = (\"zhangsan\", 18)print(\"%s 的年龄是 %d\" % info) 2. 元组和列表之间的转换 使用 list 函数可以把元组转换成列表 1list(元组) 使用 tuple 函数可以把列表转换成元组 1tuple(列表)","categories":[{"name":"Python","slug":"Python","permalink":"https://codave.github.io/categories/Python/"}],"tags":[{"name":"tuple","slug":"tuple","permalink":"https://codave.github.io/tags/tuple/"}]},{"title":"Python语法基础01-列表","slug":"Python语法基础01-列表","date":"2019-03-22T13:07:49.000Z","updated":"2019-03-23T09:19:29.039Z","comments":true,"path":"2019/03/22/Python语法基础01-列表/","link":"","permalink":"https://codave.github.io/2019/03/22/Python语法基础01-列表/","excerpt":"","text":"1. 知识点提要 Python 中数据类型可以分为 数字型 和 非数字型 数字型 整型 (int) 浮点型（float） 布尔型（bool） 真 True 非 0 数 —— 非零即真 假 False 0 复数型 (complex) 主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题 非数字型 字符串 列表 元组 字典 在 Python 中，所有 非数字型变量 都支持以下特点： 都是一个 序列 sequence，也可以理解为 容器 取值 [] 遍历 for in 计算长度、最大/最小值、比较、删除 链接 + 和 重复 * 切片 2. 列表2.1 列表的定义 List（列表） 是 Python 中使用 最频繁 的数据类型，在其他语言中通常叫做 数组 专门用于存储 一串 信息 列表用 [] 定义，数据 之间使用 , 分隔 列表的 索引 从 0 开始 索引 就是数据在 列表 中的位置编号，索引 又可以被称为 下标 注意：从列表中取值时，如果 超出索引范围，程序会报错 1name_list = [\"zhangsan\", \"lisi\", \"wangwu\"] 2.2 列表常用操作 在 ipython3 中定义一个 列表，例如：name_list = [] 输入 name_list. 按下 TAB 键，ipython 会提示 列表 能够使用的 方法 如下： 1234In [1]: name_list.name_list.append name_list.count name_list.insert name_list.reversename_list.clear name_list.extend name_list.pop name_list.sortname_list.copy name_list.index name_list.remove 序号 分类 关键字 / 函数 / 方法 说明 1 增加 列表.insert(索引, 数据) 在指定位置插入数据 列表.append(数据) 在末尾追加数据 列表.extend(列表2) 将列表2 的数据追加到列表 2 修改 列表[索引] = 数据 修改指定索引的数据 3 删除 del 列表[索引] 删除指定索引的数据 列表.remove[数据] 删除第一个出现的指定数据 列表.pop 删除末尾数据 列表.pop(索引) 删除指定索引数据 列表.clear 清空列表 4 统计 len(列表) 列表长度 列表.count(数据) 数据在列表中出现的次数 5 排序 列表.sort() 升序排序 列表.sort(reverse=True) 降序排序 列表.reverse() 逆序、反转 del 关键字 使用 del 关键字(delete) 同样可以删除列表中元素 del 关键字本质上是用来 将一个变量从内存中删除的 如果使用 del 关键字将变量从内存中删除，后续的代码就不能再使用这个变量了 1del name_list[1] 在日常开发中，要从列表删除数据，建议 使用列表提供的方法 关键字、函数和方法 关键字 是 Python 内置的、具有特殊意义的标识符 123In [1]: import keywordIn [2]: print(keyword.kwlist)In [3]: print(len(keyword.kwlist)) 关键字后面不需要使用括号 函数 封装了独立功能，可以直接调用 1函数名(参数) 函数需要死记硬背 方法 和函数类似，同样是封装了独立的功能 方法 需要通过 对象 来调用，表示针对这个 对象 要做的操作 1对象.方法名(参数) 在变量后面输入 .，然后选择针对这个变量要执行的操作，记忆起来比函数要简单很多 2.3 循环遍历 遍历 就是 从头到尾 依次 从 列表 中获取数据 在 循环体内部 针对 每一个元素，执行相同的操作 在 Python 中为了提高列表的遍历效率，专门提供的 迭代 iteration 遍历 使用 for 就能够实现迭代遍历 12345# for 循环内部使用的变量 in 列表for name in name_list: #循环内部针对列表元素进行操作 print(name) 2.4 应用场景 尽管 Python 的 列表 中可以 存储不同类型的数据 但是在开发中，更多的应用场景是： 列表 存储相同类型的数据 通过 迭代遍历，在循环体内部，针对列表中的每一项元素，执行相同的操作","categories":[{"name":"Python","slug":"Python","permalink":"https://codave.github.io/categories/Python/"}],"tags":[{"name":"list","slug":"list","permalink":"https://codave.github.io/tags/list/"}]},{"title":"Linux基础04-远程管理命令","slug":"Linux基础04-远程管理命令","date":"2019-03-21T13:14:25.000Z","updated":"2019-03-24T04:54:22.907Z","comments":true,"path":"2019/03/21/Linux基础04-远程管理命令/","link":"","permalink":"https://codave.github.io/2019/03/21/Linux基础04-远程管理命令/","excerpt":"","text":"1.关机/重启 序号 命令 对应英文 含义 01 shutdown 选项 时间 shutdown 关机/重新启动 1.1 shutdown shutdown命令可以安全关闭或者重新启动系统 选项 含义 -r 重新启动 提示： 不指定选项和参数，默认表示1分钟之后关闭电脑 远程维护服务器时，最好不要关闭系统，而应该重新启动系统 常用命令示例： 1234567891011121314#重新启动操作系统，其中 now 表示现在$ shutdown -r now#立刻关机，其中 now 表示现在$ shutdown now#系统在今天的 13:14 会关机$ shutdown 13:14#系统再过十分钟后自动关机$ shutdown +10#取消之前指定的关机计划$ shutdown -c 2. 查看或配置网卡信息 序号 命令 对应英文 作用 01 ifconfig configure a network interface 查看/配置计算机当前的网卡配置信息 02 ping ip地址 ping 检测到目标ip地址的链接是否正常 2.1 ifconfig ifconfig可以查看/配置计算机当前的网卡配置信息 12345#查看网卡配置信息$ ifconfig#查看网卡对应的IP地址$ ifconfig | grep inet 提示：一台计算机中有可能会有一个物理地址和多个虚拟网卡，在Linux中物理网卡的名字通常以ensXX表示 127.0.0.1被称为本地回环/环回地址，一般用来测试本机网卡是否正常 2.2 ping 12345#检测到目标主机是否连接正常$ ping IP地址#检测本地网卡工作正常$ ping 127.0.0.1 ping 一般用于检测当前计算机到目标计算机之间的网络 是否通畅，数值越大，速度越慢 ping的的工作原理与潜水艇的声纳相似，ping这个命令就是取自声呐的声音 网络管理员之间也常将ping用作动词——ping一下计算机X，看他是否开着 3. 远程登录和复制文件 序号 命令 对应英文 作用 01 ssh 用户名@ip secure shell 关机/重新启动 02 scp 用户名@ip：文件名或路径 用户名@ip：文件名或路径 secure copy 远程复制文件 3.1 ssh基础在 Linux 中 SSH 是 非常常用 的工具，通过 SSH 客户端 我们可以连接到运行了 SSH 服务器 的远程机器上 SSH 客户端是一种使用 Secure Shell（SSH） 协议连接到远程计算机的软件程序 ssh是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议 利用 SSH 协议 可以有效防止远程管理过程中的信息泄露 通过 SSH 协议 可以对所有传输的数据进行加密，也能够防止 DNS 欺骗和 IP 欺骗 SSH 的另一项优点是传输的数据可以是经过压缩的，所以可以加快传输的速度 1) 域名 和 端口号域名 由一串 用点分隔 的名字组成，例如：www.itcast.cn 是 IP 地址 的别名，方便用户记忆 端口号 IP 地址：通过 IP 地址 找到网络上的 计算机 端口号：通过 端口号 可以找到 计算机上运行的应用程序 SSH 服务器 的默认端口号是 22，如果是默认端口号，在连接的时候，可以省略 常见服务端口号列表： 序号 服务 端口号 01 SSH服务器 22 02 Web服务器 80 03 HTTPS 443 04 FTP服务器 21 2) SSH 客户端的简单使用1ssh [-p port] user@remote user 是在远程机器上的用户名，如果不指定的话默认为当前用户 remote 是远程机器的地址，可以是 IP／域名，或者是 后面会提到的别名 port 是 SSH Server 监听的端口，如果不指定，就为默认值 22 提示： 使用 exit 退出当前用户的登录 注意： ssh 这个终端命令只能在 Linux 或者 UNIX 系统下使用 如果在 Windows 系统中，可以安装 PuTTY 或者 XShell 客户端软件即可 提示： 在工作中，SSH 服务器的端口号很有可能不是 22，如果遇到这种情况就需要使用 -p 选项，指定正确的端口号，否则无法正常连接到服务器 3) Windows 下 SSH 客户端的安装 Putty http://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html XShell http://xshellcn.com 建议从官方网站下载正式的安装程序 3.2 scp scp 就是 secure copy，是一个在 Linux 下用来进行 远程拷贝文件 的命令 它的地址格式与 ssh 基本相同，需要注意的是，在指定端口时用的是大写的 -P 而不是小写的 12345678910111213# 把本地当前目录下的 01.py 文件 复制到 远程 家目录下的 Desktop/01.py# 注意：`:` 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径scp -P port 01.py user@remote:Desktop/01.py# 把远程 家目录下的 Desktop/01.py 文件 复制到 本地当前目录下的 01.pyscp -P port user@remote:Desktop/01.py 01.py# 加上 -r 选项可以传送文件夹# 把当前目录下的 demo 文件夹 复制到 远程 家目录下的 Desktopscp -r demo user@remote:Desktop# 把远程 家目录下的 Desktop 复制到 当前目录下的 demo 文件夹scp -r user@remote:Desktop demo 选项 含义 -r 若给出的源文件是目录文件，则 scp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名 -P 若远程 SSH 服务器的端口不是 22，需要使用大写字母 -P 选项指定端口 注意： scp 这个终端命令只能在 Linux 或者 UNIX 系统下使用 如果在 Windows 系统中，可以安装 PuTTY，使用 pscp 命令行工具或者安装 FileZilla 使用 FTP 进行文件传输 FileZilla 官方网站：https://www.filezilla.cn/download/client FileZilla 在传输文件时，使用的是 FTP 服务 而不是 SSH 服务，因此端口号应该设置为 21 3.3 SSH 高级 免密码登录 配置别名 提示：有关 SSH 配置信息都保存在用户家目录下的 .ssh 目录下 1）免密码登录步骤 配置公钥 执行 ssh-keygen 即可生成 SSH 钥匙，一路回车即可 上传公钥到服务器 执行 ssh-copy-id -p port user@remote，可以让远程服务器记住我们的公钥 非对称加密算法 使用 公钥 加密的数据，需要使用 私钥 解密 使用 私钥 加密的数据，需要使用 公钥 解密 2) 配置别名每次都输入 ssh -p port user@remote，时间久了会觉得很麻烦，特别是当 user, remote 和 port 都得输入，而且还不好记忆 而 配置别名 可以让我们进一步偷懒，譬如用：ssh mac 来替代上面这么一长串，那么就在 ~/.ssh/config 里面追加以下内容： 1234Host mac HostName ip地址 User itheima Port 22 保存之后，即可用 ssh mac 实现远程登录了，scp 同样可以使用","categories":[{"name":"Linux","slug":"Linux","permalink":"https://codave.github.io/categories/Linux/"}],"tags":[{"name":"Linux基础","slug":"Linux基础","permalink":"https://codave.github.io/tags/Linux基础/"}]},{"title":"Linux基础03-文件相关命令","slug":"Linux基础03-文件相关命令","date":"2019-03-21T12:53:42.000Z","updated":"2019-03-24T04:54:13.268Z","comments":true,"path":"2019/03/21/Linux基础03-文件相关命令/","link":"","permalink":"https://codave.github.io/2019/03/21/Linux基础03-文件相关命令/","excerpt":"","text":"1. 创建和删除操作1.1 touch 如果文件不存在，可以创建一个空白文件。 如果文件已经存在，可以修改文件的末次修改日期。 1.2 mkdir 创建一个新的目录 选项 含义 -p 可以递归创建目录 新建目录的名称不能与当前目录中已有的目录或文件夹同名。 1.3 rm 删除文件或目录 参数 含义 -f 强制删除，忽略不存在的文件，无需提示 -r 递归地删除目录下的内容，删除文件夹时必须加此参数 注意！不要使用rm -rf /* 命令！！！在虚拟机里面可以试试，然后重装。 2. 拷贝和移动文件 序号 命令 对应英文 作用 01 tree[目录名] tree 以树形图列出文件目录结构 02 cp 源文件 目标文件 copy 复制文件或目录 03 mv 源文件 目标文件 move 移动文件或目录/文件或目录重命名 2.1 tree tree命令可以以树形图列出文件目录结构 tree ~ tree / 选项 含义 -d 只显示目录 2.2 cp cp命令的功能是将给出的文件或目录复制到另一个文件或目录中，相当于DOS下的copy命令。 选项 含义 -r 已经存在的目标文件直接覆盖，不会提示 -i 覆盖文件前提示 -r 若给出的源文件是目录文件，则cp将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名。 2.3 mv mv命令可以用来移动文件或目录，也可以给文件或目录重命名。 选项 含义 -i 覆盖文件前提示 3. 查看文件内容 序号 命令 对应英文 作用 01 cat 文件名 concatenate 查看文件内容、创建文件、文件合并、追加文件内容等功能 02 more 文件名 more 分屏显示文件内容 03 grep 搜索文本文件名 grep 搜索文本文件内容 3.1 cat cat命令可以用来查看文件内容、创建文本、文件合并、追加文本内容等功能 cat会一次显示所有的内容，适合查看内容较少的文本文件 选项 含义 -b 对非空输出行编号 -n 对输出的所有行编号 Linux中还有一个nl的命令和cat -b的效果等价。 3.2 more more命令可以用于分屏显示较多的文件内容，每次只显示一页内容 适合于查看内容较多的文本文件 使用more的操作键： 操作键 功能 空格键 显示手册页的下一页 Enter 一次滚动手册的一行 b 回滚一屏 f 前滚一屏 q 退出 /word 搜索word字符串 3.3 grep Linux系统中grep命令是一种强大的文本搜索工具 grep允许对文本文件进行模式查找，所谓模式查找，又被称为正则表达式 选项 含义 -n 显示匹配行及行号 -v 显示不包含匹配文本的所有行（相当于求反） -i 忽略大小写 常用的两种模式查找 参数 含义 ^a 行首，搜索以a开头的行 a$ 行尾，搜索以a结束的行 4. 其他4.1 echo 文字内容 echo会在终端中显示参数指定的文字，通常会和重定向联合使用 4.2 重定向 &gt; 和 &gt;&gt; Linux允许将命令执行结果重定向到一个文件 将文本显示到终端上的内容 输出 / 追加到指定文件中 注意： &gt;表示输出，会覆盖文件原有的内容 &gt;&gt;表示追加，会将内容追加到已有文件的末尾 4.3 管道 | Linux允许将 一个命令的输出 可以通过 作为另一个命令的输入 可以理解现实生活中的管子，管子的一头塞东西进去，另一头取出来。这里 | 的左右分为两端，左端塞东西（写），右端取东西（读）。 常用的管道命令有： more分屏显示内容 grep在命令执行结果的基础上查询指定的文本","categories":[{"name":"Linux","slug":"Linux","permalink":"https://codave.github.io/categories/Linux/"}],"tags":[{"name":"Linux基础","slug":"Linux基础","permalink":"https://codave.github.io/tags/Linux基础/"}]},{"title":"Linux基础02-目录相关命令","slug":"Linux基础02-目录相关命令","date":"2019-03-21T11:54:41.000Z","updated":"2019-03-24T04:54:08.418Z","comments":true,"path":"2019/03/21/Linux基础02-目录相关命令/","link":"","permalink":"https://codave.github.io/2019/03/21/Linux基础02-目录相关命令/","excerpt":"","text":"1. ls命令说明 Linux下文件和目录的特点 Linux文件或目录名称最长可以有256个字符 以.开头的文件为隐藏文件，需要-a参数才能显示 .代表当前目录 ..代表上一级目录 /代表根目录 ~代表当前用户home目录 1.1 ls常用选项 参数 含义 -a 显示指定目录下所有子目录与文件 -l 以列表方式显示文件的详细信息 -h 配合 -l 以人性化的方式显示文件大小 1.2 ls通配符的使用 通配符 含义 * 代表任意个数字字符 ？ 代表任意一个字符，至少一个 [] 表示可以匹配字符组中的任意一个 [abc] 匹配a、b、c中的任意一个 [a-f] 匹配从a 到 f 范围内的任意一个字符 说明：这里是正则表达式的知识。 2. 切换目录2.1 cd cd是change directory的简写，其作用是更改当前的工作目录。 注意：Linux所有的目录和文件名都是大小写敏感的。 命令 含义 cd 切换到当前用户的主目录（/home/用户目录） cd ~ 切换到当前用户的主目录（/home/用户目录） cd . 保持在当前目录不变 cd .. 切换到上级目录 cd - 可以在最近两次工作目录之间来回切换 2.2 相对路径和绝对路径 相对路径 在输入路径时，最前面不是 / 或者 ~，表示相对当前目录所在的目录位置。 绝对路径 在输入路径时，最前面是 / 或者 ~，表示从根目录 / 家目录开始的具体位置。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://codave.github.io/categories/Linux/"}],"tags":[{"name":"Linux基础","slug":"Linux基础","permalink":"https://codave.github.io/tags/Linux基础/"}]},{"title":"Linux基础01-Linux命令简介","slug":"Linux基础01-Linux命令简介","date":"2019-03-21T09:45:45.000Z","updated":"2019-03-24T04:54:02.805Z","comments":true,"path":"2019/03/21/Linux基础01-Linux命令简介/","link":"","permalink":"https://codave.github.io/2019/03/21/Linux基础01-Linux命令简介/","excerpt":"","text":"1. 常用Linux命令的基本使用 序号 命令 对应英文 作用 01 ls list 查看当前文件夹下的内容 02 pwd print work directory 查看当前文件夹路径 03 cd[目录名] change directory 切换文件夹 04 touch[文件名] touch 新建文件 05 mkdir[目录名] make directory 创建目录 06 rm[文件名] remove 删除指定的文件名 07 clear clear 清屏 小技巧 ctrl + shift + =放大终端窗口的字体显示 ctrl + -缩小终端窗口的字体显示 2. 自动补全2.1 自动补全在敲出文件/目录/命令的前几个字母之后，按下tab键 如果输入的没有歧义，系统会自动补全 如果还有其他文件/目录/命令,再按一下tab键，系统会提示可能存在的命令。 2.2 曾经使用过的命令 按上/下光标键可以在曾经使用的命令之间来回切换 如果想要退出选择，并且不想执行当前选中的命令，可以按ctrl + c 3. Linux终端命令格式3.1 终端命令格式1command [-options] [parameter] 说明： command：命令名，相应功能的英文单词或单词的缩写 [-options]:选项，可用来对命令进行控制，也可以省略 parameter:传给命令的参数，可以是零个、一个或者多个 3.2 查阅命令帮助信息 –help 1command --help 说明：显示command命令的帮助信息 man 1man command 说明：查阅command命令的使用手册 man是manual的缩写，是Linux提供的一个手册，包含了绝大多数的命令、函数的详细使用说明","categories":[{"name":"Linux","slug":"Linux","permalink":"https://codave.github.io/categories/Linux/"}],"tags":[{"name":"Linux基础","slug":"Linux基础","permalink":"https://codave.github.io/tags/Linux基础/"}]},{"title":"少年时代的爱,不过是表演【选自意林】","slug":"少年时代的爱,不过是表演【选自意林】","date":"2019-01-30T14:59:37.000Z","updated":"2019-02-21T10:23:15.590Z","comments":true,"path":"2019/01/30/少年时代的爱,不过是表演【选自意林】/","link":"","permalink":"https://codave.github.io/2019/01/30/少年时代的爱,不过是表演【选自意林】/","excerpt":"","text":"&#160; &#160; &#160; &#160;高中的时候，我曾经交往过一个女朋友。有一天我半夜从梦中醒来，突然无比的想她。那时候手机还没有像现在这样普及，我的思念自然无从寄托。在床上瞪了一会儿眼睛以后，我跳起来麻利地穿好衣服，出门去找她了。尽管第二天上早自习我就能够见到她。那时候我以为了方便学习的名义在外面自己租房住，所以也不会遇到宿管大爷这种阻碍，可以来一场说走就走。出了门才发现外面下着大雪，地上已经有着厚厚的积雪，天空中雪花还如筛灰一般落下。但心怀着爱情的炽热，我丝毫没觉得冷。北方下雪的冬夜格外寂静，此时已经是凌晨两点以后，街上没有一个行人，只有我自己踏在积雪上的声音格外清晰。我穿过那条横穿这个小县城的街道，来到我当时女朋友家的楼下。然而我什么都做不了，楼门紧锁，况且即使开着我也没勇气在半夜里去挑战她母亲的忍耐度。于是我在楼下冒着大雪站了一会儿，抽了一支烟，惆怅了一阵子之后，就顺道拐去了网吧……直到很久以后，时过境迁，妹子已经再无联系，而我也不是那能半夜扛住风雪的鸡血少年，我才领悟自己当时的心态。那不过是一种表演罢了，除了把自己感动一下，制造一点自己痴情的假象，一点意义都没有。在感情中，我们往往觉得自己掏心掏肺，所做所为能够感天动地，闻者伤心，见者叹息，为什么偏偏感动不了你？我们总是容易用一种自虐的方式制造出一种痴情的假象来使得自己站在感情的道德制高点上，获得一种畸形的满足感和安全感。其实无论是雪夜去对方家楼下站会儿或者是冒着大雨给她送一杯奶茶什么的，自己回想起来往往觉得如乔峰大战聚贤庄、关羽千里走单骑一样壮怀激烈，而对于对方来说，一杯奶茶就是一杯奶茶，无法承载起你想要在上面寄托的山崩地裂的情怀。少年的时候，总是迫不及待地将自己的满腔爱意表达出来，而结果往往是陷入表演之中而不自知。所以两个人的记忆才会出现偏差，那些你觉得刻骨铭心的过去，对方往往没有同样的感觉，甚至茫然不知。成长的标志就是懂得克制自己。克制自己的情绪，克制自己的表演欲，甚至克制自己的喜欢。少年时候，喜欢一个人恨不能把她变成自己身体的一部分，她刚说冷，我这边心里已经结冰了，她说难过，我立马如丧考妣，比她还难过，唯恐无法将自己的爱意表达出来。而事实上，谁也无法承担起另一个人的价值寄托，只有做一个独立、有价值的人，才能真正学会去爱另一个人。也千万不要尝试改变另一个人，这注定是徒劳的。做自己就好，爱情的真谛在于相互的吸引、志趣相投的同行，而不是追逐和依附。","categories":[{"name":"思考","slug":"思考","permalink":"https://codave.github.io/categories/思考/"}],"tags":[{"name":"情感","slug":"情感","permalink":"https://codave.github.io/tags/情感/"}]},{"title":"NTRU算法的分析","slug":"NTRU算法的分析","date":"2019-01-23T08:16:02.000Z","updated":"2019-02-21T11:07:19.823Z","comments":true,"path":"2019/01/23/NTRU算法的分析/","link":"","permalink":"https://codave.github.io/2019/01/23/NTRU算法的分析/","excerpt":"","text":"NTRU简述&#160; &#160; &#160; &#160;NTRU(Number Theory Research Unit)公开密钥体制是由美国布朗大学三位数学教授(Jeffrey Hoffstein,JillPipher,Joseph H.Silverman)发明的，其安全性是基于数论中在一个非常大的维数格中寻找一个很短向量的数学难题。相对于离散对数或大数分解等公开秘密体制来说，它有许多优势。在安全性方面，NTRU算法具有抵抗量子计算攻击的能力，而RSA和ECC算法是无法抵抗量子计算的。 NTRU算法的描述NTRU算法的数论基础&#160; &#160; &#160; &#160;设有整数环Z、整数N$ \\geq$2，用R表示多项式截断环时，R可以写成：R=Z[X]/(X^N^-1)，对于任意的正整数q，令R _q_ 代表模q的多项式截断环时，R _q_可以写成： $$ R _q_ =(Z/ _q_ Z )[X]/(X ^N^ -1) ​ 可以证明当q时素数时，R具有可逆性。 NTRU算法的描述​","categories":[{"name":"密码学","slug":"密码学","permalink":"https://codave.github.io/categories/密码学/"}],"tags":[{"name":"NTRU","slug":"NTRU","permalink":"https://codave.github.io/tags/NTRU/"}]},{"title":"如何在Hexo博客中添加网易云音乐播放器","slug":"如何在Hexo博客中添加网易云音乐播放器","date":"2019-01-23T05:49:33.000Z","updated":"2019-01-30T15:57:57.461Z","comments":true,"path":"2019/01/23/如何在Hexo博客中添加网易云音乐播放器/","link":"","permalink":"https://codave.github.io/2019/01/23/如何在Hexo博客中添加网易云音乐播放器/","excerpt":"&#160; &#160; &#160; &#160;在已经搭建好Github Page博客的前提下，我们可以在自己的博客中加上音乐播放器，那就非常完美啦！这里我选择网易云音乐。","text":"&#160; &#160; &#160; &#160;在已经搭建好Github Page博客的前提下，我们可以在自己的博客中加上音乐播放器，那就非常完美啦！这里我选择网易云音乐。 步骤一&#160; &#160; &#160; &#160;首先，打开网易云音乐网站，登录自己的账号打开自己的歌单（歌单可以在PC端或者APP客户端上自由创建），也可以不登录直接搜索自己最近最喜欢的一首歌，点击后找到生成外链的链接，如下图： 步骤二&#160; &#160; &#160; &#160;你将会看到如下信息，网易云提供两种方式，一种iframe标签嵌套，另一个是flash插件，两种实现都可以。这里选择第一个。 步骤三&#160; &#160; &#160; &#160;接下来，可以根据自己需求选择尺寸。 步骤四&#160; &#160; &#160; &#160;然后，复制HTML代码，在根目录下的/theme/next/layout/_macro/sidebar.swig文件（侧边栏布局文件）中，选择你要添加播放器的位置，这里我选择添加在第136行处，并修改width=350，height=110。 步骤五&#160; &#160; &#160; &#160;大功告成！效果如下图:","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://codave.github.io/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://codave.github.io/tags/Hexo/"},{"name":"Github Page","slug":"Github-Page","permalink":"https://codave.github.io/tags/Github-Page/"}]},{"title":"如何在列表，字典，集合中根据条件筛选数据","slug":"如何在列表，字典，集合中根据条件筛选数据","date":"2019-01-17T08:09:25.000Z","updated":"2019-01-30T15:54:23.526Z","comments":true,"path":"2019/01/17/如何在列表，字典，集合中根据条件筛选数据/","link":"","permalink":"https://codave.github.io/2019/01/17/如何在列表，字典，集合中根据条件筛选数据/","excerpt":"","text":"实际案例 过滤掉列表[3,9，-1，10,20，-2…]中的负数 筛选字典{‘LiLei’:79,’Jim’:88,’Lucy’:92…}中值高于90的项 筛选集合{77,89,32,20…}中能被3整除的元素 对于以上问题，通常做法是通过迭代循环解决。比如问题1解决代码如下： 123456data = [1,5,-3,-2,6,0,9]res = []for x in data: if x &gt;= 0: res.append(x)print(res) 在列表中根据条件筛选数据 filter函数 列表解析 一.filter() 函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表。 该函数接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。 12345from random import randintdata = [randint(-10, 10) for _ in range(10)]print(data)res = filter(lambda x: x &gt;= 0, data)print(res) 注：lambda函数是匿名函数 二.列表解析 1[x for x in data if x &gt;= 0] 在字典中根据条件筛选数据12345from random import randintd = &#123;x: randint(60, 100) for x in range(1, 21)&#125;print(d)res = &#123;k: v for k, v in d.iteritems() if v &gt; 90&#125;print(res) 在集合中根据条件筛选数据1234data = [randint(-10, 10) for _ in range(10)]s = set(data)res = &#123;x for x in s if x%3 == 0&#125;print(res)","categories":[{"name":"Python","slug":"Python","permalink":"https://codave.github.io/categories/Python/"}],"tags":[{"name":"filter","slug":"filter","permalink":"https://codave.github.io/tags/filter/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-10-19T09:03:25.489Z","updated":"2018-10-22T04:12:17.539Z","comments":true,"path":"2018/10/19/hello-world/","link":"","permalink":"https://codave.github.io/2018/10/19/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}