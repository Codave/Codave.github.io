<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>未来可期</title>
  
  <subtitle>技术博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://codave.github.io/"/>
  <updated>2019-06-05T13:33:29.499Z</updated>
  <id>https://codave.github.io/</id>
  
  <author>
    <name>Codave</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++语法18-类模板与类函数</title>
    <link href="https://codave.github.io/2019/06/05/C++%E8%AF%AD%E6%B3%9518-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%8E%E7%B1%BB%E5%87%BD%E6%95%B0/"/>
    <id>https://codave.github.io/2019/06/05/C++语法18-类模板与类函数/</id>
    <published>2019-06-05T02:24:07.000Z</published>
    <updated>2019-06-05T13:33:29.499Z</updated>
    
    <content type="html"><![CDATA[<p>所谓类模板，实际上是建立一个通用类，其数据成员、成员函数的返回类型和形参类型不具体指定，用一个虚拟的类型来代表。使用类模板定义对象时，系统会根据实参的类型来取代模板中虚拟类型从而实现了不同类的功能。</p><p>定义一个类模板与定义函数模板的格式类似，必须以关键字template开始，后面是尖括号括起来的模板参数，然后是类名，其格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> 类型参数&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> 类名&#123;</span></span><br><span class="line">类成员声明</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>也可以定义成如下形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> 类型参数&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> 类名&#123;</span></span><br><span class="line">类成员声明</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>与函数模板类似，其中，template是一个声明模板的关键字，它表示声明一个模板。类型参数（通常用C++标示符表示，如T、Type等）实际上是一个虚拟的类型名，现在并未指定它是哪一种具体的类型，但使用类模板时，必须将类型参数实例化。类型参数前需要加关键字typename（或class），typename和class作用相同，都是表示其后的参数是一个虚拟的类型名（即类型参数）。</p><p>在声明中，预采用通用数据类型的数据成员、成员函数的参数或返回类型前面需要加上类型参数。</p><p>用类模板定义对象时，采用以下形式：</p><p><strong>类模板名 &lt;实际类型名&gt;对象名[(实参表列)]；</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">类模板的使用举例</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compare</span>&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    Compare(T a,T b)&#123;</span><br><span class="line">        x=a;y=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">T <span class="title">max</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (x&gt;y)?x:y;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    T x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Compare&lt;<span class="keyword">int</span>&gt;  com1(<span class="number">3</span>,<span class="number">7</span>);</span><br><span class="line">    Compare&lt;<span class="keyword">double</span>&gt;  com2(<span class="number">12.34</span>,<span class="number">56.78</span>);</span><br><span class="line"> Compare&lt;<span class="keyword">char</span>&gt;  com3(<span class="string">'a'</span>,<span class="string">'x'</span>);   </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"其中的最大值是："</span>&lt;&lt;com1.max()&lt;&lt;nedl;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"其中的最大值是："</span>&lt;&lt;com2.max()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"其中的最大值是："</span>&lt;&lt;com3.max()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：类模板中的成员函数也可以在类模板体外进行定义。此时，若成员函数中有类型参数存在，则C++有以下一些特殊的规定：</p><p>（1）需要在成员函数定义之前进行模板声明；</p><p>（2）在成员函数名前缀上“类名&lt;类型参数&gt;::”。</p><p>在类模板体外定义的成员函数的一般形式如下：    </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> 类型参数&gt;</span><br><span class="line">函数类型  类名&lt;类型参数&gt;::成员函数名（形参表）&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;所谓类模板，实际上是建立一个通用类，其数据成员、成员函数的返回类型和形参类型不具体指定，用一个虚拟的类型来代表。使用类模板定义对象时，系统会根据实参的类型来取代模板中虚拟类型从而实现了不同类的功能。&lt;/p&gt;
&lt;p&gt;定义一个类模板与定义函数模板的格式类似，必须以关键字temp
      
    
    </summary>
    
      <category term="C++" scheme="https://codave.github.io/categories/C/"/>
    
    
      <category term="类模板" scheme="https://codave.github.io/tags/%E7%B1%BB%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="模板类" scheme="https://codave.github.io/tags/%E6%A8%A1%E6%9D%BF%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>C++语法17-函数模板与模板函数</title>
    <link href="https://codave.github.io/2019/06/05/C++%E8%AF%AD%E6%B3%9517-%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0/"/>
    <id>https://codave.github.io/2019/06/05/C++语法17-函数模板与模板函数/</id>
    <published>2019-06-05T02:23:36.000Z</published>
    <updated>2019-06-05T13:35:18.074Z</updated>
    
    <content type="html"><![CDATA[<p>所谓模板函数，实际上是建立一个通用函数，其函数返回类型和形参类型不具体指定，用一个虚拟的类型来代表。这个通用函数就称为函数模板。在调用函数时系统会根据实参的类型（模板实参）来取代模板中虚拟类型从而实现了不同函数的功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">函数模板的声明格式如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> 类型参数&gt;</span><br><span class="line">返回类型 函数名 模板形参数）</span><br><span class="line">&#123;</span><br><span class="line">函数体</span><br><span class="line"></span><br><span class="line">&#125;；</span><br><span class="line">也可以定义成如下形式：</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> 类型参数&gt;</span></span><br><span class="line"><span class="class">返回类型 函数名（模板形参数）</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">函数体</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>说明：</p><p>（1）在函数模板中允许使用多个类型参数。但是应当注意template定义部分的每个类型参数类型必须有关键字typename(或class)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type1,<span class="keyword">typename</span> type2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myfunc</span><span class="params">(type1 x,type2 y)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="string">" "</span>&lt;&lt;y&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">myfunc(<span class="number">10</span>,<span class="string">"hao"</span>);</span><br><span class="line">myfunc(<span class="number">0.123</span>,<span class="number">10L</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）在template语句与函数模板定义语句之间不允许有别的语句。</p><p>（3）同一般函数一样，函数模板也可以重载。</p><p>（4）函数模板与同名的非模板函数可以重载。在这种情况下，调用的顺序是：首先寻找一个参数完全匹配的废模板函数，如果找到了就调用它；若是没有找到，则寻找函数模板，将其实例化，产生一个匹配的模板函数，若找到了，就是用它。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;所谓模板函数，实际上是建立一个通用函数，其函数返回类型和形参类型不具体指定，用一个虚拟的类型来代表。这个通用函数就称为函数模板。在调用函数时系统会根据实参的类型（模板实参）来取代模板中虚拟类型从而实现了不同函数的功能。&lt;/p&gt;
&lt;figure class=&quot;highligh
      
    
    </summary>
    
      <category term="C++" scheme="https://codave.github.io/categories/C/"/>
    
    
      <category term="函数模板" scheme="https://codave.github.io/tags/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="模板函数" scheme="https://codave.github.io/tags/%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++语法16-虚函数</title>
    <link href="https://codave.github.io/2019/04/27/C++%E8%AF%AD%E6%B3%9516-%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    <id>https://codave.github.io/2019/04/27/C++语法16-虚函数/</id>
    <published>2019-04-27T12:27:05.000Z</published>
    <updated>2019-06-05T13:40:42.146Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>虚函数是重载的另一种表现形式。这是一种动态的重载方式，它提供了一种更为灵活的运行时的多态性机制。虚函数允许函数调用与函数体之间的联系在运行时才建立，也就是在运行时才决定如何动作，即所谓的<strong>动态联编</strong>。</p></blockquote><h1 id="1-虚函数的定义"><a href="#1-虚函数的定义" class="headerlink" title="1. 虚函数的定义"></a>1. 虚函数的定义</h1><p>虚函数就是在基类中被关键字virtual说明，并在派生类中重新定义的函数。虚函数的作用是允许在派生类中重新定义与基类同名的函数，并且可以通过基类指针或引用来访问基类和派生类中的同名函数。</p><p>虚基类的定义是在基类中进行的，它是在基类中需要定义为虚函数的成员函数的声明中冠以关键字virtual。定义虚基类的方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> 函数类型 函数名（形参表）&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在基类中的某个成员函数被声明为虚函数后，此虚函数就可以在一个或多个派生类中被重新定义。在派生类中重新定义时，其函数原型，包括函数类型、函数名、参数个数、参数类型的顺序，都必须与基类中的原型完全相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">虚函数的使用</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B0</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span>* p)</span></span>&#123;<span class="comment">//定义虚函数print</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="string">"print()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span>:</span><span class="keyword">public</span> B0&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span>* p)</span></span>&#123;<span class="comment">//重新定义虚函数print</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="string">"print()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span>:</span><span class="keyword">public</span> B1&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span>* p)</span></span>&#123;<span class="comment">//重新定义虚函数print</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="string">"print()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;；</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">B0 ob0,*op;</span><br><span class="line">op=&amp;ob0; op-&gt;print(<span class="string">"B0::"</span>);</span><br><span class="line">B1 ob1;</span><br><span class="line">op=&amp;ob1; op-&gt;print(<span class="string">"B1::"</span>);</span><br><span class="line">B2 ob2;</span><br><span class="line">op=&amp;ob2;op-&gt;print(<span class="string">"B2::"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p>（1）若在基类中，只声明虚函数原型（需加上virtual），而在类外定义虚函数时，则不必再加virtual。</p><p>（2）在派生类中，虚函数被重新定义时，其函数的原型与基类中的函数原型（即包括函数类型、函数名、参数个数、参数类型、参数类型的顺序）都必须完全相同。</p><p>（3）C++规定，当一个成员函数被定义为虚函数后，其派生类中符合重新定义虚函数要求的同名函数都自动成为虚函数。因此，在派生类中重新定义该虚函数时，关键字virtual可以写也可以不写。但是，为了使程序更加清晰，最好在每一层派生类中定义该函数时都加上关键字virtual。</p><p>（4）如果在派生类中没有对基类的虚函数重新定义，则公有派生类继承其直接基类的虚函数。一个虚函数无论继承多少次，它仍然保持其虚函数的特性。</p><p>（5）虚函数必须是其所在类的成员函数，而不能是友元函数，也不能是静态成员函数，因为虚函数调用要靠特定的对象来决定该激活哪个函数。</p><p>（6）虽然使用对象名和点运算符的方式也可以调用虚函数，但是这种调用是在编译时进行的，是静态联编，它没有利用虚函数的特性。<strong>只有通过基类的指针访问虚函数时才能获得运行的多态性。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">使用对象名和点运算符的方式调用虚函数。</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B0</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span>* p)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="string">"print()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B1</span>:</span><span class="keyword">public</span> B0&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span>* p)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="string">"print()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B2</span>:</span><span class="keyword">public</span> B1&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">char</span>* p)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;p&lt;&lt;<span class="string">"print()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    B0 ob0;</span><br><span class="line">    ob0.print(<span class="string">"B0::"</span>);</span><br><span class="line">    B1 ob1;</span><br><span class="line">    ob1.print(<span class="string">"B1::"</span>);</span><br><span class="line">    B2 ob2;</span><br><span class="line">    ob2.print(<span class="string">"B2::"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-虚析构函数"><a href="#2-虚析构函数" class="headerlink" title="2. 虚析构函数"></a>2. 虚析构函数</h1><p>在C++中，不能声明虚析构函数，但是可以声明虚析构函数，之前介绍过，当派生类对象撤销时，一般先调用派生类的析构函数，然后再调用基类的析构函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;虚函数是重载的另一种表现形式。这是一种动态的重载方式，它提供了一种更为灵活的运行时的多态性机制。虚函数允许函数调用与函数体之间的联系在运行时才建立，也就是在运行时才决定如何动作，即所谓的&lt;strong&gt;动态联编&lt;/strong&gt;。&lt;/p&gt;
&lt;/bl
      
    
    </summary>
    
      <category term="C++" scheme="https://codave.github.io/categories/C/"/>
    
    
      <category term="虚函数" scheme="https://codave.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++语法15-类型转换</title>
    <link href="https://codave.github.io/2019/04/27/C++%E8%AF%AD%E6%B3%9515-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>https://codave.github.io/2019/04/27/C++语法15-类型转换/</id>
    <published>2019-04-27T12:25:36.000Z</published>
    <updated>2019-06-05T13:54:06.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-系统预定义类型间的转换"><a href="#1-系统预定义类型间的转换" class="headerlink" title="1. 系统预定义类型间的转换"></a>1. 系统预定义类型间的转换</h1><blockquote><p>类型转换是将一种类型的值转换为另一种类型值。对于系统预定义的标准类型（如int、float、double、char等），C++提供两种类型转换方式：一种是隐式类型转换；另一种是显示类型转换。</p></blockquote><h1 id="1-1-隐式类型转换"><a href="#1-1-隐式类型转换" class="headerlink" title="1.1 隐式类型转换"></a>1.1 隐式类型转换</h1><p> 隐式类型转换主要遵循以下规则：</p><p>（1）在赋值表达式A=B的情况下，赋值运算符右端B的值需要转换为A类型进行赋值。</p><p>（2）当char或short类型变量与int类型变量进行运算时，将char或short类型转换成int类型。</p><p>（3）当两个操作对象类型不一致时，在算术运算前，级别低的类型自动转换为级别高的类型。</p><h1 id="1-2-显示类型转换"><a href="#1-2-显示类型转换" class="headerlink" title="1.2 显示类型转换"></a>1.2 显示类型转换</h1><p>编程人员在程序中可以明确地指出将一种数据类型转换成另一种指定的类型，这种转换成为显示类型转换。</p><h1 id="2-类类型与系统预定义类型间的转换"><a href="#2-类类型与系统预定义类型间的转换" class="headerlink" title="2. 类类型与系统预定义类型间的转换"></a>2. 类类型与系统预定义类型间的转换</h1><p>对于用户自己定义的类类型而言，如何实现它们与其他数据类型之间的转换呢？通常，可归纳为以下：<br>（1）通过转换<strong>构造函数</strong>进行类型转换。</p><p>（2）通过类型转换函数进行类型转换。</p><h1 id="2-1-转换构造函数"><a href="#2-1-转换构造函数" class="headerlink" title="2.1 转换构造函数"></a>2.1 转换构造函数</h1><blockquote><p>转换构造函数也是构造函数的一种，它具有类型转换的作用，它的作用是将一个其他类型的数据转换成它所在类的对象。</p></blockquote><p>通常，使用转换构造函数将一个指定的数据类型转换为类对象的方法如下：</p><p>（1）先声明一个类。</p><p>（2）在这个类中定义一个只有一个参数的构造函数，参数是待转换类型的数据，在函数体中指定转换的方法。</p><p>（3）可以用以下形式进行类型转换。</p><p>&#160;&#160;<strong>类名（待转换类型的数据）</strong></p><p><strong>说明：</strong></p><p>（1）转换构造函数也是一种构造函数，它遵循构造函数的一般规则。转换构造函数只有一个参数，作用是将一个其他类型的数据转换它所在类的对象。但是，有一个参数的构造函数不一定是转换构造函数，它可以是普通的构造函数，仅仅起对象初始化的作用。</p><p>（2）转换构造函数不仅可以将一个系统预定义的标准类型数据转换成类的对象，也可以将另一个类的对象转换成构造函数所在的类对象。（不做详解）</p><h1 id="2-2-类型转换函数"><a href="#2-2-类型转换函数" class="headerlink" title="2.2 类型转换函数"></a>2.2 类型转换函数</h1><p>通过转换构造函数可以将一个指定类型的数据转换为类的对象。但是不能反过来将一个类的对象转换成其他类型的数据，例如不能将一个Complex类的对象转换成double类型的数据。为此，C++提供了一个称为类型转换函数的函数来解决这个转换问题。类型转换的作用就是将一个类的对象转换成另一类型的数据。在类中，定义类型转换函数的一般格式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">operator</span> 目标类型（）&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，目标类型为希望转换成的类型名，它既可以是预定义的标准函数也可以是其他类的类型。类型转换函数的函数名为“operator 目标类型”，在函数名前面不能指定函数类型，也不能有参数。通常，其函数体的最后一条语句是return语句，返回值的类型是该函数的目标函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型转换的应用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> namespaace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Complex(<span class="keyword">double</span> r=<span class="number">0</span>,<span class="keyword">double</span> i=<span class="number">0</span>)&#123;</span><br><span class="line">        real=r;</span><br><span class="line">        imag=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> real;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> real,imag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">Complex <span class="title">com</span><span class="params">(<span class="number">2.2</span>,<span class="number">4.4</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Complex类的对象com转换成double型的数据为："</span>；</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">double</span>(com)&lt;&lt;<span class="built_in">endl</span>；</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于类型转换函数，有以下几点注意事项：</p><p>（1）类型转换函数只能定义为一个类的成员函数而不能定义为类的友元函数。类型转换函数也可以在类体中声明函数原型，而将函数体定义在类的外部。</p><p>（2）类型转换函数既没有参数，也不能在函数名前面指定函数类型。</p><p>（3）类型函数中必须有return语句，即必须送回目标类型的数据作为函数的返回值。</p><p>（4）一个类可以定义多个类型转换函数。C++编译器将根据类型转换函数名自动地选择一个合适的类型转换函数予以调用。</p><h1 id="2-3-转换构造函数和类型转换函数的综合应用"><a href="#2-3-转换构造函数和类型转换函数的综合应用" class="headerlink" title="2.3 转换构造函数和类型转换函数的综合应用"></a>2.3 转换构造函数和类型转换函数的综合应用</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Complex()&#123;&#125;<span class="comment">//不带参数的构造函数</span></span><br><span class="line">        Complex(<span class="keyword">int</span> r,<span class="keyword">int</span> i)&#123;<span class="comment">//带两个参数的构造函数</span></span><br><span class="line">real=r;imag=i;</span><br><span class="line">        &#125;</span><br><span class="line">        Complex（<span class="keyword">int</span> x)&#123;<span class="comment">//转换构造函数，将int类型</span></span><br><span class="line">real=imag=i/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> real+imag;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"real:"</span>&lt;&lt;real&lt;&lt;<span class="string">"\t"</span>&lt;&lt;<span class="string">"imag:"</span>&lt;&lt;imag&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> real,imag;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Complex a1(1,2),a2(3,4);</span><br><span class="line">    Complex a3;</span><br><span class="line">    a3=a1+a2;</span><br><span class="line">    a3.print();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析这个程序，读者一定会感到奇怪，类Complex中有没有定义将两个对象相加的运算符重载函数，怎么还可以进行“a1+a2”的操作呢 ？这是由于C++自动进行隐式转换的缘故。这个自动进行类型转换过程的步骤如下：</p><p>（1）寻找两个Complex类对象相加的运算符重载函数，程序中未找到。</p><p>（2）寻找能将Complex类的对象转换成int型数据的类型转换函数operator int()，程序中找到。于是调用其分别将 对象a1和a2隐式转换成int类型的数据3和7。</p><p>（3）寻找将两个整数相加的运算符函数，这个运算符函数已经在C++系统中预定义。于是调用这个运算符函数将两个int类型的数据3和7相加得到10。</p><p>（4）由于语句“a3=a1+a2;”的赋值号左边是Complex类的对象a3,而右边是int类型数据10，于是隐式调用转换构造函数将int类型数10转换成Complex类的一个临时对象（其real和image都是5），然后将这个临时对象的值赋给Complex类对象a3，执行结果是对象a3的real和image也分别是5。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-系统预定义类型间的转换&quot;&gt;&lt;a href=&quot;#1-系统预定义类型间的转换&quot; class=&quot;headerlink&quot; title=&quot;1. 系统预定义类型间的转换&quot;&gt;&lt;/a&gt;1. 系统预定义类型间的转换&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;类型转换是将一种类型的
      
    
    </summary>
    
      <category term="C++" scheme="https://codave.github.io/categories/C/"/>
    
    
      <category term="转换构造函数" scheme="https://codave.github.io/tags/%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="类型转换函数" scheme="https://codave.github.io/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++语法14-运算符重载</title>
    <link href="https://codave.github.io/2019/04/26/C++%E8%AF%AD%E6%B3%9514-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    <id>https://codave.github.io/2019/04/26/C++语法14-运算符重载/</id>
    <published>2019-04-26T09:02:50.000Z</published>
    <updated>2019-06-05T13:53:34.265Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在C++中，除了可以对函数重载外，还可以对大多数运算符实施重载。运算符重载与函数重载相比，稍微复杂一点。运算符重载是通过创建运算符重载函数来实现的。<strong>运算符重载函数可以是在类外定义的普通函数，也可以是类的成员函数或友元函数。</strong></p></blockquote><h1 id="1-在类外定义的运算符重载函数"><a href="#1-在类外定义的运算符重载函数" class="headerlink" title="1. 在类外定义的运算符重载函数"></a>1. 在类外定义的运算符重载函数</h1><p>C++为运算符重载提供了一种方法，即在进行运算符重载时，必须定义一个运算符重载函数，其名字为operator，后随一个要重载的运算符。例如，要重载“+”号，应该写一个名字为operator的函数。其他的运算符重载函数也应该以同样的方式命名。</p><p>C++语言对运算符重载制定了一些规则：</p><p>（1）C++中绝大部分的运算符允许重载，不能重载的运算符只有以下几个：</p><ul><li><strong>.</strong>    成员访问运算符</li><li><strong>.*</strong>     成员指针访问运算符</li><li><strong>::</strong>      作用域运算符</li><li><strong>Sizeof</strong>     长度运算符</li><li><strong>？:</strong>       条件运算符</li></ul><p>（2）C++语言中只能对已有的C++运算符进行重载，不允许用户自己定义新的运算符。例如，虽然某些程序语言将“*<em>”作为指数运算符，但是C++语言编程时不能重载“ </em>  <em> “，因为” </em>  * “不是C++运算符。</p><p>（3）重载不能改变运算符的操作对象（即操作数）的个数。</p><p>（4）重载不能改变运算符原有的优先顺序。</p><p>（5）重载不能改变运算符原有的结合特性。</p><p>（7）运算符重载的参数至少应有一个是类对象（或类对象的引用）。也就是说，运算符重载函数的参数不能全部是C++标准型。（<strong>这项规定的目的是，防止用户修改用于标准类型数据的运算符性质</strong>）</p><p>（8）运算符重载函数可以是普通函数，也可以是类的成员函数，还可以是类的友元函数。</p><p>（9）一般而言，用于类对象的运算符必须重载，但是赋值运算符“ = ”例外，不必用户进行重载。通常情况下，赋值运算符“ = ”可用于同类对象之间的相互赋值。</p><h1 id="2-友元运算符重载函数"><a href="#2-友元运算符重载函数" class="headerlink" title="2. 友元运算符重载函数"></a>2. 友元运算符重载函数</h1><p>运算符重载是通过创建运算符重载函数来实现的，运算符重载函数定义了重载的运算符将要进行的操作。如果运算符重载函数是在类的外部定义的普通函数，这个运算符重载函数只能访问类中的公有数据成员，而不能访问类的私有成员。实际上，类中的数据成员常常是私有成员或保护成员，为此运算符重载函数一般采用如下两种形式定义：一是定义为它将要操作的类的成员函数（简称为成员运算符重载函数）；二是定义为类的友元函数（简称为友元运算符重载函数）。</p><h1 id="2-1-定义友元运算符重载函数的语法形式"><a href="#2-1-定义友元运算符重载函数的语法形式" class="headerlink" title="2.1 定义友元运算符重载函数的语法形式"></a>2.1 定义友元运算符重载函数的语法形式</h1><p>（1）在类的内部，定义友元运算符重载函数的格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> 函数类型 <span class="keyword">operator</span>运算符（形参表）&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）友元运算符重载函数也可以在类中声明友元函数的原型，在类外定义。</p><p>在类中，声明友元运算符重载函数原型的格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">friend</span>   函数类型   <span class="keyword">operator</span>运算符（形参表）；</span><br><span class="line">...</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>在类外，定义友元运算符重载函数的格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数类型 <span class="keyword">operator</span>运算符（形参表）&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：由于友元运算符重载函数不是该类的成员函数，所以在类外定义时不需要缀上类名。</p><h1 id="2-2-双目运算符重载"><a href="#2-2-双目运算符重载" class="headerlink" title="2.2 双目运算符重载"></a>2.2 双目运算符重载</h1><p>双目运算符（或称二元运算符）有两个操作数，通常在运算符的左右两侧。当用友元函数重载双目运算符时，两个操作数都要传递给运算符重载函数。</p><p>一般而言，如果在类X中采用友元函数重载双目运算符@，而aa和bb是类X的两个对象，则以下两种函数调用方法是等价的：</p><p><strong>aa@bb;</strong>        //隐式调用</p><p><strong>operator@(aa,bb);</strong>        //显示调用</p><p>说明：</p><p>（1）有时，在函数返回的时候，可以直接用类的构造函数来生成一个临时对象，而不用对该对象进行命名。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Complex  <span class="keyword">operator</span>+(Complex&amp; a,Complex&amp; b)&#123;</span><br><span class="line">    Complex temp;</span><br><span class="line">    temp.real=a.real+b.real;</span><br><span class="line">    temp.real=a.imag+b.imag;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line">改为</span><br><span class="line">Complex <span class="keyword">operator</span>+(Complex&amp; a,Complex&amp; b)&#123;</span><br><span class="line"><span class="keyword">return</span> Complex(a.real+b.real,a.imag+b.imag);  <span class="comment">//此处建立了一个临时对象，它没有对象名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-3-单目运算重载符"><a href="#2-3-单目运算重载符" class="headerlink" title="2.3 单目运算重载符"></a>2.3 单目运算重载符</h1><p>单目运算符只有一个操作数，如-a、&amp;b、!c、++p等。重载单目运算符的方法与重载双目运算符的方法是类似的。用友元函数重载单目运算符时，需要一个显示的操作数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coord</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Coord(<span class="keyword">int</span> i=<span class="number">0</span>,<span class="keyword">int</span> j=<span class="number">0</span>)&#123;</span><br><span class="line">            x=i;</span><br><span class="line">            y=j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"x:"</span>&lt;&lt;x&lt;&lt;<span class="string">",y: "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">friend</span> Coord <span class="keyword">operator</span>++(Coord &amp;op)&#123;</span><br><span class="line">            ++op.x;</span><br><span class="line">            ++op.y;</span><br><span class="line">            <span class="keyword">return</span> op;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Coord <span class="title">ob</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">    ob.print();</span><br><span class="line">    ++ob;</span><br><span class="line">    ob.print();</span><br><span class="line">    <span class="keyword">operator</span>++ (ob);</span><br><span class="line">    ob.print();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">程序运行结果：</span><br><span class="line">x:<span class="number">10</span>, y:<span class="number">20</span></span><br><span class="line">x:<span class="number">11</span>, y:<span class="number">21</span></span><br><span class="line">x:<span class="number">12</span>, y:<span class="number">22</span></span><br></pre></td></tr></table></figure><p>注意：</p><p>使用友元函数重载单目运算符“++”时，采用对象引用参数传递操作数，如果采用对象传递操作数，结果是不正确的。是因为形参是对象时，是通过传值的方法传递参数的，函数体内对形参op的所有修改都无法传到函数体外。</p><p>一般而言，如果在类X中采用友元函数重载单目运算符@，而aa是类X的对象，则以下两种函数调用方法是等价的：</p><p><strong>@aa；</strong>        //隐式调用</p><p><strong>operator@(aa);</strong>        //显示调用</p><p>说明：</p><p>（1）运算符重载函数operator@可以返回任何类型，甚至可以是void类型，但通常返回类型与它所操作的类的类型相同，这样可以使重载运算符用在复杂的表达式中。</p><p>（2）有的运算符不能定义为友元运算符重载函数，如赋值运算符“=”、下标运算符“[ ]”、函数调用运算符“()”等。</p><h1 id="3-成员运算符重载函数"><a href="#3-成员运算符重载函数" class="headerlink" title="3. 成员运算符重载函数"></a>3. 成员运算符重载函数</h1><blockquote><p>在C++中，可以把运算符重载函数定义成某个类的成员函数，称为成员运算符重载函数。</p></blockquote><h1 id="3-1-定义成员运算符重载函数的语法形式"><a href="#3-1-定义成员运算符重载函数的语法形式" class="headerlink" title="3.1 定义成员运算符重载函数的语法形式"></a>3.1 定义成员运算符重载函数的语法形式</h1><p>（1）在类的内部，定义成员运算符重载函数的格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数类型 <span class="keyword">operator</span> 运算符（形参表）&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）成员运算符重载函数也可以在类中声明成员函数的原型，在类外定义。</p><p>在类的内部，声明成员运算符重载函数原型的格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">函数类型  <span class="keyword">operator</span>运算符（形参表）；</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>在类外，定义成员函数运算符重载函数的格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数类型 X::<span class="keyword">operator</span>运算符（形参表）&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：由于成员运算符重载函数是该类的成员函数，所以在类外定义时需要缀上类名。</p><h1 id="3-2-双目运算符重载"><a href="#3-2-双目运算符重载" class="headerlink" title="3.2 双目运算符重载"></a>3.2 双目运算符重载</h1><p> 对双目运算符而言，成员运算符重载函数的形参表中仅有一个参数，它作为运算符的右操作数。另一个操作数（左操作数）是隐含的，是该类的当前对象，它是通过this指针隐含地传递给函数的。</p><p>一般而言，如果在类X中采用成员函数重载双目运算符@，成员运算符函数operator@所需的一个操作数由对象aa通过this指针隐含地传递，它的另一个操作数bb在参数表中显示，则以下两种函数调用方法是等价的：</p><p><strong>aa@bb;</strong>        //隐式调用</p><p><strong>aa.operator@(bb);</strong>    //显示调用</p><h1 id="3-3-单目运算符重载"><a href="#3-3-单目运算符重载" class="headerlink" title="3.3 单目运算符重载"></a>3.3 单目运算符重载</h1><p>对单目运算符而言，成员运算符重载函数的参数表中没有参数，此时当前对象作为运算符的一个操作数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coord</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Coord(<span class="keyword">int</span> i=<span class="number">0</span>,<span class="keyword">int</span> j=<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    Coord <span class="keyword">operator</span>++();</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line">Coord::Coord(<span class="keyword">int</span> i,<span class="keyword">int</span> j)&#123;</span><br><span class="line">    x=i;</span><br><span class="line">    y=j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Coord::print()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"x: "</span>&lt;&lt; x &lt;&lt; ,y: <span class="string">"&lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">Coord Coord::operator++()&#123;</span></span><br><span class="line"><span class="string">    ++x;</span></span><br><span class="line"><span class="string">    ++y;</span></span><br><span class="line"><span class="string">    return *this;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">int mian()&#123;</span></span><br><span class="line"><span class="string">    Coord ob(10,20);</span></span><br><span class="line"><span class="string">    ob.print();</span></span><br><span class="line"><span class="string">    ++ob;//隐式调用运算符重载函数operator++</span></span><br><span class="line"><span class="string">    ob.print();</span></span><br><span class="line"><span class="string">    ob.operator++();//显示调用运算符重载函数operator++</span></span><br><span class="line"><span class="string">    ob.print();</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>由于this指针是指向当前对象的指针，因此语句“return *this；”返回的是当前对象的值，即调用运算符重载函数operator++的对象ob的值。</p><p>不难看出，对类Coord重载了运算符“++”后，对类对象的加1操作变得非常方便，就像对整型数进行加1操作一样。</p><h1 id="4-成员运算符重载函数与友元运算符重载函数的比较"><a href="#4-成员运算符重载函数与友元运算符重载函数的比较" class="headerlink" title="4. 成员运算符重载函数与友元运算符重载函数的比较"></a>4. 成员运算符重载函数与友元运算符重载函数的比较</h1><p>（1）对双目运算符而言，成员运算符重载函数参数表中含有一个参数，而友元运算符重载函数参数表中有两个参数；对单目运算符而言，成员运算符函数重载函数参数表中没有参数，而友元运算符重载函数参数表中有一个参数。</p><p>（2）双目运算符一般可以被重载为友元运算符重载函数或成员运算符重载函数，但有一种情况，必须使用友元函数。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如，如果将一个复数与一个整数相加，可用成员运算符函数重载“+”运算符</span><br></pre></td></tr></table></figure><p>（3）成员运算符函数和友元运算符函数都可以用习惯方式调用，也可以用它们专用的方式调用。</p><table><thead><tr><th>习惯调用形式</th><th>友元运算符重载函数调用形式</th><th>成员运算符重载函数调用形式</th></tr></thead><tbody><tr><td>a+b</td><td>operator+(a,b)</td><td>a.operator+(b)</td></tr><tr><td>-a</td><td>operator-(a)</td><td>a.operator-( )</td></tr><tr><td>a++</td><td>operator++(a,0)</td><td>a.operator++(0)</td></tr></tbody></table><p>（4）C++的大部分运算符既可以说明为成员运算符重载函数，又可以说明为友元运算符重载函数。究竟选择哪一种运算符函数好一些，没有定论，这主要取决于实际情况和程序员的习惯。</p><p>一般而言，对于双目运算符，将它重载为友元运算符重载函数比重载为成员运算符重载函数便于使用。对于单目运算符，则选择成员运算符函数较好。如果运算符所需的操作数（尤其是第一个操作数）希望有隐式类型转换，则运算符重载函数必须用友元函数，而不能用成员函数。</p><p>以下的经验可供参考：</p><ul><li>对于单目运算符，建议选择成员函数；</li><li>对于运算符“=、( )、[ ]、-&gt;、”只能作为成员函数；</li><li>对于运算符“+=、-=、/=、*=、&amp;=、!=、~=、%=、&lt;&lt;=、&gt;&gt;=”，建议重载为成员函数；</li><li>对于其他运算符，建议重载为友元函数。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在C++中，除了可以对函数重载外，还可以对大多数运算符实施重载。运算符重载与函数重载相比，稍微复杂一点。运算符重载是通过创建运算符重载函数来实现的。&lt;strong&gt;运算符重载函数可以是在类外定义的普通函数，也可以是类的成员函数或友元函数。&lt;/str
      
    
    </summary>
    
      <category term="C++" scheme="https://codave.github.io/categories/C/"/>
    
    
      <category term="运算符重载" scheme="https://codave.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>C++语法13-基类与派生类对象之间的赋值兼容关系</title>
    <link href="https://codave.github.io/2019/04/26/C++%E8%AF%AD%E6%B3%9513-%E5%9F%BA%E7%B1%BB%E4%B8%8E%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B5%8B%E5%80%BC%E5%85%BC%E5%AE%B9%E5%85%B3%E7%B3%BB/"/>
    <id>https://codave.github.io/2019/04/26/C++语法13-基类与派生类对象之间的赋值兼容关系/</id>
    <published>2019-04-26T07:16:25.000Z</published>
    <updated>2019-04-26T09:00:08.242Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在一定条件下，不同类型的数据之间可以进行类型转换，例如可以将整型数据赋给双精度型变量。在赋值之前，先把整型数据转换成为双精度型数据，然后再把它赋给双精度变量。这种不同类型数据之间的自动转换和赋值，称为赋值兼容。在基类和派生类对象之间也存在赋值兼容关系，基类和派生类对象之间的赋值兼容规则是指在需要基类对象的任何地方，都可以使用公有派生类的对象来替代。</p></blockquote><p>通过前面的学习我们知道，通过公有继承，派生类保留了基类中构造函数、析构函数之外的所有成员，基类的公有或保护成员的访问权限在派生类中全部按原样保留了下来，在派生类外可以调用基类的公有成员函数访问基类的私有成员。因此，公有派生类具有基类的全部功能，凡是基类能够实现的功能，公有派生类都能实现。我们可以将派生类对象的值赋给基类对象，在用到基类对象的时候可以用其子对象代替。</p><p>根据赋值兼容规则，在基类Base的对象可以使用的任何地方，都可以使用派生类Derived的对象来替代，但只能使用从基类继承来的成员。具体表现在以下几个方面：</p><p>（1）派生类对象可以向基类对象赋值，即用派生类对象中从基类继承过来的数据成员，逐个赋值给基类对象的数据成员。</p><p>（2）派生类对象可以初始化基类对象的引用。</p><p>​    <strong>Base b;</strong>        //定义基类Base的对象b</p><p>​    <strong>Derived d;</strong>    //定义基类Base的公有派生类Derived的对象b</p><p>​    <strong>Base &amp;br=d;</strong>        //定义基类Base的对象的引用br，并用派生类Derived的对象d对其初始化</p><p>（3）派生类对象的地址可以赋给指向基类对象的指针。</p><p>​    <strong>Derived d;</strong></p><p>​    <strong>Base  *bp = &d;</strong></p><p>（4）如果函数的形参是基类对象或基类对象的引用，在调用函数时可以用派生类对象作为实参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">class <span class="title">fun</span><span class="params">(Base &amp;bb)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;bb.i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">在调用函数fun时可以用派生类Derived的对象d4作为实参：</span><br><span class="line">fun(d4);</span><br></pre></td></tr></table></figure><p>下面是一个使用赋值兼容规则的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    Base(<span class="keyword">int</span> x)&#123;</span><br><span class="line">        i=x;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base"</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> x):Base(x)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(Base &amp;bb)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;bb.i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">Base <span class="title">b1</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    b1.show();</span><br><span class="line">    <span class="function">Derived <span class="title">d1</span><span class="params">(<span class="number">11</span>)</span></span>;</span><br><span class="line">    b1=d1;<span class="comment">//用派生类对象d1给基类对象b1赋值</span></span><br><span class="line">    b1.show();</span><br><span class="line">    <span class="function">Derived <span class="title">d2</span><span class="params">(<span class="number">22</span>)</span></span>;<span class="comment">//用派生类对象d2来初始化基类对象的引用b2</span></span><br><span class="line">    Base &amp;b2=d2;</span><br><span class="line">    b2.show();</span><br><span class="line">    <span class="function">Derived <span class="title">d3</span><span class="params">(<span class="number">33</span>)</span></span>;</span><br><span class="line">    Base *b3=&amp;d3;<span class="comment">//把派生类对象的地址赋值给指向基类的指针b3</span></span><br><span class="line">    b3-&gt;show();</span><br><span class="line">    <span class="function">Derived <span class="title">d4</span><span class="params">(<span class="number">44</span>)</span></span>;</span><br><span class="line">    fun(d4);<span class="comment">//派生类的对象d4作为函数fun的实参</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p>（1）声明为指向基类对象的指针可以指向它的公有派生的对象，但不允许指向它的私有派生的对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">private</span> Base&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Base op1,*ptr;<span class="comment">//定义基类Base的对象op1及指向基类Base的指针ptr</span></span><br><span class="line">    Derive op2;<span class="comment">//定义派生类Derived的对象op2</span></span><br><span class="line">    ptr=&amp;op1;<span class="comment">//将指针ptr指向基类对象op1</span></span><br><span class="line">    ptr=&amp;op2;<span class="comment">//错误，不允许将指向基类的Base的指针ptr指向它的私有派生类对象op2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）允许将一个声明为指向基类的指针指向其公有派生类的对象，但是不能将一个声明为指向派生类对象的指针指向其基类的一个对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Base obj1;<span class="comment">//定义基类对象obj1</span></span><br><span class="line">    Derive obj2,*ptr;<span class="comment">//定义派生类对象obj2及指向派生类的指针ptr</span></span><br><span class="line">    ptr=&amp;obj2;<span class="comment">//将指向派生类对象的指针ptr指向派生类对象ptr</span></span><br><span class="line">    ptr=&amp;obj1;<span class="comment">//错误，试图将指向派生类对象的指针ptr指向其基类对象obj1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在一定条件下，不同类型的数据之间可以进行类型转换，例如可以将整型数据赋给双精度型变量。在赋值之前，先把整型数据转换成为双精度型数据，然后再把它赋给双精度变量。这种不同类型数据之间的自动转换和赋值，称为赋值兼容。在基类和派生类对象之间也存在赋值兼容关
      
    
    </summary>
    
      <category term="C++" scheme="https://codave.github.io/categories/C/"/>
    
    
      <category term="-赋值兼容" scheme="https://codave.github.io/tags/%E8%B5%8B%E5%80%BC%E5%85%BC%E5%AE%B9/"/>
    
  </entry>
  
  <entry>
    <title>C++语法12-多重继承</title>
    <link href="https://codave.github.io/2019/04/25/C++%E8%AF%AD%E6%B3%9512-%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/"/>
    <id>https://codave.github.io/2019/04/25/C++语法12-多重继承/</id>
    <published>2019-04-25T08:41:09.000Z</published>
    <updated>2019-06-05T13:47:52.761Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>派生类只有一个基类，这种派生方法称为单继承或单基派生。当一个派生类具有两个或多个基类时，这种派生方法称为多重继承或多基派生。</p></blockquote><h1 id="1-多重继承派生类的声明"><a href="#1-多重继承派生类的声明" class="headerlink" title="1. 多重继承派生类的声明"></a>1. 多重继承派生类的声明</h1><p>在C++中，声明具有两个以上基类的派生类与声明单基派生类的形式相似，只需将要继承的多个基类用逗号分隔即可，其声明的一般形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 派生类名：继承方式1 基类名1，...... ，继承方式<span class="title">n</span> 基类名<span class="title">n</span>&#123;</span></span><br><span class="line">派生类新增的数据成员和成员函数</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>注意：对基类成员的访问必须是无二义性的，例如下列程序段对基类成员的访问是二义性的，必须想办法消除二义性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">clas X&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span>:</span><span class="keyword">public</span> X,<span class="keyword">public</span> Y&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果定义类Z的对象obj：</p><p>Z  obj;</p><p>则以下对函数f()的访问是二义性的：</p><p>obj.f();            //二义性错误，不知调用的是类X的f(),还是类Y的f()</p><p>使用成员名限定可以消除二义性，例如：</p><p>obj.X::f();        //调用类X的f()</p><p>obj.Y::f();            //调用类Y的f()</p><h1 id="2-多重继承派生类的构造函数与析构函数"><a href="#2-多重继承派生类的构造函数与析构函数" class="headerlink" title="2. 多重继承派生类的构造函数与析构函数"></a>2. 多重继承派生类的构造函数与析构函数</h1><p>多重继承下派生类构造函数的定义形式与单继承派生类构造函数的定义形式相似，只是n个基类的构造函数之间用逗号分隔。多重继承下派生类构造函数定义的一般形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">派生类名（参数总表）：基类名<span class="number">1</span>（参数表<span class="number">1</span>），基类名<span class="number">2</span>（参数表<span class="number">2</span>），...... , 基类名n（参数名n）&#123;</span><br><span class="line">派生类新增成员的初始化语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>派生类的参数个数必须包含完成所有基类初始化所需的参数个数。</p><p>多重继承的构造函数的执行顺序与单继承构造函数的执行顺序相同，也是遵循先执行基类的构造函数，再执行对象成员的构造函数，最后执行派生类构造函数的原则。在多个基类之间，则严格按照派生类声明时从左向右的顺序来排列先后。</p><p>由于析构函数是不带参数的，在派生类中是否要定义析构函数与它所属的基类无关，所以与单继承情况类似，基类的析构函数不会因为派生类没有析构函数而得不到执行，他们各自是独立的。析构函数和构造函数的执行顺序正好是相反的。</p><h1 id="3-虚基类"><a href="#3-虚基类" class="headerlink" title="3. 虚基类"></a>3. 虚基类</h1><p>如果一个类有多个直接基类，而这些直接基类又有一个共同的基类，则在最低层的派生类中会保留这个间接的共同基类数据成员的多份同名成员。在访问这些同名的成员时，必须在派生类对象名后面增加直接基类名，使其惟一的标识一个成员，以免产生二义性。</p><h1 id="3-1-虚基类的概念"><a href="#3-1-虚基类的概念" class="headerlink" title="3.1 虚基类的概念"></a>3.1 虚基类的概念</h1><p>在C++中，如果想使这个公共的基类只产生一个复制，则可以将这个基类说明成虚基类。这就要求从类 Base派生新类时，使用关键字virtual将类Base说明成虚基类。</p><p>虚基类在派生类中的声明，其语法形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class 派生类名：<span class="keyword">virtual</span> 继承方式 基类名&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过这样的声明后，当基类通过多条派生路径被一个派生类继承时，该派生类只继承该基类一次，也就是说，基类成员只保留一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">虚基类的使用</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        a=<span class="number">5</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base a="</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//a=5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> b1;</span><br><span class="line">    Base1()&#123;</span><br><span class="line">        a=a+<span class="number">10</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base1 a="</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//a=15</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> b2;</span><br><span class="line">    Base2()&#123;</span><br><span class="line">        a=a+<span class="number">20</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Base2 a="</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//a=35</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base1,<span class="keyword">public</span> Base2&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">    Derived()&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Derived a="</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;   <span class="comment">//a=35</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Derived obj;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-2-虚基类的初始化"><a href="#3-2-虚基类的初始化" class="headerlink" title="3.2 虚基类的初始化"></a>3.2 虚基类的初始化</h1><p>虚基类的初始化与一般的多继承的初始化在语法上是一样的，但构造函数的调用顺序不同。在使用虚基类机制时应该注意一下几点：</p><p>（1）如果在虚基类中定义有带形参的构造函数，并且没有定义默认形式的构造函数，则整个继承结构中，所有直接或间接的派生类都必须在构造函数的成员初始化列表中列出对虚函数类构造函数的调用，以初始化在虚基类中定义的数据成员。</p><p>（2）建立一个对象时，如果这个对象中含有从虚基类继承来的成员，则虚基类的成员是由最远派生类的构造函数通过调用虚基类的构造函数进行初始化的。该派生类的其他基类对虚基类构造函数的调用都自动被忽略。</p><p>（3）若同一层次中同时包含虚基类和非虚基类，应先调用虚基类中的构造函数，再调用非虚基类的构造函数，最后调用派生类构造函数。</p><p>（4）对于多个虚基类，构造函数的执行顺序仍然是先左后右，自上而下。</p><p>（5）对于非虚基类，构造函数的执行顺序仍然是先左后右，自上而下。</p><p>（6）若虚基类由非虚基类派生而来，则仍然先调用基类构造函数，再调用派生类的构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">虚基类的派生类构造函数的执行顺序。</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Base(<span class="keyword">int</span> sa)&#123;</span><br><span class="line">            a=sa;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Coustructing Base"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base1</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Base1(<span class="keyword">int</span> sa,<span class="keyword">int</span> sb):Base(sa)&#123;</span><br><span class="line">            b=sb;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Constructing Base1"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Base2(<span class="keyword">int</span> sa,<span class="keyword">int</span> sc)&#123;</span><br><span class="line">            c=sc;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Constructing Base2"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base1,<span class="keyword">public</span> Base2&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Derived(<span class="keyword">int</span> sa,<span class="keyword">int</span> sb,<span class="keyword">int</span> sc,<span class="keyword">int</span> sd):</span><br><span class="line">        Base(sa),Base1(sa,sb),Base2(sa,sc)&#123;</span><br><span class="line">            d=sd;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Constructing Derived"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">obj</span><span class="params">(<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">程序运行结果：</span><br><span class="line">Coustructing Base</span><br><span class="line">Constructing Base1</span><br><span class="line">Constructing Base2</span><br><span class="line">Constructing Derived</span><br></pre></td></tr></table></figure><p>不难看出，上述程序中虚基类Base的构造函数只执行了一次。显然，当Derived的构造函数调用了虚基类Base的构造函数之后，类Base1和类Base2对Base构造函数的调用被忽略了。这也是初始化虚基类和初始化非虚基类不同的地方。</p><p>说明：</p><p>（1）关键字virtual与派生方式关键字（public或private）的先后顺序无关紧要，它只说明是“虚拟派生”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> Base&#123;</span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br><span class="line">这两个虚拟派生的声明是等价的。</span><br></pre></td></tr></table></figure><p>（2）一个基类在作为某些派生类虚基类的同时，又作为另一些派生类的非虚基类，这种情况是允许的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;派生类只有一个基类，这种派生方法称为单继承或单基派生。当一个派生类具有两个或多个基类时，这种派生方法称为多重继承或多基派生。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-多重继承派生类的声明&quot;&gt;&lt;a href=&quot;#1-多重继承派生类的声
      
    
    </summary>
    
      <category term="C++" scheme="https://codave.github.io/categories/C/"/>
    
    
      <category term="多重继承" scheme="https://codave.github.io/tags/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>C++语法11-调整基类成员在派生类中的访问属性的其他方法</title>
    <link href="https://codave.github.io/2019/04/24/C++%E8%AF%AD%E6%B3%9511-%E8%B0%83%E6%95%B4%E5%9F%BA%E7%B1%BB%E6%88%90%E5%91%98%E5%9C%A8%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%AD%E7%9A%84%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95/"/>
    <id>https://codave.github.io/2019/04/24/C++语法11-调整基类成员在派生类中的访问属性的其他方法/</id>
    <published>2019-04-24T13:27:03.000Z</published>
    <updated>2019-04-25T08:40:18.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-同名成员"><a href="#1-同名成员" class="headerlink" title="1. 同名成员"></a>1. 同名成员</h1><p>在定义派生类的时候，C++语言允许在派生类中说明的成员与基类中的成员名字相同，也就是说，派生类可以重新说明与基类成员同名的成员。如果在派生类中定义了与基类成员同名的成员，则称派生类成员覆盖了基类的同名成员，在派生类中使用这个名字意味着访问在派生类中重新说明的成员。为了在派生类中使用基类的同名成员，必须在该成员名之前加上基类名和作用域标示符”::”，即必须使用如下格式才能访问到基类的同名成员。</p><p><strong>基类名::成员名</strong></p><h1 id="2-访问声明"><a href="#2-访问声明" class="headerlink" title="2. 访问声明"></a>2. 访问声明</h1><p>我们已经知道，对于公有继承，基类的公有成员函数也就是派生类的公有成员函数，这意味着外界可以用派生类的对象调用基类的公有成员函数。但是对于私有继承，基类的公有成员函数变成了派生类的私有成员函数了。这是 外界就无法利用派生类的对象直接调用基类的成员函数，而只能通过调用派生类的成员函数（内含调用基类成员函数的语句）间接地调用基类的成员函数。</p><p>访问声明的方法就是把基类的保护成员或公有成员直接写至私有派生类定义式中的同名段中，同时给成员名前冠以基类名和作用域标示符 :: 。利用这种方法，该成员就成为派生类的保护类或公有成员了。</p><p>说明：</p><p>（1）数据成员也可以使用访问声明。</p><p>（2）访问声明中只含不带类型和参数的函数或变量名。</p><p>（3）访问声明不能改变成员在基类中的访问属性，也就是说，访问声明只能把原基类的保护成员调整为私有派生类的保护成员，把原基类的公有成员调整为私有派生类的公有成员。但是对基类的私有成员不能使用访问声明。</p><p>（4）对于基类中的重载函数名，访问声明将对基类中所有同名函数起作用。这意味着对于重载函数使用访问声明时要慎重。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-同名成员&quot;&gt;&lt;a href=&quot;#1-同名成员&quot; class=&quot;headerlink&quot; title=&quot;1. 同名成员&quot;&gt;&lt;/a&gt;1. 同名成员&lt;/h1&gt;&lt;p&gt;在定义派生类的时候，C++语言允许在派生类中说明的成员与基类中的成员名字相同，也就是说，派生类可以重新说
      
    
    </summary>
    
      <category term="C++" scheme="https://codave.github.io/categories/C/"/>
    
    
      <category term="同名成员" scheme="https://codave.github.io/tags/%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98/"/>
    
      <category term="访问声明" scheme="https://codave.github.io/tags/%E8%AE%BF%E9%97%AE%E5%A3%B0%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>C++语法10-派生类的构造和析构</title>
    <link href="https://codave.github.io/2019/04/22/C++%E8%AF%AD%E6%B3%9510-%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84/"/>
    <id>https://codave.github.io/2019/04/22/C++语法10-派生类的构造和析构/</id>
    <published>2019-04-22T04:54:34.000Z</published>
    <updated>2019-06-05T13:45:30.951Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>派生类继承了基类的成员，实现了原有代码的重用，这仅仅是引入继承的目的之一。引入继承的更主要的目的是代码的扩充，只有在派生类中通过添加新的成员，加入新的功能，类的派生才更有意义。<strong>但是基类的构造函数和析构函数不能被继承，在派生类中，如果对派生类新增的成员进行初始化，就需要加入派生类的构造函数。</strong>与此同时，对所有从基类继承下来的成员的初始化工作，还是由基类的构造函数完成的，但是我们必须在派生类中对基类的构造函数所需要的参数进行设置。同样，对撤销派生类对象时的扫尾、清理工作也需要加入新的析构函数来完成。</p></blockquote><h1 id="1-派生类构造函数和析构函数的执行顺序"><a href="#1-派生类构造函数和析构函数的执行顺序" class="headerlink" title="1. 派生类构造函数和析构函数的执行顺序"></a>1. 派生类构造函数和析构函数的执行顺序</h1><p>通常情况下，当创建派生类的对象时，首先执行基类的构造函数，随后再执行派生类的构造函数；当撤销派生类对象时，则先执行派生类的析构函数，随后再执行基类的析构函数。</p><h1 id="2-派生类构造函数和析构函数的构造规则"><a href="#2-派生类构造函数和析构函数的构造规则" class="headerlink" title="2. 派生类构造函数和析构函数的构造规则"></a>2. 派生类构造函数和析构函数的构造规则</h1><h1 id="2-1-简单的派生类的构造函数"><a href="#2-1-简单的派生类的构造函数" class="headerlink" title="2.1 简单的派生类的构造函数"></a>2.1 简单的派生类的构造函数</h1><p>当基类的构造函数没有参数，或没有显示定义构造函数时，派生类可以不向基类传递参数，甚至可以不定义构造函数。<strong>当基类含有带参数的构造函数时，派生类必须定义构造函数，以提供把参数传递给基类构造函数的途径。</strong></p><p>在C++中，派生类构造函数的一般格式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">派生类名（总参数表）：基类名（参数表）&#123;</span><br><span class="line">  </span><br><span class="line">    派生类新增数据成员的初始化语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的程序说明如何传递一个参数给派生类的构造函数和传递一个参数给基类的构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>&#123;</span><span class="comment">//声明基类Student</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Student(<span class="keyword">int</span> number1,<span class="built_in">string</span> name1,<span class="keyword">float</span> score1)&#123;<span class="comment">//基类构造函数</span></span><br><span class="line">            number=number1;</span><br><span class="line">            name=name1;</span><br><span class="line">            score=score1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"number:"</span>&lt;&lt;number&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"name:"</span>&lt;&lt;name&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"score:"</span>&lt;&lt;score&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="keyword">int</span> number;</span><br><span class="line">        <span class="built_in">string</span> name;</span><br><span class="line">        <span class="keyword">float</span> score;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UStudent</span>:</span><span class="keyword">public</span> Student&#123;<span class="comment">//声明公有派生类Ustudent</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        UStudent(<span class="keyword">int</span> number1,<span class="built_in">string</span> name1,<span class="keyword">float</span> score1,<span class="built_in">string</span> major1)</span><br><span class="line">        :Student(number1,name1,score1)<span class="comment">//定义派生类构造函数要加上调用的基类的构造函数及其参数</span></span><br><span class="line">        &#123;</span><br><span class="line">            major=major1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span></span>&#123;</span><br><span class="line">            print();</span><br><span class="line">            count&lt;&lt;<span class="string">"major:"</span>&lt;&lt;major&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>：</span><br><span class="line">        <span class="built_in">string</span> major;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    UStudent stu(22116,"张志"，95，"信息安全")；</span><br><span class="line">    stu.print();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p>（1）可以将派生类构造函数定义在类的外部，而在类体内只写该函数的声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UStudent(<span class="keyword">int</span> number1,<span class="built_in">string</span> name1,<span class="keyword">float</span> score1,<span class="built_in">string</span> major1);</span><br></pre></td></tr></table></figure><p>而在类的外部定义派生类的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UStudent::UStudent(<span class="keyword">int</span> number1,<span class="built_in">string</span> name1,<span class="keyword">float</span> score1,<span class="built_in">string</span> major1)</span><br><span class="line">:Student(number1,name1,score1)<span class="comment">//定义派生类构造函数要加上调用的基类的构造函数及其参数</span></span><br><span class="line">&#123;</span><br><span class="line">major=major1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：在类中声明派生类构造函数时，不包括基类构造函数名及其参数表(即Student(number1,name1,score1))，只在类外定义构造函数时才将它列出。</p><p>（2）若在类使用默认构造函数或不带参数的构造函数，则在派生类中定义构造函数时可略去”：基类名（参数表）”，此时若派生类不需要构造函数，则可不定义派生类构造函数。</p><p>（3）当基类构造函数不带参数时，派生类不一定需要定义构造函数，然后当基类的构造函数哪怕只带有一个参数，它所有的派生类都必须定义构造函数，甚至所定义的派生类构造函数的函数体可能为空，仅仅起参数的传递作用。</p><h1 id="2-2-派生类的析构函数"><a href="#2-2-派生类的析构函数" class="headerlink" title="2.2 派生类的析构函数"></a>2.2 派生类的析构函数</h1><blockquote><p>在派生类中可以根据需要定义自己的析构函数，用来对派生类中的所增加的成员进行清理工作。基类的清理工作仍然由基类的析构函数负责。由于析构函数是不带参数的，在派生系统中是否要自定义析构函数与它所属基类的析构函数无关。在执行派生类的析构函数时，系统会自动调用基类的析构函数，对基类的对象进行清理工作。</p></blockquote><h1 id="2-3-含有对象成员（子对象）的派生类的构造函数"><a href="#2-3-含有对象成员（子对象）的派生类的构造函数" class="headerlink" title="2.3 含有对象成员（子对象）的派生类的构造函数"></a>2.3 含有对象成员（子对象）的派生类的构造函数</h1><p>当派生类中含有内嵌的对象成员（也称子对象）时，其构造函数的一般形式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">派生类名（参数总表）：基类名（参数表<span class="number">0</span>），对象成员名<span class="number">1</span>（参数表<span class="number">1</span>），......，对象成员名n（参数表n）&#123;</span><br><span class="line">派生类新增成员的初始化语句；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在定义派生类对象时，构造函数的执行顺序如下：</p><ul><li>调用基类的构造函数，对基类数据成员初始化；</li><li>调用内嵌对象成员的构造函数，对内嵌对象成员的数据成员初始化；</li><li>执行派生类的构造函数体，对派生类数据成员初始化。</li></ul><p>撤销对象时，析构函数的调用顺序与构造函数的调用顺序正好相反。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Base(<span class="keyword">int</span> i)&#123;</span><br><span class="line">            x=i;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Constrcting base class\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ~Base()&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"Destructing base class\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"x="</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Derived(<span class="keyword">int</span> i):Base(i),d(i)<span class="comment">//缀上要调用的基类构造函数和对象成员构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Constructing derived class\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~Derived()&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"Destructing derived class\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    Base d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Derived <span class="title">obj</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    obj.show();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p>（1）在派生类中含有多个内嵌对象成员时，调用内嵌对象成员的构造函数顺序由它们在类中声明的顺序确定。</p><p>（2）如果派生类的基类也是一个派生类，每个派生类只需要负责其直接基类数据成员的初始化。依次上溯。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;派生类继承了基类的成员，实现了原有代码的重用，这仅仅是引入继承的目的之一。引入继承的更主要的目的是代码的扩充，只有在派生类中通过添加新的成员，加入新的功能，类的派生才更有意义。&lt;strong&gt;但是基类的构造函数和析构函数不能被继承，在派生类中，如果
      
    
    </summary>
    
      <category term="C++" scheme="https://codave.github.io/categories/C/"/>
    
    
      <category term="构造函数" scheme="https://codave.github.io/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="析构函数" scheme="https://codave.github.io/tags/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    
      <category term="派生类" scheme="https://codave.github.io/tags/%E6%B4%BE%E7%94%9F%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>C++语法09-派生类的概念</title>
    <link href="https://codave.github.io/2019/04/21/C++%E8%AF%AD%E6%B3%9509-%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
    <id>https://codave.github.io/2019/04/21/C++语法09-派生类的概念/</id>
    <published>2019-04-21T13:24:59.000Z</published>
    <updated>2019-04-22T04:50:41.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-派生类的声明"><a href="#1-派生类的声明" class="headerlink" title="1. 派生类的声明"></a>1. 派生类的声明</h1><p>声明一个派生类的一般格式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class 派生类名：[继承方式]  基类名&#123;</span><br><span class="line">    派生类新增的数据成员和成员函数</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p>如果不显示地给出继承方式关键字，系统默认为私有继承（private)。</p><h1 id="2-基类成员在派生类中的访问属性"><a href="#2-基类成员在派生类中的访问属性" class="headerlink" title="2. 基类成员在派生类中的访问属性"></a>2. 基类成员在派生类中的访问属性</h1><p>派生类可以继承基类中除了构造函数与析构函数之外的成员，但是这些成员的访问属性在派生过程中是可以调整的。从基类继承来的成员在派生类中的访问属性是由继承方式控制的。</p><table><thead><tr><th>基类中的成员</th><th>在公有派生类中的访问属性</th><th>在私有派生类中的访问属性</th><th>在保护派生类中的访问属性</th></tr></thead><tbody><tr><td>私有成员</td><td>不可直接访问</td><td>不可直接访问</td><td>不可直接访问</td></tr><tr><td>公有成员</td><td>公有</td><td>私有</td><td>保护</td></tr><tr><td>保护成员</td><td>保护</td><td>私有</td><td>保护</td></tr></tbody></table><p>从上表中可以归纳出以下几点：</p><p>（1）基类中的私有成员</p><p>​    <strong>无论哪种继承方式，基类中的私有成员不允许派生类继承，即在派生类中是不可直接访问的</strong>。</p><p>（2）基类中的公有成员</p><p>​    当类的继承方式为公有继承时，基类中的所有公有成员在派生类中仍以公有成员的身份出现。</p><p>​    当类的继承方式为私有继承时，基类中的所有公有成员在派生类中仍以私有成员的身份出现。</p><p>​    当类的继承方式为保护继承时，基类中的所有公有成员在派生类中仍以保护成员的身份出现。</p><p>（3）基类中的保护成员</p><p>​    当类的继承方式为公有继承时，基类中的所有保护成员在派生类中仍以保护成员的身份出现。</p><p>​    当类的继承方式为私有继承时，基类中的所有保护成员在派生类中仍以私有成员的身份出现。</p><p>​    当类的继承方式为保护继承时，基类中的所有保护成员在派生类中仍以保护成员的身份出现。</p><h1 id="3-派生类对基类成员的访问规则"><a href="#3-派生类对基类成员的访问规则" class="headerlink" title="3. 派生类对基类成员的访问规则"></a>3. 派生类对基类成员的访问规则</h1><p>派生类对基类成员的访问形式主要有以下两种：</p><p>（1）内部访问。由派生类中新增的成员函数对基类继承来的成员的访问</p><p>（2）对象访问。由派生类外部，通过派生类的对象对从基类继承来的成员的访问。</p><h1 id="3-1-私有继承的访问规则"><a href="#3-1-私有继承的访问规则" class="headerlink" title="3.1 私有继承的访问规则"></a>3.1 私有继承的访问规则</h1><table><thead><tr><th>基类中的成员</th><th>私有成员</th><th>公有成员</th><th>保护成员</th></tr></thead><tbody><tr><td>内部访问</td><td>不可访问</td><td>可访问</td><td>可访问</td></tr><tr><td>对象访问</td><td>不可访问</td><td>不可访问</td><td>不可访问</td></tr></tbody></table><p>说明：</p><p>（1）基类中的私有成员在被私有继承时既不能被派生类的对象访问，也不能被派生类的成员函数访问，只能被基类自己的成员函数访问。因此，我们在设计积累时，总要为它的私有数据成员提供公有成员函数，如成员函数showx等，以便使派生类可以间接访问这些数据成员。</p><p>（2）经历了私有继承之后，所有基类的成员都成为了派生类的私有成员或不可直接访问的成员，如果进一步派生的话，基类的全部成员都无法在新的派生类中被访问。</p><h1 id="3-2-公有继承的访问规则"><a href="#3-2-公有继承的访问规则" class="headerlink" title="3.2 公有继承的访问规则"></a>3.2 公有继承的访问规则</h1><table><thead><tr><th>基类中的成员</th><th>私有成员</th><th>公有成员</th><th>保护成员</th></tr></thead><tbody><tr><td>内部访问</td><td>不可访问</td><td>可访问</td><td>可访问</td></tr><tr><td>对象访问</td><td>不可访问</td><td>可访问</td><td>不可访问</td></tr></tbody></table><h1 id="3-3-保护继承的访问规则"><a href="#3-3-保护继承的访问规则" class="headerlink" title="3.3 保护继承的访问规则"></a>3.3 保护继承的访问规则</h1><table><thead><tr><th>基类中的成员</th><th>私有成员</th><th>公有成员</th><th>保护成员</th></tr></thead><tbody><tr><td>内部访问</td><td>不可访问</td><td>可访问</td><td>可访问</td></tr><tr><td>对象访问</td><td>不可访问</td><td>不可访问</td><td>不可访问</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-派生类的声明&quot;&gt;&lt;a href=&quot;#1-派生类的声明&quot; class=&quot;headerlink&quot; title=&quot;1. 派生类的声明&quot;&gt;&lt;/a&gt;1. 派生类的声明&lt;/h1&gt;&lt;p&gt;声明一个派生类的一般格式为：&lt;/p&gt;
&lt;figure class=&quot;highlight 
      
    
    </summary>
    
      <category term="C++" scheme="https://codave.github.io/categories/C/"/>
    
    
      <category term="派生" scheme="https://codave.github.io/tags/%E6%B4%BE%E7%94%9F/"/>
    
      <category term="继承" scheme="https://codave.github.io/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>C++语法08-常类型</title>
    <link href="https://codave.github.io/2019/04/21/C++%E8%AF%AD%E6%B3%9508-%E5%B8%B8%E7%B1%BB%E5%9E%8B/"/>
    <id>https://codave.github.io/2019/04/21/C++语法08-常类型/</id>
    <published>2019-04-21T12:02:24.000Z</published>
    <updated>2019-04-21T12:45:16.835Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>程序中各种形式的数据共享，在不同程度上破坏了数据的安全性。常类型的引入，就是为了既保证数据共享又防止数据被改动。常类型是指使用类型修饰符const说明的类型，常类型的变量或对象成员的值在程序运行期间是不可改变的。</p></blockquote><h1 id="1-常引用"><a href="#1-常引用" class="headerlink" title="1. 常引用"></a>1. 常引用</h1><p>如果在说明引用时用const修饰，则被说明的引用为常引用。如果用常引用作形参，便不会产生对实参的不希望的更改。常引用的说明形式如下：</p><p><strong>const  类型  &amp;引用名；</strong></p><p>在实际应用中，常引用往往用来作函数的形参，这样的参数称为常参数。</p><h1 id="2-常对象"><a href="#2-常对象" class="headerlink" title="2. 常对象"></a>2. 常对象</h1><p>如果在说明对象时用const修饰，则被说明的对象为常对象。常对象的数据成员值在对象的整个生存期内不能被改变。常对象的说明该形式如下：</p><p><strong>类名   const   对象名[(参数名)]；</strong>或者   <strong>const   类名   对象名[(参数表)]；</strong></p><p><strong>注意：</strong>在定义对象时必须进行初始化，而且不能被更新。</p><h1 id="3-常对象成员"><a href="#3-常对象成员" class="headerlink" title="3. 常对象成员"></a>3. 常对象成员</h1><h1 id="3-1-常数据成员"><a href="#3-1-常数据成员" class="headerlink" title="3.1 常数据成员"></a>3.1 常数据成员</h1><p>类的数据成员可以是常量或者常引用，使用const说明的数据成员称为常数据成员。<strong>如果在一个类中说明了常数据成员，那么构造函数就只能通过成员初始化列表对该数据成员进行初始化，而其他任何函数都不能对该成员赋值。</strong></p><h1 id="3-2-常成员函数"><a href="#3-2-常成员函数" class="headerlink" title="3.2 常成员函数"></a>3.2 常成员函数</h1><p>在类中使用关键字const说明的成员函数为常成员函数，常成员函数的说明格式如下：</p><p><strong>类型说明符       函数名（参数表）const；</strong></p><p>const是函数类型的一个组成部分，因此在声明函数和定义函数时都要有关键字const。在调用时不必加const。</p><p>说明：</p><p>（1）常成员函数可以访问常数据成员，也可以访问普通数据成员。常数据成员可以被常成员函数访问，也可以被普通成员函数访问。</p><table><thead><tr><th>数据成员</th><th>普通成员函数</th><th>常成员函数</th></tr></thead><tbody><tr><td>普通数据成员</td><td>可以访问，也可以改变值</td><td>可以访问，但不可以改变值</td></tr><tr><td>常数据成员</td><td>可以访问，但不可以改变值</td><td>可以访问，但不可以改变值</td></tr><tr><td>常对象的数据成员</td><td>不允许访问和改变值</td><td>可以访问，但不可以改变值</td></tr></tbody></table><p>（2）如果将一个对象说明为常对象，则通过该对象只能调用它的常成员函数，而不能调用普通的成员函数。常成员函数是常对象的唯一的对外接口，这是C++从语法机制上对常对象的保护。</p><p>（3）常成员函数不能更新对象的数据成员，也不能调用该类中的普通成员函数，这就保证了在常成员函数中绝对不会更新数据成员的值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;程序中各种形式的数据共享，在不同程度上破坏了数据的安全性。常类型的引入，就是为了既保证数据共享又防止数据被改动。常类型是指使用类型修饰符const说明的类型，常类型的变量或对象成员的值在程序运行期间是不可改变的。&lt;/p&gt;
&lt;/blockquote&gt;
      
    
    </summary>
    
      <category term="C++" scheme="https://codave.github.io/categories/C/"/>
    
    
      <category term="常引用" scheme="https://codave.github.io/tags/%E5%B8%B8%E5%BC%95%E7%94%A8/"/>
    
      <category term="常函数" scheme="https://codave.github.io/tags/%E5%B8%B8%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++语法07-类的组合</title>
    <link href="https://codave.github.io/2019/04/21/C++%E8%AF%AD%E6%B3%9507-%E7%B1%BB%E7%9A%84%E7%BB%84%E5%90%88/"/>
    <id>https://codave.github.io/2019/04/21/C++语法07-类的组合/</id>
    <published>2019-04-21T10:36:48.000Z</published>
    <updated>2019-06-05T13:44:20.589Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在类中定义的数据成员一般都是基本的数据类型或复合数据类型。但是还可以根据需要使用其他类的对象作为正在声明的类的数据成员。在一个类中内嵌另一个类的对象作为数据成员，称为类的组合。该内嵌对象称为对象成员，也成为子对象。</p></blockquote><p>使用对象成员着重要注意的问题是如何完成对象成员的初始化工作。当创建类的对象时，如果这个类具有内嵌的对象成员，那么内嵌对象成员也将被自动创建。因此，在创建对象时既要对本类的基本数据成员初始化，又要对内嵌的对象成员进行初始化。含有对象成员的类，其构造函数和不含对象成员的构造函数有所不同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class X&#123;</span><br><span class="line">    类名<span class="number">1</span>对象成员<span class="number">1</span>；</span><br><span class="line">    类名<span class="number">2</span>对象成员<span class="number">2</span>；</span><br><span class="line">        ...</span><br><span class="line">    类名n对象成员n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一般来说，类X的构造函数的定义形式为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X::X（形参表<span class="number">0</span>）：对象成员<span class="number">1</span>（形参表<span class="number">1</span>），对象成员<span class="number">2</span>（形参表<span class="number">2</span>），......&#123;</span><br><span class="line"><span class="comment">//类X的构造函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用构造函数X::X()时，首先按各内嵌对象成员在类声明中的顺序依次调用它们的构造函数，对这些对象初始化。最后再执行类X的构造函数体，初始化类X中的其他成员。析构函数的调用顺序与构造函数的调用顺序相反。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">例：对象成员的初始化。</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> x1,<span class="keyword">float</span> y1)&#123;</span><br><span class="line">        x=x1;</span><br><span class="line">        y=y1;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"\n x="</span>&lt;&lt; x &lt;&lt; <span class="string">"y="</span> &lt;&lt;y;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">float</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B(<span class="keyword">int</span> x1,<span class="keyword">float</span> y1, <span class="keyword">int</span> z1):a(x1,y1)&#123;</span><br><span class="line">        z=z1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a.show();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"z="</span>&lt;&lt; z;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">int</span> z;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">B <span class="title">b</span><span class="params">(<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>)</span></span>;</span><br><span class="line">    b.show();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在类中定义的数据成员一般都是基本的数据类型或复合数据类型。但是还可以根据需要使用其他类的对象作为正在声明的类的数据成员。在一个类中内嵌另一个类的对象作为数据成员，称为类的组合。该内嵌对象称为对象成员，也成为子对象。&lt;/p&gt;
&lt;/blockquote
      
    
    </summary>
    
      <category term="C++" scheme="https://codave.github.io/categories/C/"/>
    
    
      <category term="类的组合" scheme="https://codave.github.io/tags/%E7%B1%BB%E7%9A%84%E7%BB%84%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>C++语法06-静态成员</title>
    <link href="https://codave.github.io/2019/04/21/C++%E8%AF%AD%E6%B3%9506-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/"/>
    <id>https://codave.github.io/2019/04/21/C++语法06-静态成员/</id>
    <published>2019-04-21T05:50:01.000Z</published>
    <updated>2019-04-21T08:20:37.629Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-静态数据成员"><a href="#1-静态数据成员" class="headerlink" title="1. 静态数据成员"></a>1. 静态数据成员</h1><blockquote><p>为了实现同一个类的多个对象之间的数据共享，C++提出了静态数据成员的概念。在一个类中 ，若将一个数据成员说明成static，这种成员被称为静态数据成员。与一般的数据成员不同，无论建立多少个类的对象，都只有一个静态数据成员的拷贝。从而实现了同一个类中的不同对象之间的数据共享。</p></blockquote><p>定义静态数据成员的格式如下：</p><p><strong>static  数据类型  数据成员名</strong></p><p>说明：</p><p>（1）静态数据成员的定义与普通数据成员相似，但前面要加上static关键字。</p><p>（2）静态数据成员的初始化与普通数据成员不同。静态数据成员初始化应在类外单独进行，而且应在定义对象之前进行。一般在主函数main之前，类声明之后的特殊地带为它提供定义和初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">初始化的格式如下：</span><br><span class="line">数据类型  类名：：静态数据成员名=初始值；</span><br></pre></td></tr></table></figure><p>（3）静态数据成员属于类（准确地说，是属于类对象的集合），而不像普通数据成员那样属于某一对象，因此可以使用使用“类名：”访问静态的数据成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用类名访问静态数据成员的格式如下：</span><br><span class="line">类名：静态数据成员名</span><br></pre></td></tr></table></figure><p>（4）静态数据成员与静态变量一样，是在编译时创建并初始化。它在该类的任何对象被建立之前就存在。因此，公有的静态数据成员可以在对象定义之前被访问。对象定义后，公有的静态数据成员，也可以通过对象进行访问。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象名.静态数据成员名；</span><br><span class="line">对象指针-&gt;静态数据成员名；</span><br></pre></td></tr></table></figure><p>（5）私有静态数据成员不能在类外直接访问，必须通过公有的成员函数访问。</p><p>（6）C++支持静态数据成员的一个重要原因是可以不必使用全局变量。依赖于全局变量的类几乎都是违反面向对象程序设计的封装特性的。静态数据成员主要用作类的所有对象所共有的数据，如统计总数、平均数等。</p><h1 id="2-静态成员函数"><a href="#2-静态成员函数" class="headerlink" title="2. 静态成员函数"></a>2. 静态成员函数</h1><blockquote><p>在类定义中，前面有static说明的成员函数被称为静态成员函数。静态成员函数属于整个类，是该类所有对象共享的成员函数，而不是类中的某个对象。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">定义静态成员函数的格式如下：</span><br><span class="line"><span class="keyword">static</span>  返回类型  静态成员函数名（参数表）;</span><br><span class="line"></span><br><span class="line">与静态数据成员类似，调用公有静态成员函数的一般格式有如下几种：</span><br><span class="line">(<span class="number">1</span>) 类名::静态成员函数名（实参名）</span><br><span class="line">(<span class="number">2</span>) 对象.静态成员函数名（实参名）</span><br><span class="line">(<span class="number">3</span>) 对象指针-&gt;静态成员函数名（实参名）</span><br></pre></td></tr></table></figure><p>例：静态成员函数访问静态数据成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Small_cat</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Small_cat(<span class="keyword">double</span> w);</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">total_disp</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">double</span> weight;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> total_weight;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> total_number;</span><br><span class="line">&#125;;</span><br><span class="line">Small_cat::Small_cat(<span class="keyword">double</span> w)&#123;</span><br><span class="line">    weight=w;</span><br><span class="line">    total_weight+=w;</span><br><span class="line">    total_number++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Small_cat::display()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"这只小猫的重量是："</span>&lt;&lt;weight&lt;&lt;<span class="string">"千克\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> Small_cat::total_disp()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;total_number&lt;&lt;<span class="string">"只小猫的总重量是："</span>；</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;total_weight&lt;&lt;<span class="string">"千克"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">double</span> Small_cat::total_weight = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> Small_cat::total_number = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Small_cat w1(0.5),w2(0.6),w3(0.4);</span><br><span class="line">    w1.display();</span><br><span class="line">    w2.display();</span><br><span class="line">    w3.display();</span><br><span class="line">    Samll_cat::total_disp();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面对静态成员函数的使用再作几点说明：</p><p>（1）一般情况下，静态函数成员主要用来访问静态数据成员。当它与静态数据成员一起使用时，达到了对同一个类中对象之间共享数据的目的。</p><p>（2）私有静态成员函数不能做类外部的函数和对象访问。</p><p>（3）使用静态成员函数的一个原因是，可以用它在建立任何对象之前调用静态成员函数，以处理静态数据成员，这是普通成员函数不能实现的功能。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Small_cat::total_disp();<span class="comment">//可以用它在建立任何对象之前调用静态成员函数</span></span><br><span class="line">    Small_cat w1(0.5),w2(0.6),w3(0.4);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）编译系统将静态成员函数限定为内部连接，也就是说，与现行文件相连接的其他文件中的同名函数不会与该函数发生冲突，维护了该函数使用的安全性，这是使用静态成员函数的另一个原因。</p><p>（5）静态成员函数是类的一部分，而不是对象的一部分。</p><p>（6）静态成员函数与非静态成员函数的重要的区别是：非静态成员函数有this指针，而静态成员函数没有this指针。<strong>静态成员函数可以直接访问本类中的静态数据成员，因为静态数据成员同样是属于类的，可以直接访问。</strong>一般而言，静态成员函数不访问类中的非静态成员。若确实需要访问非静态数据成员，静态成员函数只能通过对象名（或对象指针、对象引用）访问该对象的非静态成员。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-静态数据成员&quot;&gt;&lt;a href=&quot;#1-静态数据成员&quot; class=&quot;headerlink&quot; title=&quot;1. 静态数据成员&quot;&gt;&lt;/a&gt;1. 静态数据成员&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;为了实现同一个类的多个对象之间的数据共享，C++提出了静态数据
      
    
    </summary>
    
      <category term="C++" scheme="https://codave.github.io/categories/C/"/>
    
    
      <category term="静态成员" scheme="https://codave.github.io/tags/%E9%9D%99%E6%80%81%E6%88%90%E5%91%98/"/>
    
  </entry>
  
  <entry>
    <title>C++语法05-对象的赋值和复制</title>
    <link href="https://codave.github.io/2019/04/20/C++%E8%AF%AD%E6%B3%9505-%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%B5%8B%E5%80%BC%E5%92%8C%E5%A4%8D%E5%88%B6/"/>
    <id>https://codave.github.io/2019/04/20/C++语法05-对象的赋值和复制/</id>
    <published>2019-04-20T13:36:51.000Z</published>
    <updated>2019-06-05T13:42:54.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-对象赋值语句"><a href="#1-对象赋值语句" class="headerlink" title="1. 对象赋值语句"></a>1. 对象赋值语句</h1><blockquote><p>这里所指的对象的赋值是指对其中的数据成员赋值，而不是对成员函数赋值。</p></blockquote><p>例如：A和B是同一类的两个对象，那么下述对象赋值语句 B=A；就能把对象A的数据成员的值逐位复制给对象B。</p><p>说明：</p><p>（1）在使用对象赋值语句进行对象赋值时，两个对象的类型必须相同，如对象的类型不相同，编译时将出错。</p><p>（2） 两个对象之间的赋值，仅仅使这些对象中数据成员相同，而两个对象仍是分离的。</p><p>（3）将一个对象的值赋给另一个对象时，多数情况下都是成功的，但当类中存在指针时，可能会产生错误。</p><h1 id="2-拷贝构造函数"><a href="#2-拷贝构造函数" class="headerlink" title="2. 拷贝构造函数"></a>2. 拷贝构造函数</h1><blockquote><p>拷贝构造函数是一种特殊的构造函数，其形参是本类对象的引用。拷贝构造函数的作用是，在建立一个新的对象时，使用一个已经存在的对象去初始化这个新对象。</p></blockquote><p>例如： Point p2（p1);</p><p>其作用是，在建立新对象p2时，用已经存在的对象p1去初始化新对象p2，在这个过程中就要调用拷贝构造函数。</p><p>拷贝构造函数具有以下特点：</p><p>（1）因为该函数也是一种构造函数，所以其函数名与类名相同，并且该函数也没有返回值类型。</p><p>（2）该函数只有一个参数，并且是同类对象的引用。</p><p>（3）每个类都必须有一个拷贝构造构造函数。程序员可以自定义拷贝构造函数，用于按照需要初始化新对象。如果程序员没有定义类的拷贝构造函数，系统就会自动生成产生一个默认拷贝构造函数，用于复制出数据成员值完全相同的新对象。</p><h1 id="2-1-自定义拷贝构造函数"><a href="#2-1-自定义拷贝构造函数" class="headerlink" title="2.1 自定义拷贝构造函数"></a>2.1 自定义拷贝构造函数</h1><p>自定义拷贝函数的一般形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类名：：类名（<span class="keyword">const</span> 类名 &amp;对象名）&#123;</span><br><span class="line"><span class="comment">//拷贝构造函数的函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用拷贝构造函数的一般形式为：</p><p>（1）代入法： <strong>类名  对象2（对象1）；</strong></p><p>（2）赋值法： <strong>类名  对象2 = 对象1；</strong></p><h1 id="2-2-默认拷贝构造函数"><a href="#2-2-默认拷贝构造函数" class="headerlink" title="2.2 默认拷贝构造函数"></a>2.2 默认拷贝构造函数</h1><blockquote><p>每个类都必须有一个拷贝构造函数。如果程序员没有定义拷贝构造函数，系统就会自动生成一个默认拷贝构造函数，用于复制出完全相同的新对象。</p></blockquote><p>在通常情况下，默认拷贝函数是能够胜任工作的，但如果类中有指针类型时，调用默认拷贝构造函数有时会产生错误，使用时要予以注意。</p><h1 id="2-3-调用拷贝构造函数的3种情况"><a href="#2-3-调用拷贝构造函数的3种情况" class="headerlink" title="2.3 调用拷贝构造函数的3种情况"></a>2.3 调用拷贝构造函数的3种情况</h1><blockquote><p>普通的构造函数是在对象创建时被调用，而拷贝构造函数在以下3种情况下都会被调用。</p></blockquote><p>（1）当用类的一个对象去初始化该类的另一个对象时，拷贝构造函数将会被调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">Point p3=p1;</span><br></pre></td></tr></table></figure><p>（2）当函数的形参是类的对象，在调用函数进行形参和实参结合时，拷贝构造函数将会调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">(Point p)</span></span>&#123;</span><br><span class="line">    p.print();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">    fun1(p1);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）当函数的返回值是类的对象，在函数调用完毕将返回值（对象）带回函数调用处时。此时就会调用拷贝构造函数，将此对象复制给一个临时对象并传到该函数的调用处。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">fun2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">10</span>,<span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Point p2;</span><br><span class="line">    p2=fun2();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-对象赋值语句&quot;&gt;&lt;a href=&quot;#1-对象赋值语句&quot; class=&quot;headerlink&quot; title=&quot;1. 对象赋值语句&quot;&gt;&lt;/a&gt;1. 对象赋值语句&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;这里所指的对象的赋值是指对其中的数据成员赋值，而不是对成员函数
      
    
    </summary>
    
      <category term="C++" scheme="https://codave.github.io/categories/C/"/>
    
    
      <category term="对象赋值" scheme="https://codave.github.io/tags/%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC/"/>
    
      <category term="对象复制" scheme="https://codave.github.io/tags/%E5%AF%B9%E8%B1%A1%E5%A4%8D%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>C++语法04-向函数传递对象</title>
    <link href="https://codave.github.io/2019/04/20/C++%E8%AF%AD%E6%B3%9504-%E5%90%91%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E5%AF%B9%E8%B1%A1/"/>
    <id>https://codave.github.io/2019/04/20/C++语法04-向函数传递对象/</id>
    <published>2019-04-20T12:31:32.000Z</published>
    <updated>2019-04-21T08:21:01.898Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-使用对象作为函数参数"><a href="#1-使用对象作为函数参数" class="headerlink" title="1. 使用对象作为函数参数"></a>1. 使用对象作为函数参数</h1><blockquote><p>对象可以作为参数传递给函数，其方法与传递基本类型的变量相同。在向函数传递对象时，是通过“传值调用”传递给函数的，即单向传递，只由实参传给形参，而不能由形参传回来给实参。<strong>因此函数中对对象的任何修改均不影响调用该函数的对象（实参）本身。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tr</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Tr(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        i=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_i</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        i=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_i</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sqr_it</span><span class="params">(Tr ob)</span></span>&#123;</span><br><span class="line">    ob.set_i(ob.get_i()*ob.get_i());</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"在函数sqr_it内，形参对象ob的数据成员i的值为："</span>&lt;&lt;ob.get_i();      <span class="comment">//100</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Tr <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"调用函数sqr_it前，实参对象obj的数据成员i的值为："</span>;         <span class="comment">//10</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;obj.get_i()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    sqr_it(obj);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"调用函数sqr_it后，实参对象obj的数据成员i的值为："</span>;        <span class="comment">//10</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;obj.get_i();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-使用对象指针作为函数参数"><a href="#2-使用对象指针作为函数参数" class="headerlink" title="2. 使用对象指针作为函数参数"></a>2. 使用对象指针作为函数参数</h1><blockquote><p>对象指针可以作为函数的参数，使用对象指针作为函数参数可以实现“传址调用”，即在函数调用时使实参对象和形参对象指针变量指向同一内存地址，在函数调用过程中，<strong>对形参对象指针值的改变也同样影响着实参对象的值</strong>。<strong>当函数的形参是对象指针时，调用函数的对应实参应该是某个对象的地址值。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tr</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Tr(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        i=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_i</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        i=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_i</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sqr_it</span><span class="params">(Tr *ob)</span></span>&#123;</span><br><span class="line">    ob-&gt;set_i(ob-&gt;get_i()*ob-&gt;get_i());</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"在函数sqr_it内，形参对象ob的数据成员i的值为："</span>&lt;&lt;ob-&gt;get_i();        <span class="comment">//100</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Tr <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"调用函数sqr_it前，实参对象obj的数据成员i的值为："</span>;           <span class="comment">//10</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;obj.get_i()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    sqr_it(&amp;obj);      <span class="comment">//传地址</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"调用函数sqr_it后，实参对象obj的数据成员i的值为："</span>;            <span class="comment">//100</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;obj.get_i();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-使用对象引用作为函数参数"><a href="#3-使用对象引用作为函数参数" class="headerlink" title="3. 使用对象引用作为函数参数"></a>3. 使用对象引用作为函数参数</h1><blockquote><p>在实际中，使用对象引用作为函数参数非常普遍，大部分程序员喜欢用对象引用取代对象指针作为函数参数。因为使用对象引用作为函数参数不但具有对象指针用作函数参数的优点，而且用对象引用作为函数参数将<strong>更简单、更直接</strong>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tr</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Tr(<span class="keyword">int</span> n)&#123;</span><br><span class="line">        i=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_i</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        i=n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_i</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sqr_it</span><span class="params">(Tr &amp;ob)</span></span>&#123;</span><br><span class="line">    ob.set_i(ob.get_i()*ob.get_i());</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"在函数sqr_it内，形参对象ob的数据成员i的值为："</span>&lt;&lt;ob.get_i();<span class="comment">//100</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">Tr <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"调用函数sqr_it前，实参对象obj的数据成员i的值为："</span>;   <span class="comment">//10</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;obj.get_i()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    sqr_it(obj);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"调用函数sqr_it后，实参对象obj的数据成员i的值为："</span>;<span class="comment">//100</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;obj.get_i();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-使用对象作为函数参数&quot;&gt;&lt;a href=&quot;#1-使用对象作为函数参数&quot; class=&quot;headerlink&quot; title=&quot;1. 使用对象作为函数参数&quot;&gt;&lt;/a&gt;1. 使用对象作为函数参数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;对象可以作为参数传递给函数，其
      
    
    </summary>
    
      <category term="C++" scheme="https://codave.github.io/categories/C/"/>
    
    
      <category term="函数传参" scheme="https://codave.github.io/tags/%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82/"/>
    
  </entry>
  
  <entry>
    <title>C++语法03-对象数组与对象指针</title>
    <link href="https://codave.github.io/2019/04/20/C++%E8%AF%AD%E6%B3%9503-%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88/"/>
    <id>https://codave.github.io/2019/04/20/C++语法03-对象数组与对象指针/</id>
    <published>2019-04-20T05:20:06.000Z</published>
    <updated>2019-04-21T08:20:51.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-对象数组"><a href="#1-对象数组" class="headerlink" title="1. 对象数组"></a>1. 对象数组</h1><blockquote><p>所谓对象数组是指每一个数组元素都是对象的数组，也就是说，若一个类有若干个对象，我们把这一系列的对象用一个数组来存放。对象数组的元素是对象，不仅具有数据成员，而且还有函数成员。</p></blockquote><p>定义一个一维数组的格式如下：</p><p><strong>类名 数组名[下标表达式]</strong></p><p>例如有10个复数，每个复数的属性包括实部与虚部。如果为每一个复数建立一个对象，需要分别取10个对象名。显然用程序处理起来很不方便。这时可以定义一个复数类Complex的对象数组，每一个数组元素是Complex类的一个对象，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex com[<span class="number">10</span>];<span class="comment">//定义类Complex的对象数组com,含有10个对象数组元素</span></span><br></pre></td></tr></table></figure><p>在建立数组时，同样要调用构造函数。有几个数组元素就要调用几次构造函数。例如有10个数组元素 ，就要调用10次构造函数。类Complex的构造函数有两个参数，分别用于给实部数据和虚部数据赋值。<strong>如果构造函数只有1个参数，在定义对象数组时可以直接在等号后面的花括号内提供实参。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用只有1个参数的构造函数给对象数组赋值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">exam</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        exam(<span class="keyword">int</span> n)&#123;</span><br><span class="line">            x=n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">get_x</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    exam ob1[<span class="number">4</span>]=&#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>,<span class="number">44</span>&#125;;<span class="comment">//用只有1个参数的构造函数给对象数组赋值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        cout&lt;&lt;ob1[i].get_x()&lt;&lt;'';</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与基本数据类型的数组一样，在使用对象数组时也只能访问单个数组元素，其一般形式是：</p><p>​                        <strong>数组名  [下标].成员名</strong></p><p>以上例子中构造函数只有一个参数，如果构造函数有多个参数，在定义对象数组时应当怎样实现初始化？我们只要在花括号中分别写出构造函数并指定实参即可。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Complex com[<span class="number">3</span>]=&#123;        <span class="comment">//定义对象数组com</span></span><br><span class="line">    Complex(<span class="number">1.1</span>, <span class="number">2.2</span>);</span><br><span class="line">    Complex(<span class="number">3.3</span>, <span class="number">4.4</span>);</span><br><span class="line">    Complex(<span class="number">5.5</span>, <span class="number">6.6</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于这个对象数组有3个对象数组元素，因此在建立对象数组时，3次调用构造函数，对每一个对象数组元素初始化。<strong>当1个数组中的数组元素被删除时，系统会调用析构函数来完成扫尾工作，有几个对象数组元素就会调用几次析构函数。</strong></p><h1 id="2-对象指针"><a href="#2-对象指针" class="headerlink" title="2. 对象指针"></a>2. 对象指针</h1><blockquote><p>每一个对象在初始化后都会在内存占有一定的空间。因此，既可以通过对象名访问一个对象，也可以通过对象地址来访问一个对象。对象指针就是用于存放对象地址的变量。</p></blockquote><p>声明对象指针的一般语法形式为：</p><p>​                            <strong>类名 *对象指针名</strong></p><p><strong>（1）用指针访问单个对象成员</strong>：</p><p>​    说明对象指针的语法和说明其他数据类型指针的语法相同。使用对象指针时，首先要把它指向一个已创建的对象，然后才能引用该对象的成员。</p><p>​    在一般情况下，用点运算符“.”来访问对象成员，当用指向对象的指针来访问对象成员时，就要用“-&gt;”操作符。</p><p><strong>（2）用对象指针访问对象数组</strong></p><p>​    对象指针不仅能引用单个对象，也能访问对象数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    exe ob[<span class="number">2</span>]; <span class="comment">//定义类exe的对象数组ob[2]</span></span><br><span class="line">    exe *p; <span class="comment">//定义指向类exe的对象指针变量p</span></span><br><span class="line">    ob[<span class="number">0</span>].set_a(<span class="number">10</span>); <span class="comment">//</span></span><br><span class="line">    ob[<span class="number">0</span>].set_b(<span class="number">20</span>);</span><br><span class="line">    p=ob;</span><br><span class="line">    p-&gt;show_a();</span><br><span class="line">    p++;      <span class="comment">//一般而言，当指针加1或减1时，它总是指向其基本类型中相邻的一个元素，对象指针也是如此</span></span><br><span class="line">    p-&gt;show_a();  </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-this指针"><a href="#3-this指针" class="headerlink" title="3. this指针"></a>3. this指针</h1><p>// TODO</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-对象数组&quot;&gt;&lt;a href=&quot;#1-对象数组&quot; class=&quot;headerlink&quot; title=&quot;1. 对象数组&quot;&gt;&lt;/a&gt;1. 对象数组&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;所谓对象数组是指每一个数组元素都是对象的数组，也就是说，若一个类有若干个对象，
      
    
    </summary>
    
      <category term="C++" scheme="https://codave.github.io/categories/C/"/>
    
    
      <category term="对象数组" scheme="https://codave.github.io/tags/%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84/"/>
    
      <category term="对象指针" scheme="https://codave.github.io/tags/%E5%AF%B9%E8%B1%A1%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>C++语法02-构造函数和析构函数</title>
    <link href="https://codave.github.io/2019/04/19/C++%E8%AF%AD%E6%B3%9502-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    <id>https://codave.github.io/2019/04/19/C++语法02-构造函数和析构函数/</id>
    <published>2019-04-19T12:58:37.000Z</published>
    <updated>2019-04-20T05:19:06.852Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-对象的初始化和构造函数"><a href="#1-对象的初始化和构造函数" class="headerlink" title="1. 对象的初始化和构造函数"></a>1. 对象的初始化和构造函数</h1><blockquote><p><strong>类是一种抽象的数据类型，它不占存储空间，不能容纳具体的数据。因此在类声明中不能给数据成员赋初值。</strong>与使用变量一样，使用对象时也应该先定义，后使用。在定义对象时，对数据成员赋初值，称为对象的初始化。在定义对象时，如果某一数据成员没有被赋值，则它的值是不可预知的。对象是一个实体，在使用对象时，它的每一个数据成员都应该有确定的值。</p></blockquote><p>如果一个类中的所有成员，都是共有的，则可以在定义对象时对数据成员进行初始化。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">double</span> real;</span><br><span class="line">    <span class="keyword">double</span> imag;</span><br><span class="line">&#125;;</span><br><span class="line">Complex c1=&#123;<span class="number">1.1</span>,<span class="number">2.2</span>&#125;;</span><br></pre></td></tr></table></figure><p>说明：这种方法类似于结构体变量初始化的方法。但是，如果类中包含私有的或保护的成员时，就不能用这种方法进行初始化。除了调用公有成员函数来给数据成员赋值，C++提供了一个更好的方法，利用构造函数来完成对象的初始化。</p><blockquote><p>构造函数是一种特殊的成员函数，它主要用于为对象分配对象，进行初始化。构造函数的名字必须和类名相同，而不能由用户任意命名。它可以有任意类型的参数，但不能具有返回值类型。它不需要用户来调用，而是在建立对象时自动执行的。</p></blockquote><p><strong>在建立对象的同时，采用构造函数给成员赋初值，通常有以下两种形式。</strong></p><p><strong>形式1：</strong></p><p><strong>类名  对象名[(实参表)]</strong></p><p><strong>形式2：</strong></p><p><strong>类名  *指针变量名=new 类名[(实参表)]</strong></p><p>说明：这时编译系统开辟了一段内存空间，并在此空间中存放了一个Complex类对象，同时调用了该类的构造函数给数据成员赋初值。这个对象没有名字，称为无名对象。但是该对象有地址，这个地址存放在指针变量pa中。访问用new动态建立的对象一般是不用对象的，而是通过指针访问。</p><p><strong>注意：</strong></p><p>（1）当new建立的对象使用结束时，不再需要它时，可以用delete运算符予以释放<code>delete pa</code>。</p><p>（2）与普通成员函数一样，构造函数的函数体可写在类体内（系统将构造函数作为内联函数处理），也可以写在类体外。</p><p>（3）构造函数一般声明为公有函数，它是在定义对象的同时被自动调用的，而且只执行一次。</p><p>（4）如果没有给类定义构造函数，则编译系统自动地生成一个默认构造函数。<strong>（这个默认的构造函数不带任何参数，函数体是空的，它只能为对象开辟数据成员存储空间，而不能给对象中的数据成员赋值）</strong></p><p>（5）构造函数可以不带参数，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Complex()&#123;   <span class="comment">//不带参数的构造函数</span></span><br><span class="line">    real=<span class="number">0</span>;</span><br><span class="line">    imag=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Complex A;   <span class="comment">//定义类Complex的对象A时调用不要带参数，也不要要带括号！！！</span></span><br></pre></td></tr></table></figure><h1 id="2-用成员初始化列表对数据成员初始化"><a href="#2-用成员初始化列表对数据成员初始化" class="headerlink" title="2. 用成员初始化列表对数据成员初始化"></a>2. 用成员初始化列表对数据成员初始化</h1><blockquote><p>C++还提供另一种初始化数据成员的方法——用成员初始化列表对数据成员初始化。这种方法不在函数体内用赋值语句对数据成员初始化，而是在函数首部实现的。</p></blockquote><p>带有成员初始化列表的构造函数的一般形式如下：</p><p><strong>类名：：构造函数名（[参数表])[:(成员初始化列表)]{</strong></p><p>​        <strong>//构造函数体</strong></p><p><strong>}</strong></p><p>成员初始化列表的一般形式为：</p><p><strong>数据成员名1（初始值1），数据成员名2（初始值2），…..</strong></p><p><strong>注意:</strong></p><p>（1）对于用<code>const</code>修饰的数据成员，或是引用类型的数据成员，是不允许用赋值语句直接赋值的。因此，只能用成员初始化列表对其进行初始化。</p><p>（2）数据成员是按照它们在类中声明的顺序进行初始化的，与它们在成员初始化列表中列出的顺序无关。</p><h1 id="3-构造函数的重载"><a href="#3-构造函数的重载" class="headerlink" title="3. 构造函数的重载"></a>3. 构造函数的重载</h1><blockquote><p>与一般的成员函数一样，C++允许构造函数重载，以适应不同的场合。</p></blockquote><p><strong>注意：</strong></p><p>（1）使用无参构造函数创建对象时，应该用语句“Date date1；”，而不能用语句“Date date1()；”。因为语句“Date date1()；”表示声明一个名为date1的普通函数，此函数的返回值为Date类型。</p><p>（2）如果在类中用户没有定义构造函数，系统会自动提供一个函数体为空的默认构造函数。但是，只要类中定义了一个构造函数（不一定是无参构造函数），系统将不再给它提供默认构造函数。</p><h1 id="4-带默认参数的构造函数"><a href="#4-带默认参数的构造函数" class="headerlink" title="4. 带默认参数的构造函数"></a>4. 带默认参数的构造函数</h1><blockquote><p>对于带参数的构造函数，在定义对象时必须给构造函数的形参传递参数的值，否则构造函数将不被执行。但在实际使用中，有些构造函数的参数值在大部分情况是相同的，只有在特殊情况下才需要改变它的参数值。</p></blockquote><p><strong>说明：</strong></p><p>（1）如果构造函数在类的声明外定义，那么默认参数在类内声明构造函数原型时指定，而不能在类外构造函数定义时指定。因为类的声明是放在头文件中的，用户可以看到，而构造函数的定义是类的实现细节，用户往往看不到。因此，在声明时指定默认参数，可以保证用户在建立对象时知道怎么使用默认参数。</p><p>（2）如果构造函数的全部参数都指定了默认值，则在定义对象时可以指定1个或几个实参，也可以不给出实参，这时的构造函数也属于默认构造函数。<strong>因为一个类只能有一个默认构造函数，因此不能同时再声明无参数的默认构造函数。</strong>否则，编译系统将无法识别应该调用哪个构造函数，因此产生了二义性。</p><p>（3）在一个类中定义了全部是默认参数的构造函数后，不能再定义重载构造函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">例如在一个类中有以下构造函数的声明</span><br><span class="line">Complex(<span class="keyword">double</span> r=<span class="number">0.0</span>, <span class="keyword">double</span> i=<span class="number">0.0</span>);</span><br><span class="line">Complex(<span class="keyword">double</span> r);</span><br><span class="line"></span><br><span class="line">如果用以下语句定义对象</span><br><span class="line">Complex S2（<span class="number">1.1</span>）；     <span class="comment">//无法判断应该调用以上哪个构造函数</span></span><br></pre></td></tr></table></figure><p>因此，一般不要同时使用构造函数的重载和有默认参数的构造函数。</p><h1 id="5-析构函数"><a href="#5-析构函数" class="headerlink" title="5. 析构函数"></a>5. 析构函数</h1><blockquote><p>析构函数也是一种特殊的成员函数。它执行与构造函数相反的操作，通常用于执行一些清理任务，如释放分配给对象的内存空间等。析构函数有如下一些特点：</p><p>（1）析构函数名与类名相同，但它前面必须加一个波浪号（~）。</p><p>（2）析构函数不返回任何值。在定义析构函数时，是不能说明它的类型的，甚至说明为void也不行。</p><p>（3）析构函数没有参数，因此它不能被重载。<strong>一个类可以有多个构造函数，但只能有一个析构函数。</strong></p><p>（4）撤销对象时，编译系统会自动地调用析构函数。</p></blockquote><p><strong>说明：</strong></p><p>（1）每个类必须有一个析构函数。若没有显示地为一个类定义析构函数，则编译系统会自动地生成一个默认析构函数。**对于大多数而言，这个默认析构函数就能满足要求。但是，如果在一个对象撤销之前需要完成另外一些处理工作的话，则应该显示地定义析构函数。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String_data</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        String_data(<span class="keyword">char</span> *s)&#123;</span><br><span class="line">            str=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(s)+<span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(str, s);</span><br><span class="line">        &#125;</span><br><span class="line">        ~String_data()&#123;</span><br><span class="line">            <span class="keyword">delete</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">get_info</span><span class="params">(<span class="keyword">char</span>*)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sent_info</span><span class="params">(<span class="keyword">char</span>*)</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> *str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是构造函数和析构函数最常见的用法，即在构造函数中用运算符new为字符串分配存储空间，最后在析构函数中用运算符delete释放已分配的存储空间。</p><p>（2）除了在主函数结束（或调用exit函数）时，对象被撤销，系统会自动调用析构函数外，在以下情况，析构函数也会被调用：</p><ul><li>如果一个对象被定义在一个函数体内，则当这个函数被调用结束时，该对象将释放，析构函数被自动调用。</li><li>若一个对象时使用new运算符动态创建的，在使用delete运算符释放它时，delete会自动调用析构函数。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-对象的初始化和构造函数&quot;&gt;&lt;a href=&quot;#1-对象的初始化和构造函数&quot; class=&quot;headerlink&quot; title=&quot;1. 对象的初始化和构造函数&quot;&gt;&lt;/a&gt;1. 对象的初始化和构造函数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;类是一
      
    
    </summary>
    
      <category term="C++" scheme="https://codave.github.io/categories/C/"/>
    
    
      <category term="构造函数" scheme="https://codave.github.io/tags/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    
      <category term="析构函数" scheme="https://codave.github.io/tags/%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>C++语法01-类和对象的基本概念</title>
    <link href="https://codave.github.io/2019/04/07/C++%E8%AF%AD%E6%B3%9501-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://codave.github.io/2019/04/07/C++语法01-类和对象的基本概念/</id>
    <published>2019-04-07T12:52:37.000Z</published>
    <updated>2019-04-21T09:05:03.634Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-结构体的扩充"><a href="#1-结构体的扩充" class="headerlink" title="1. 结构体的扩充"></a>1. 结构体的扩充</h1><blockquote><p>结构体是C语言的一种自定义的数据类型，在结构体中可以含有多种不同类型的数据。C++语言对结构体类型进行了扩充，它不仅可以含有不同类型的数据，而且还可以含有函数。</p></blockquote><p>例如下面声明了一个扩充的结构体Complex:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span>&#123;</span><span class="comment">//声明了一个名为Complex的结构体</span></span><br><span class="line">    <span class="keyword">double</span> real;<span class="comment">//复试的实部    </span></span><br><span class="line">    <span class="keyword">double</span> imag;<span class="comment">//复试的虚部</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">double</span> r,<span class="keyword">double</span> i)</span></span>&#123;</span><br><span class="line">        real=r;</span><br><span class="line">        imag=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">abscomplex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">double</span> t;</span><br><span class="line">        t=real*real+imag*imag;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体中的数据和成员都是结构体的成员，在C++中，通常把结构体中的数据成为数据成员，把函数称为成员函数。为了访问这些成员函数，必须先定义该结构体类型的变量，然后像访问结构体中的数据一样进行访问。</p><p><strong>C++提供了一种比结构体更安全有效的数据类型-类</strong>。类与结构体的扩充形式十分相似。上面的结构体类型Complex可以用类改写如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>&#123;</span><span class="comment">//声明了一个名为Complex的类</span></span><br><span class="line">    <span class="keyword">double</span> real;<span class="comment">//数据成员，复试的实部    </span></span><br><span class="line">    <span class="keyword">double</span> imag;<span class="comment">//数据成员，复试的虚部</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">double</span> r,<span class="keyword">double</span> i)</span></span>&#123;<span class="comment">//成员函数</span></span><br><span class="line">        real=r;</span><br><span class="line">        imag=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">abscomplex</span><span class="params">()</span></span>&#123;<span class="comment">//成员函数</span></span><br><span class="line">        <span class="keyword">double</span> t;</span><br><span class="line">        t=real*real+imag*imag;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sqrt</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>类是一种数据类型，它是一种用户定义的抽象的函数类型。C++规定，在默认情况下，类中的成员是私有的，结构体中成员是共有的。</p></blockquote><h1 id="2-类的声明"><a href="#2-类的声明" class="headerlink" title="2. 类的声明"></a>2. 类的声明</h1><p>可以得出，类类型声明的一般形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名&#123;</span></span><br><span class="line">    [<span class="keyword">private</span>:]</span><br><span class="line">    私有数据成员和成员函数</span><br><span class="line">    [<span class="keyword">public</span>:]</span><br><span class="line">        公有数据成员和成员函数</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>(1)私有成员(用private声明)包括数据成员和成员函数只能被类内的成员函数访问，公有成员(用public声明)包括数据成员和成员函数既可被类内的成员函数访问，也可被类外的对象访问。</p><p>(2)除了private和public之外，类中的成员还可以用另一个关键字protected来说明。被protected说明的数据成员和成员函数称为保护成员。保护成员可以由本类的成员函数访问，也可以由本类的派生类的成员函数访问。</p><p>(3)数据成员可以是任何数据成员，但不能是用自动(auto)、寄存器(register)或外部(extern)进行说明。</p><h1 id="3-成员函数的定义"><a href="#3-成员函数的定义" class="headerlink" title="3. 成员函数的定义"></a>3. 成员函数的定义</h1><blockquote><p>类的成员函数是函数的一种，它也有函数名、返回值类型和参数表，用法和普通函数差不多，只是它属于一个类的成员。<strong>成员函数可以访问本类中任何成员（包括private、protected、public）</strong>。</p></blockquote><p><strong>成员函数的三种定义方式</strong></p><blockquote><p><strong>第一种</strong>：在类声明中只给出成员函数的原型，而将成员函数的定义放在类的外部。<strong>(类内声明，类外定义)</strong></p></blockquote><p>这种成员函数在类外定义的一般形式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 类名：：成员函数名（参数表）&#123;</span><br><span class="line">    </span><br><span class="line">    函数体</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong>：在类声明中，成员函数的原型的参数表中可以不说明参数的名字，而只说明它们的类型。<strong>但是</strong>，在类外定义成员函数时，不但要说明参数表中的参数的类型，还必须要指出其参数名。</p><blockquote><p><strong>第二种：</strong>将成员函数直接定义在类的内部。</p></blockquote><p><strong>说明</strong>：编译器会将这些函数隐含地定义为内联成员函数。这种定义内联成员内联函数的方法没有使用关键字<strong>inline</strong>进行声明，因此称为<strong>隐式定义</strong>。</p><blockquote><p>第三种：在类内函数原型声明前或在类外定义成员函数前冠以关键字<strong>inline</strong>，因此称为<strong>显示定义</strong>。</p></blockquote><p><strong>说明</strong>：可以在声明函数原型和定义函数时同时写inline，也可以在其中一处声明inline，效果是相同的。都能按内联函数处理 。使用inline定义内联函数时，必须将类的声明和内联成员函数的定义都放在同一个文件（或同一个头文件中），否则编译时无法进行代码置换。</p><h1 id="4-对象的定义及使用"><a href="#4-对象的定义及使用" class="headerlink" title="4. 对象的定义及使用"></a>4. 对象的定义及使用</h1><h2 id="4-1-对象的定义"><a href="#4-1-对象的定义" class="headerlink" title="4.1 对象的定义"></a>4.1 对象的定义</h2><p>可以用以下两种方法定义对象：</p><p>（1）在声明类的同时，直接定义对象。即直接在声明类的右花括号“}”后，直接写出属于该类的对象名表。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setpoint</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getx</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">gety</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;op1,op2;</span><br></pre></td></tr></table></figure><p>在声明类Point的同时，直接定义了对象op1,op2。</p><p>（2）声明了类之后，在使用时再定义对象。其一般形式如下：<code>类名 对象名1，对象名2，..... ;</code></p><p>例如<code>Point op1,op2;</code></p><h2 id="4-2-对象中成员的访问"><a href="#4-2-对象中成员的访问" class="headerlink" title="4.2 对象中成员的访问"></a>4.2 对象中成员的访问</h2><blockquote><p>不论是数据成员，还是函数成员，只要是公有的，在类的外部可以通过类的对象进行访问。访问对象中的成员通常有一下三种方法。</p></blockquote><p>（1）<strong>通过对象名和对象选择符访问对象中的成员</strong></p><p>​    其一般形式是： <code>对象名.数据成员名</code> 或者 <code>对象名.成员函数名[(实参表)]</code></p><p>​    说明：<code>.</code>叫做对象选择符，简称点运算符</p><p>（2）<strong>通过指向对象的指针访问对象中的成员</strong></p><p>​    在定义对象时，若我们定义的是指向此对象的指针，则访问此对象的成员时，不能用<code>.</code>操作符，而应该使用<code>-&gt;</code>操作符。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">Date d,*ptr;</span><br><span class="line">ptr=&amp;d;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;ptr-&gt;year;</span><br></pre></td></tr></table></figure><p>在此，<code>ptr-&gt;year</code>表示<code>ptr</code>当前指向对象中<code>d</code>中的成员<code>year</code>，因为<code>（*ptr)</code>就是对象<code>d</code>，<code>(*ptr).year</code>表示的也就是对象<code>d</code>中的成员<code>year</code>。所以有如下等价关系：</p><p><img src="/2019/04/07/C++语法01-类和对象的基本概念/1.png" alt="图1"></p><p>（3）<strong>通过对象的引用访问对象中的成员</strong></p><p>​    如果为了一个对象定义了一个引用，也就是为这个对象起了一个别名、因此完全可以通过引用来访问对象中的成员，其方法与通过对象名来访问对象中的成员是相同的。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">Date d1;</span><br><span class="line">Date &amp;d2=d1;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;d1.year;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;d2.year;</span><br></pre></td></tr></table></figure><p>由于d2是d1的引用（即d2和d1占有相同的存储单），因此d2.year和d1.year是相同的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-结构体的扩充&quot;&gt;&lt;a href=&quot;#1-结构体的扩充&quot; class=&quot;headerlink&quot; title=&quot;1. 结构体的扩充&quot;&gt;&lt;/a&gt;1. 结构体的扩充&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;结构体是C语言的一种自定义的数据类型，在结构体中可以含有多种不
      
    
    </summary>
    
      <category term="C++" scheme="https://codave.github.io/categories/C/"/>
    
    
      <category term="类和对象" scheme="https://codave.github.io/tags/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础07-其他命令</title>
    <link href="https://codave.github.io/2019/03/24/Linux%E5%9F%BA%E7%A1%8007-%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/"/>
    <id>https://codave.github.io/2019/03/24/Linux基础07-其他命令/</id>
    <published>2019-03-24T05:03:16.000Z</published>
    <updated>2019-04-21T09:09:26.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-查找文件"><a href="#1-查找文件" class="headerlink" title="1. 查找文件"></a>1. 查找文件</h1><ul><li><code>find</code> 命令功能非常强大，通常用来在 <strong>特定的目录下</strong> <strong>搜索</strong> 符合条件的文件</li></ul><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>find [路径] -name “*.py”</td><td>查找指定路径下扩展名是 <code>.py</code> 的文件，包括子目录</td></tr></tbody></table><ul><li>如果省略路径，表示在当前文件夹下查找</li><li>之前学习的通配符，在使用 <code>find</code> 命令时同时可用</li><li>有关 <code>find</code> 的高级使用，见高级语法</li></ul><h2 id="演练目标"><a href="#演练目标" class="headerlink" title="演练目标"></a>演练目标</h2><ol><li>搜索桌面目录下，文件名包含 <code>1</code> 的文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name <span class="string">"*1*"</span></span><br></pre></td></tr></table></figure><ol start="2"><li>搜索桌面目录下，所有以 <code>.txt</code> 为扩展名的文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name <span class="string">"*.txt"</span></span><br></pre></td></tr></table></figure><ol start="3"><li>搜索桌面目录下，以数字 <code>1</code> 开头的文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -name <span class="string">"1*"</span></span><br></pre></td></tr></table></figure><h1 id="2-软链接"><a href="#2-软链接" class="headerlink" title="2. 软链接"></a>2. 软链接</h1><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ln -s 被链接的源文件 链接文件</td><td>建立文件的软链接，用通俗的方式讲<strong>类似于</strong> Windows 下的<strong>快捷方式</strong></td></tr></tbody></table><p>注意：</p><ol><li><p>没有-s选项建立的是一个硬链接文件,两个文件占用相同大小的硬盘空间，<strong>工作中几乎不会建立文件的硬链接</strong></p></li><li><p><strong>源文件要使用绝对路径</strong>，不能使用相对路径，这样可以方便移动链接文件后，仍然能够正常使用</p></li></ol><h2 id="演练目标-1"><a href="#演练目标-1" class="headerlink" title="演练目标"></a>演练目标</h2><ol><li>将桌面目录下的 <code>01.py</code> <strong>移动</strong>到 <code>demo/b/c</code> 目录下</li><li>在桌面目录下新建01.py的软链接FirstPython<br> 分别使用 <strong>相对路径</strong> 和 <strong>绝对路径</strong> 建立 <code>FirstPython</code> 的软链接</li><li>将 <code>FirstPython</code> <strong>移动</strong>到 <code>demo</code> 目录下，对比使用 <strong>相对路径</strong> 和 <strong>绝对路径</strong> 的区别</li></ol><h2 id="硬链接简介"><a href="#硬链接简介" class="headerlink" title="硬链接简介"></a>硬链接简介</h2><ul><li>在使用 <code>ln</code> 创建链接时，如果没有 <code>-s</code> 选项，会创建一个 <strong>硬链接</strong>，而不是软链接</li></ul><h3 id="硬链接演练"><a href="#硬链接演练" class="headerlink" title="硬链接演练"></a>硬链接演练</h3><ol><li>在 <code>~/Desktop/demo</code> 目录下建立 <code>~/Desktop/demo/b/c/01.py</code> 的硬链接 <code>01_hard</code></li><li>使用 <code>ls -l</code> 查看文件的<strong>硬链接数</strong>（硬链接——有多少种方式可以访问文件或者目录）</li><li>删除 <code>~/Desktop/demo/b/c/01.py</code>，并且使用 <code>tree</code> 来确认 <code>demo</code> 目录下的三个链接文件</li></ol><blockquote><p>在 Linux 中，<strong>文件名</strong> 和 <strong>文件的数据</strong> 是分开存储的</p></blockquote><p><strong>提示：</strong></p><ul><li>在 Linux 中，只有文件的 <code>硬链接数 == 0</code> 才会被删除</li><li>使用 <code>ls -l</code> 可以查看一个文件的硬链接的数量</li><li>在日常工作中，几乎不会建立文件的硬链接，知道即可</li></ul><h1 id="3-打包压缩"><a href="#3-打包压缩" class="headerlink" title="3. 打包压缩"></a>3. 打包压缩</h1><ul><li><strong>打包压缩</strong> 是日常工作中备份文件的一种方式</li><li>在不同操作系统中，常用的打包压缩方式是不同的<ul><li><code>Windows</code> 常用 <code>rar</code></li><li><code>Mac</code> 常用 <code>zip</code></li><li><code>Linux</code> 常用 <code>tar.gz</code></li></ul></li></ul><h2 id="3-1-打包-／-解包"><a href="#3-1-打包-／-解包" class="headerlink" title="3.1 打包 ／ 解包"></a>3.1 打包 ／ 解包</h2><ul><li><code>tar</code> 是 Linux 中最常用的 <strong>备份</strong>工具，此命令可以 <strong>把一系列文件</strong> 打包到 <strong>一个大文件中</strong>，也可以把一个 <strong>打包的大文件恢复成一系列文件</strong></li><li><code>tar</code> 的命令格式如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打包文件</span></span><br><span class="line">tar -cvf 打包文件.tar 被打包的文件／路径...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解包文件</span></span><br><span class="line">tar -xvf 打包文件.tar</span><br></pre></td></tr></table></figure><ul><li><code>tar</code> 选项说明</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>c</td><td>生成档案文件，创建打包文件</td></tr><tr><td>x</td><td>解开档案文件</td></tr><tr><td>v</td><td>列出归档解档的详细过程，显示进度</td></tr><tr><td>f</td><td>指定档案文件名称，f 后面一定是 .tar 文件，所以必须放选项最后</td></tr></tbody></table><blockquote><p>注意：<code>f</code> 选项必须放在最后，其他选项顺序可以随意</p></blockquote><h3 id="打包解包演练"><a href="#打包解包演练" class="headerlink" title="打包解包演练"></a>打包解包演练</h3><ol><li>删除桌面下的所有内容</li><li>在桌面下新建三个空白文件 <code>01.py</code>、<code>02.py</code>、<code>03.py</code></li><li>将这三个文件打一个 <code>py.tar</code> 的包</li><li>新建 <code>tar</code> 目录，并且将 <code>py.tar</code> 移动到 <code>tar</code> 目录下</li><li>解包 <code>py.tar</code></li></ol><h2 id="3-2-压缩／解压缩"><a href="#3-2-压缩／解压缩" class="headerlink" title="3.2 压缩／解压缩"></a>3.2 压缩／解压缩</h2><h3 id="1-gzip"><a href="#1-gzip" class="headerlink" title="1) gzip"></a>1) <code>gzip</code></h3><ul><li>tar与gzip命令结合可以使用实现文件打包和压缩<ul><li><code>tar</code> 只负责打包文件，但不压缩</li><li>用 <code>gzip</code> 压缩 <code>tar</code> 打包后的文件，其扩展名一般用 <code>xxx.tar.gz</code></li></ul></li></ul><blockquote><p>在 <code>Linux</code> 中，最常见的压缩文件格式就是 <code>xxx.tar.gz</code></p></blockquote><ul><li>在 <code>tar</code> 命令中有一个选项 <strong>-z</strong> 可以调用 <code>gzip</code>，从而可以方便的实现压缩和解压缩的功能</li><li>命令格式如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压缩文件</span></span><br><span class="line">tar -zcvf 打包文件.tar.gz 被压缩的文件／路径...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩文件</span></span><br><span class="line">tar -zxvf 打包文件.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩到指定路径</span></span><br><span class="line">tar -zxvf 打包文件.tar.gz -C 目标路径</span><br></pre></td></tr></table></figure><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-C</td><td>解压缩到指定目录，注意：要解压缩的目录必须存在</td></tr></tbody></table><h3 id="2-bzip2"><a href="#2-bzip2" class="headerlink" title="2) bzip2"></a>2) <code>bzip2</code></h3><ul><li><code>tar</code> 与 <code>bzip2</code> 命令结合可以使用实现文件 <strong>打包和压缩</strong>（用法和 <code>gzip</code> 一样）<ul><li><code>tar</code> 只负责打包文件，但不压缩，</li><li>用 <code>bzip2</code> 压缩 <code>tar</code> 打包后的文件，其扩展名一般用 <code>xxx.tar.bz2</code></li></ul></li><li>在 <code>tar</code> 命令中有一个选项 <strong>-j</strong> 可以调用 <code>bzip2</code>，从而可以方便的实现压缩和解压缩的功能</li><li>命令格式如下：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 压缩文件</span></span><br><span class="line">tar -jcvf 打包文件.tar.bz2 被压缩的文件／路径...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压缩文件</span></span><br><span class="line">tar -jxvf 打包文件.tar.bz2</span><br></pre></td></tr></table></figure><h1 id="4-软件安装"><a href="#4-软件安装" class="headerlink" title="4. 软件安装"></a>4. 软件安装</h1><h2 id="4-1-通过-apt-安装／卸载软件"><a href="#4-1-通过-apt-安装／卸载软件" class="headerlink" title="4.1 通过 apt 安装／卸载软件"></a>4.1 通过 apt 安装／卸载软件</h2><ul><li>apt 是 <code>Advanced Packaging Tool</code>，是 Linux 下的一款安装包管理工具</li><li>可以在终端中方便的 <strong>安装</strong>／<strong>卸载</strong>／<strong>更新软件包</strong></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 安装软件</span></span><br><span class="line">$ sudo apt install 软件包</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 卸载软件</span></span><br><span class="line">$ sudo apt remove 软件名</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 更新已安装的包</span></span><br><span class="line">$ sudo apt upgrade</span><br></pre></td></tr></table></figure><h3 id="安装演练"><a href="#安装演练" class="headerlink" title="安装演练"></a>安装演练</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个小火车提示</span></span><br><span class="line">$ sudo apt install sl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个比较漂亮的查看当前进程排名的软件</span></span><br><span class="line">$ sudo apt install htop</span><br></pre></td></tr></table></figure><h2 id="4-2-配置软件源"><a href="#4-2-配置软件源" class="headerlink" title="4.2 配置软件源"></a>4.2 配置软件源</h2><p>在Ubantu18.04版本在系统设置里面是找不到软件源设置界面按钮的，可用如下指令帮助启动图形界面以便设置软件源。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-manager -c -d</span><br></pre></td></tr></table></figure><ul><li><p>如果希望在 <code>ubuntu</code> 中安装软件，<strong>更加快速</strong>，可以通过设置<strong>镜像源</strong>，选择一个访问网速更快的服务器，来提供软件下载／安装服务</p></li><li><p>提示：更换服务器之后，需要一个相对比较长时间的更新过程，需要耐心等待。更新完成后，再安装软件都会从新设置的服务器下载软件了</p></li></ul><blockquote><p>所谓镜像源，就是<strong>所有服务器的内容是相同的（镜像）</strong>，但是根据所在位置不同，国内服务器通常速度会更快一些！</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-查找文件&quot;&gt;&lt;a href=&quot;#1-查找文件&quot; class=&quot;headerlink&quot; title=&quot;1. 查找文件&quot;&gt;&lt;/a&gt;1. 查找文件&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;find&lt;/code&gt; 命令功能非常强大，通常用来在 &lt;strong&gt;特定的目录
      
    
    </summary>
    
      <category term="Linux" scheme="https://codave.github.io/categories/Linux/"/>
    
    
      <category term="Linux基础" scheme="https://codave.github.io/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础06-系统信息相关命令</title>
    <link href="https://codave.github.io/2019/03/24/Linux%E5%9F%BA%E7%A1%8006-%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"/>
    <id>https://codave.github.io/2019/03/24/Linux基础06-系统信息相关命令/</id>
    <published>2019-03-24T05:02:08.000Z</published>
    <updated>2019-03-24T05:32:16.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-时间和日期"><a href="#1-时间和日期" class="headerlink" title="1. 时间和日期"></a>1. 时间和日期</h1><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>date</td><td>查看系统时间</td></tr><tr><td>02</td><td>cal</td><td><code>calendar</code> 查看日历，<code>-y</code> 选项可以查看一年的日历</td></tr></tbody></table><h1 id="2-磁盘信息"><a href="#2-磁盘信息" class="headerlink" title="2. 磁盘信息"></a>2. 磁盘信息</h1><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>df -h</td><td><code>disk free</code> 显示磁盘剩余空间</td></tr><tr><td>02</td><td>du -h [目录名]</td><td><code>disk usage</code> 显示目录下的文件大小</td></tr></tbody></table><ul><li>选项说明</li></ul><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-h</td><td>以人性化的方式显示文件大小</td></tr></tbody></table><h1 id="3-进程信息"><a href="#3-进程信息" class="headerlink" title="3. 进程信息"></a>3. 进程信息</h1><ul><li>所谓 <strong>进程</strong>，通俗地说就是 <strong>当前正在执行的一个程序</strong></li></ul><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ps aux</td><td><code>process status</code> 查看进程的详细状况</td></tr><tr><td>02</td><td>top</td><td>动态显示运行中的进程并且排序</td></tr><tr><td>03</td><td>kill [-9] 进程代号</td><td>终止指定代号的进程，<code>-9</code> 表示强行终止</td></tr></tbody></table><blockquote><p><code>ps</code> 默认只会显示当前用户通过终端启动的应用程序</p></blockquote><ul><li><code>ps</code> 选项说明功能</li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>a</td><td>显示终端上的所有进程，包括其他用户的进程</td></tr><tr><td>u</td><td>显示进程的详细状态</td></tr><tr><td>x</td><td>显示没有控制终端的进程</td></tr></tbody></table><blockquote><p>提示：使用 <code>kill</code> 命令时，最好只终止由当前用户开启的进程，而不要终止 <code>root</code> 身份开启的进程，否则可能导致系统崩溃</p><ul><li>要退出 <code>top</code> 可以直接输入 <code>q</code></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-时间和日期&quot;&gt;&lt;a href=&quot;#1-时间和日期&quot; class=&quot;headerlink&quot; title=&quot;1. 时间和日期&quot;&gt;&lt;/a&gt;1. 时间和日期&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;序号&lt;/th&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;作用
      
    
    </summary>
    
      <category term="Linux" scheme="https://codave.github.io/categories/Linux/"/>
    
    
      <category term="Linux基础" scheme="https://codave.github.io/tags/Linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
